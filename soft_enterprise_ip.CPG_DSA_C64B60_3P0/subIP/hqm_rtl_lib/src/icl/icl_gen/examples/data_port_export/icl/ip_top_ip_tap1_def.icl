// ICL  : generated by tap_icl_gen.pl version 1.0
// TIME : Mon Jan 25 13:03:40 2021


Module ip_top_ip_tap1_def {

   Attribute intel_desc = "IP description";

   //--------------------------------------------------------------------------------
   //Local Parameters
   Parameter IR_SIZE = 8;

   LocalParameter RED     = 2'b11;
   LocalParameter ORANGE  = 2'bx1;
   LocalParameter GREEN   = 2'bxx;

   //--------------------------------------------------------------------------------
   //TAP Opcodes
   LocalParameter SLVIDCODE_OPCODE = 'hc;
   LocalParameter regA_OPCODE = 'h30;
   LocalParameter regB_OPCODE = 'h40;
   LocalParameter BYPASS_OPCODE = 'hff;

   //--------------------------------------------------------------------------------
   //TAP DR Sizes
   LocalParameter SLVIDCODE_DR_SIZE = 32;
   LocalParameter regA_DR_SIZE = 6;
   LocalParameter regB_DR_SIZE = 12;
   LocalParameter BYPASS_DR_SIZE = 1;

   //--------------------------------------------------------------------------------
   //TAP DR Security Levels
   LocalParameter SLVIDCODE_SECURITY = $GREEN;
   LocalParameter regA_SECURITY = $RED;
   LocalParameter regB_SECURITY = $GREEN;
   LocalParameter BYPASS_SECURITY = $GREEN;

   //--------------------------------------------------------------------------------
   //OPCODE Enum
   Enum TAP_INSTRUCTIONS {
      SLVIDCODE = $SLVIDCODE_OPCODE;
      regA = $regA_OPCODE;
      regB = $regB_OPCODE;
      BYPASS = $BYPASS_OPCODE;
   }

   //--------------------------------------------------------------------------------
   // TAP ports & interfaces
   // All ports in ICL must match corresponding RTL module port names

   ScanInPort    Tdi;
   ScanOutPort   Tdo { Source tdo_mux;}
   TMSPort       Tms;
   TRSTPort      Trstb;
   TCKPort       Tclk;

   // DFx powergood/reset ports
   ResetPort      fdfx_powergood { ActivePolarity 0;}

   // DFx Secure Interface
   //Note: fdfx_earlyboot_exit/fdfx_policy_update are not required to be modeled in ICL
   DataInPort    fdfx_secure_policy[3:0] { RefEnum TAP_SECURITY;}

   Enum TAP_SECURITY {
      SECURITY_LOCKED      = 4'h0;
      FUNCTIONALITY_LOCKED = 4'h1;
      SECURITY_UNLOCKED    = 4'h2;
      RESERVED             = 4'h3;
      INTEL_UNLOCKED       = 4'h4;
      OEM_UNLOCKED         = 4'h5;
      ENDEBUG_UNLOCKED     = 4'h6;
      INFRARED_UNLOCKED    = 4'h7;
      DRAM_DEBUG_UNLOCKED  = 4'h8;
      FUSA_UNLOCKED        = 4'h9;
      USER4_UNLOCKED       = 4'ha;
      USER5_UNLOCKED       = 4'hb;
      USER6_UNLOCKED       = 4'hc;
      USER7_UNLOCKED       = 4'hd;
      USER8_UNLOCKED       = 4'he;
      PART_DISABLED        = 4'hf;
   }

   // Client TAP/JTAG interface
   ScanInterface c_tap {
      Port   Tdi;
      Port   Tdo;
      Port   Tms;
   }

   //--------------------------------------------------------------------------------
   // Base TAP logic
   //--------------------------------------------------------------------------------

   // TaP FSM
   Instance fsm Of iclgen_intel_tap_fsm {
     InputPort   tck   = Tclk;
     InputPort   tms   = Tms;
     InputPort   trstb = Trstb;
   }

   // Intel TAP security
   Instance security Of iclgen_intel_dfxsecure_plugin {
      InputPort   fdfx_secure_policy = fdfx_secure_policy[3:0];
   }

   LogicSignal   unlock_red {
      security.dfxsecure_feature_en[2];
   }

   LogicSignal   unlock_orange_or_red {
      security.dfxsecure_feature_en[2] | security.dfxsecure_feature_en[1];
   }

   // TAP IR
   Instance IR Of iclgen_intel_tap_ir {
     Parameter   IR_SIZE        = $IR_SIZE;
     Parameter   IR_RESET_VALUE = $SLVIDCODE_OPCODE;
     Parameter   IR_CAPTURE_SRC = 'hx;
     Attribute   intel_TapIrCaptureValue = 'h1;
     InputPort    si             = Tdi;
     InputPort    rst            = fsm.tlr;
   }
   Alias IR[$IR_SIZE-1:0] = IR.IR { RefEnum TAP_INSTRUCTIONS; }

   //TAP TDR selection & TDO muxing
   ScanMux tdo_mux SelectedBy fsm.irsel {
      1'b0:    dr_mux;
      1'b1:    IR.so;
   }

   ScanMux dr_mux SelectedBy IR.tir_out, unlock_red, unlock_orange_or_red {
      $SLVIDCODE_OPCODE, $SLVIDCODE_SECURITY: SLVIDCODE.so;
      $regA_OPCODE, $regA_SECURITY: regA.so;
      $regB_OPCODE, $regB_SECURITY: regB.so;
      $BYPASS_OPCODE, $BYPASS_SECURITY: BYPASS.so;
      'bx, $GREEN: BYPASS_RSVD.so;
   }

   //--------------------------------------------------------------------------------
   // TaP TDRs

   // BYPASS for reserved opcodes
   Instance BYPASS_RSVD Of iclgen_intel_bypass_rsvd_reg {
     Attribute   intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
     InputPort   si  = Tdi;
   }

   //---------------------------
   DataInPort     tdr_in_SLVIDCODE[31:0];

   Instance SLVIDCODE Of ip_top_ip_tap1_def_slvidcode_def {
      Attribute intel_RegOpcode = 'hc;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = Tdi;
      InputPort   rstn = fdfx_powergood;
      InputPort   tdr_in = tdr_in_SLVIDCODE;
   }
   Alias SLVIDCODE[$SLVIDCODE_DR_SIZE-1:0] = SLVIDCODE.DR;

   //---------------------------
   DataOutPort    tdr_out_regA__f1[3:0] { Source regA.tdr_out_f1;}

   Instance regA Of ip_top_ip_tap1_def_regA_def {
      Attribute intel_RegOpcode = 'h30;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_RED";
      Attribute intel_TapRegResetType = "PWRGOOD";
      InputPort   si = Tdi;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regA[$regA_DR_SIZE-1:0] = regA.DR;

   //---------------------------
   Instance regB Of ip_top_ip_tap1_def_regB_def {
      Attribute intel_RegOpcode = 'h40;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = Tdi;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regB[$regB_DR_SIZE-1:0] = regB.DR;

   //---------------------------
   Instance BYPASS Of ip_top_ip_tap1_def_bypass_def {
      Attribute intel_RegOpcode = 'hff;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = Tdi;
      InputPort   rstn = fdfx_powergood;
   }
   Alias BYPASS[$BYPASS_DR_SIZE-1:0] = BYPASS.DR;
} // end of ip_top_ip_tap1_def


// Chain Definitions

// Register Definitions
//---------------------------
Module ip_top_ip_tap1_def_slvidcode_def {

   Attribute intel_desc = "Slave ID Code register";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   DataInPort    tdr_in[31:0];

   ScanRegister DR[31:0] {
      ScanInSource   si;
      ResetValue     32'b1001000110100010101100111;
      CaptureSource  tdr_in;
   }
   Alias value[31:0] = DR[31:0] {
      Attribute intel_desc = "Slave ID code value for given TAP.";
      Attribute intel_AccessType = "RO";
   }
} // end of ip_top_ip_tap1_def_slvidcode_def

//---------------------------
Module ip_top_ip_tap1_def_regA_def {

   Attribute intel_desc = "regA description";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   DataOutPort    tdr_out_f1[3:0] { Source f1;}

   ScanRegister DR[5:0] {
      ScanInSource   si;
      ResetValue     6'b0;
      CaptureSource  2'bx,DR[3:0];
   }
   Alias f1[3:0] = DR[3:0] {
      Attribute intel_desc = "f1 description";
      Attribute intel_AccessType = "RW";
   }
   Alias f2[0:0] = DR[4:4] {
      Attribute intel_desc = "f2 description";
      Attribute intel_AccessType = "RW/V";
   }
   Alias f3[0:0] = DR[5:5] {
      Attribute intel_desc = "f3 description";
      Attribute intel_AccessType = "WO";
   }
} // end of ip_top_ip_tap1_def_regA_def

//---------------------------
Module ip_top_ip_tap1_def_regB_def {

   Attribute intel_desc = "regB description";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[11:0] {
      ScanInSource   si;
      ResetValue     12'b101;
      CaptureSource  8'bx,4'b101;
   }
   Alias f1[3:0] = DR[3:0] {
      Attribute intel_desc = "f1 description";
      Attribute intel_AccessType = "RO";
   }
   Alias f2[7:0] = DR[11:4] {
      Attribute intel_desc = "f2 description";
      Attribute intel_AccessType = "RO/V";
   }
} // end of ip_top_ip_tap1_def_regB_def

//---------------------------
Module ip_top_ip_tap1_def_bypass_def {

   Attribute intel_desc = "TAP BYPASS Register";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[0:0] {
      ScanInSource   si;
      ResetValue     1'b0;
      CaptureSource  1'b0;
   }
   Alias dr[0:0] = DR[0:0] {
      Attribute intel_desc = "A one bit <no action> register.";
      Attribute intel_AccessType = "RO";
   }
} // end of ip_top_ip_tap1_def_bypass_def

