// ICL  : generated by tap_icl_gen.pl version 1.0
// TIME : Mon Jan 25 13:10:38 2021


Module ip {

   Attribute intel_desc = "IP description";

   //--------------------------------------------------------------------------------
   //Local Parameters
   Parameter IR_SIZE = 8;

   LocalParameter RED     = 2'b11;
   LocalParameter ORANGE  = 2'bx1;
   LocalParameter GREEN   = 2'bxx;

   //--------------------------------------------------------------------------------
   //TAP Opcodes
   LocalParameter SLVIDCODE_OPCODE = 'hc;
   LocalParameter regA1_OPCODE = 'h30;
   LocalParameter regA2_OPCODE = 'h31;
   LocalParameter regB_OPCODE = 'h40;
   LocalParameter BYPASS_OPCODE = 'hff;

   //--------------------------------------------------------------------------------
   //TAP DR Sizes
   LocalParameter SLVIDCODE_DR_SIZE = 32;
   LocalParameter regA1_DR_SIZE = 6;
   LocalParameter regA2_DR_SIZE = 6;
   LocalParameter regB_DR_SIZE = 12;
   LocalParameter BYPASS_DR_SIZE = 1;

   //--------------------------------------------------------------------------------
   //TAP DR Security Levels
   LocalParameter SLVIDCODE_SECURITY = $GREEN;
   LocalParameter regA1_SECURITY = $RED;
   LocalParameter regA2_SECURITY = $RED;
   LocalParameter regB_SECURITY = $GREEN;
   LocalParameter BYPASS_SECURITY = $GREEN;

   //--------------------------------------------------------------------------------
   //OPCODE Enum
   Enum TAP_INSTRUCTIONS {
      SLVIDCODE = $SLVIDCODE_OPCODE;
      regA1 = $regA1_OPCODE;
      regA2 = $regA2_OPCODE;
      regB = $regB_OPCODE;
      BYPASS = $BYPASS_OPCODE;
   }

   //--------------------------------------------------------------------------------
   // TAP ports & interfaces
   // All ports in ICL must match corresponding RTL module port names

   ScanInPort    TdiT731L;
   ScanOutPort   TdoT731H { Source tdo_mux;}
   TMSPort       TmsT731L;
   TRSTPort      TrstbT731L;
   TCKPort       Tclk;

   // DFx powergood/reset ports
   ResetPort      fdfx_powergood { ActivePolarity 0;}

   DataInPort     feature_en[2:2];
   DataInPort     feature_en[1:1];

   // Client TAP/JTAG interface
   ScanInterface c_tap {
      Port   TdiT731L;
      Port   TdoT731H;
      Port   TmsT731L;
   }

   //--------------------------------------------------------------------------------
   // Base TAP logic
   //--------------------------------------------------------------------------------

   // TaP FSM
   Instance fsm Of iclgen_intel_tap_fsm {
     InputPort   tck   = Tclk;
     InputPort   tms   = TmsT731L;
     InputPort   trstb = TrstbT731L;
   }

   LogicSignal   unlock_red {
       feature_en[2:2];
   }

   LogicSignal   unlock_orange_or_red {
       feature_en[2:2] | feature_en[1:1];
   }

   // TAP IR
   Instance IR Of iclgen_intel_tap_ir {
     Parameter   IR_SIZE        = $IR_SIZE;
     Parameter   IR_RESET_VALUE = $SLVIDCODE_OPCODE;
     Parameter   IR_CAPTURE_SRC = 'hx;
     Attribute   intel_TapIrCaptureValue = 'h1;
     InputPort    si             = TdiT731L;
     InputPort    rst            = fsm.tlr;
   }
   Alias IR[$IR_SIZE-1:0] = IR.IR { RefEnum TAP_INSTRUCTIONS; }

   //TAP TDR selection & TDO muxing
   ScanMux tdo_mux SelectedBy fsm.irsel {
      1'b0:    dr_mux;
      1'b1:    IR.so;
   }

   ScanMux dr_mux SelectedBy IR.tir_out, unlock_red, unlock_orange_or_red {
      $SLVIDCODE_OPCODE, $SLVIDCODE_SECURITY: SLVIDCODE.so;
      $regA1_OPCODE, $regA1_SECURITY: regA1.so;
      $regA2_OPCODE, $regA2_SECURITY: regA2.so;
      $regB_OPCODE, $regB_SECURITY: regB.so;
      $BYPASS_OPCODE, $BYPASS_SECURITY: BYPASS.so;
      'bx, $GREEN: BYPASS_RSVD.so;
   }

   //--------------------------------------------------------------------------------
   // TaP TDRs

   // BYPASS for reserved opcodes
   Instance BYPASS_RSVD Of iclgen_intel_bypass_rsvd_reg {
     Attribute   intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
     InputPort   si  = TdiT731L;
   }

   //---------------------------

   // SLVIDCODE strap
   DataInPort     ftap_slvidcode[31:0];

   Instance SLVIDCODE Of iclgen_intel_slvidcode_strap_reg {
      Attribute intel_RegOpcode = 'hc;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = TdiT731L;
      InputPort   ftap_slvidcode = ftap_slvidcode[31:0];
   }
   Alias SLVIDCODE[$SLVIDCODE_DR_SIZE-1:0] = SLVIDCODE.DR;

   //---------------------------
   Instance regA1 Of ip_with_tap_def_regA_def {
      Attribute intel_RegOpcode = 'h30;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_RED";
      Attribute intel_TapRegResetType = "PWRGOOD";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regA1[$regA1_DR_SIZE-1:0] = regA1.DR;

   //---------------------------
   Instance regA2 Of ip_with_tap_def_regA_def {
      Attribute intel_RegOpcode = 'h31;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_RED";
      Attribute intel_TapRegResetType = "PWRGOOD";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regA2[$regA2_DR_SIZE-1:0] = regA2.DR;

   //---------------------------
   Instance regB Of ip_with_tap_def_regB_def {
      Attribute intel_RegOpcode = 'h40;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regB[$regB_DR_SIZE-1:0] = regB.DR;

   //---------------------------
   Instance BYPASS Of ip_with_tap_def_bypass_def {
      Attribute intel_RegOpcode = 'hff;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias BYPASS[$BYPASS_DR_SIZE-1:0] = BYPASS.DR;

   // Other Ports (not used)
   // -----------------------
    DataInPort   feature_en[0:0];

} // end of ip


// Chain Definitions

// Register Definitions
//---------------------------
Module ip_with_tap_def_regA_def {

   Attribute intel_desc = "regA description";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[5:0] {
      ScanInSource   si;
      ResetValue     6'b0;
      CaptureSource  2'bx,DR[3:0];
   }
   Alias f1[3:0] = DR[3:0] {
      Attribute intel_desc = "f1 description";
      Attribute intel_AccessType = "RW";
   }
   Alias f2[0:0] = DR[4:4] {
      Attribute intel_desc = "f2 description";
      Attribute intel_AccessType = "RW/V";
   }
   Alias f3[0:0] = DR[5:5] {
      Attribute intel_desc = "f3 description";
      Attribute intel_AccessType = "WO";
   }
} // end of ip_with_tap_def_regA_def

//---------------------------
Module ip_with_tap_def_regB_def {

   Attribute intel_desc = "regB description";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[11:0] {
      ScanInSource   si;
      ResetValue     12'b101;
      CaptureSource  8'bx,4'b101;
   }
   Alias f1[3:0] = DR[3:0] {
      Attribute intel_desc = "f1 description";
      Attribute intel_AccessType = "RO";
   }
   Alias f2[7:0] = DR[11:4] {
      Attribute intel_desc = "f2 description";
      Attribute intel_AccessType = "RO/V";
   }
} // end of ip_with_tap_def_regB_def

//---------------------------
Module ip_with_tap_def_bypass_def {

   Attribute intel_desc = "TAP BYPASS Register";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[0:0] {
      ScanInSource   si;
      ResetValue     1'b0;
      CaptureSource  1'b0;
   }
   Alias dr[0:0] = DR[0:0] {
      Attribute intel_desc = "A one bit <no action> register.";
      Attribute intel_AccessType = "RO";
   }
} // end of ip_with_tap_def_bypass_def

