// ICL  : generated by tap_icl_gen.pl version 1.0
// TIME : Mon Jan 25 13:05:40 2021


Module ip {

   Attribute intel_desc = "IP description";

   //--------------------------------------------------------------------------------
   //Local Parameters
   Parameter IR_SIZE = 8;

   LocalParameter RED     = 2'b11;
   LocalParameter ORANGE  = 2'bx1;
   LocalParameter GREEN   = 2'bxx;

   //--------------------------------------------------------------------------------
   //TAP Opcodes
   LocalParameter SLVIDCODE_OPCODE = 'hc;
   LocalParameter regA1_OPCODE = 'h30;
   LocalParameter regA2_OPCODE = 'h31;
   LocalParameter RTDR_OPCODE = 'h40;
   LocalParameter BYPASS_OPCODE = 'hff;

   //--------------------------------------------------------------------------------
   //TAP DR Sizes
   LocalParameter SLVIDCODE_DR_SIZE = 32;
   LocalParameter regA1_DR_SIZE = 6;
   LocalParameter regA2_DR_SIZE = 6;
   LocalParameter RTDR_DR_SIZE = "RTDR";
   LocalParameter BYPASS_DR_SIZE = 1;

   //--------------------------------------------------------------------------------
   //TAP DR Security Levels
   LocalParameter SLVIDCODE_SECURITY = $GREEN;
   LocalParameter regA1_SECURITY = $RED;
   LocalParameter regA2_SECURITY = $RED;
   LocalParameter RTDR_SECURITY = $GREEN;
   LocalParameter BYPASS_SECURITY = $GREEN;

   //--------------------------------------------------------------------------------
   //OPCODE Enum
   Enum TAP_INSTRUCTIONS {
      SLVIDCODE = $SLVIDCODE_OPCODE;
      regA1 = $regA1_OPCODE;
      regA2 = $regA2_OPCODE;
      RTDR = $RTDR_OPCODE;
      BYPASS = $BYPASS_OPCODE;
   }

   //--------------------------------------------------------------------------------
   // TAP ports & interfaces
   // All ports in ICL must match corresponding RTL module port names

   ScanInPort    TdiT731L;
   ScanOutPort   TdoT731H { Source tdo_mux;}
   TMSPort       TmsT731L;
   TRSTPort      TrstbT731L;
   TCKPort       Tclk;

   // DFx powergood/reset ports
   ResetPort      fdfx_powergood { ActivePolarity 0;}

   // DFx Secure Interface
   //Note: fdfx_earlyboot_exit/fdfx_policy_update are not required to be modeled in ICL
   DataInPort    fdfx_secure_policy[3:0] { RefEnum TAP_SECURITY;}

   Enum TAP_SECURITY {
      SECURITY_LOCKED      = 4'h0;
      FUNCTIONALITY_LOCKED = 4'h1;
      SECURITY_UNLOCKED    = 4'h2;
      RESERVED             = 4'h3;
      INTEL_UNLOCKED       = 4'h4;
      OEM_UNLOCKED         = 4'h5;
      ENDEBUG_UNLOCKED     = 4'h6;
      INFRARED_UNLOCKED    = 4'h7;
      DRAM_DEBUG_UNLOCKED  = 4'h8;
      FUSA_UNLOCKED        = 4'h9;
      USER4_UNLOCKED       = 4'ha;
      USER5_UNLOCKED       = 4'hb;
      USER6_UNLOCKED       = 4'hc;
      USER7_UNLOCKED       = 4'hd;
      USER8_UNLOCKED       = 4'he;
      PART_DISABLED        = 4'hf;
   }

   // Client TAP/JTAG interface
   ScanInterface c_tap {
      Port   TdiT731L;
      Port   TdoT731H;
      Port   TmsT731L;
   }

   // Host RTDR interfaces
   // --------------------
   // RTDR RTDR

   ScanInPort   	rtdr_so;
   ScanOutPort   	rtdr_si { Source TdiT731L;}
   ToSelectPort   	rtdr_sel { Source sel_RTDR;}

   ScanInterface h_RTDR {
      Port   rtdr_so;
      Port   rtdr_si;
      Port   rtdr_sel;
      Attribute intel_RegOpcode = 'h40;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
   }

   //--------------------------------------------------------------------------------
   // Base TAP logic
   //--------------------------------------------------------------------------------

   // TaP FSM
   Instance fsm Of iclgen_intel_tap_fsm {
     InputPort   tck   = Tclk;
     InputPort   tms   = TmsT731L;
     InputPort   trstb = TrstbT731L;
   }

   // Intel TAP security
   Instance security Of iclgen_intel_dfxsecure_plugin {
      InputPort   fdfx_secure_policy = fdfx_secure_policy[3:0];
   }

   LogicSignal   unlock_red {
      security.dfxsecure_feature_en[2];
   }

   LogicSignal   unlock_orange_or_red {
      security.dfxsecure_feature_en[2] | security.dfxsecure_feature_en[1];
   }

   // TAP IR
   Instance IR Of iclgen_intel_tap_ir {
     Parameter   IR_SIZE        = $IR_SIZE;
     Parameter   IR_RESET_VALUE = $SLVIDCODE_OPCODE;
     Parameter   IR_CAPTURE_SRC = 'hx;
     Attribute   intel_TapIrCaptureValue = 'h1;
     InputPort    si             = TdiT731L;
     InputPort    rst            = fsm.tlr;
   }
   Alias IR[$IR_SIZE-1:0] = IR.IR { RefEnum TAP_INSTRUCTIONS; }

   //TAP TDR selection & TDO muxing
   ScanMux tdo_mux SelectedBy fsm.irsel {
      1'b0:    dr_mux;
      1'b1:    IR.so;
   }

   ScanMux dr_mux SelectedBy IR.tir_out, unlock_red, unlock_orange_or_red {
      $SLVIDCODE_OPCODE, $SLVIDCODE_SECURITY: SLVIDCODE.so;
      $regA1_OPCODE, $regA1_SECURITY: regA1.so;
      $regA2_OPCODE, $regA2_SECURITY: regA2.so;
      $RTDR_OPCODE, $RTDR_SECURITY: rtdr_so;
      $BYPASS_OPCODE, $BYPASS_SECURITY: BYPASS.so;
      'bx, $GREEN: BYPASS_RSVD.so;
   }

   //--------------------------------------------------------------------------------
   // TaP TDRs

   // BYPASS for reserved opcodes
   Instance BYPASS_RSVD Of iclgen_intel_bypass_rsvd_reg {
     Attribute   intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
     InputPort   si  = TdiT731L;
   }

   //---------------------------

   // SLVIDCODE strap
   DataInPort     ftap_slvidcode[31:0];

   Instance SLVIDCODE Of iclgen_intel_slvidcode_strap_reg {
      Attribute intel_RegOpcode = 'hc;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = TdiT731L;
      InputPort   ftap_slvidcode = ftap_slvidcode[31:0];
   }
   Alias SLVIDCODE[$SLVIDCODE_DR_SIZE-1:0] = SLVIDCODE.DR;

   //---------------------------
   Instance regA1 Of ip_with_tap_def_regA_def {
      Attribute intel_RegOpcode = 'h30;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_RED";
      Attribute intel_TapRegResetType = "PWRGOOD";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regA1[$regA1_DR_SIZE-1:0] = regA1.DR;

   //---------------------------
   Instance regA2 Of ip_with_tap_def_regA_def {
      Attribute intel_RegOpcode = 'h31;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_RED";
      Attribute intel_TapRegResetType = "PWRGOOD";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias regA2[$regA2_DR_SIZE-1:0] = regA2.DR;

   //---------------------------
   // RTDR RTDR: Select signal

   DataMux sel_RTDR SelectedBy IR.tir_out, unlock_red, unlock_orange_or_red {
      $RTDR_OPCODE, $RTDR_SECURITY: 1'b1;
      'bx, $GREEN: 1'b0;
   }

   //---------------------------
   Instance BYPASS Of ip_with_tap_def_bypass_def {
      Attribute intel_RegOpcode = 'hff;
      Attribute intel_TapOpcodeSecurityLevel = "SECURE_GREEN";
      InputPort   si = TdiT731L;
      InputPort   rstn = fdfx_powergood;
   }
   Alias BYPASS[$BYPASS_DR_SIZE-1:0] = BYPASS.DR;
} // end of ip


// Chain Definitions

// Register Definitions
//---------------------------
Module ip_with_tap_def_regA_def {

   Attribute intel_desc = "regA description";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[5:0] {
      ScanInSource   si;
      ResetValue     6'b0;
      CaptureSource  2'bx,DR[3:0];
   }
   Alias f1[3:0] = DR[3:0] {
      Attribute intel_desc = "f1 description";
      Attribute intel_AccessType = "RW";
   }
   Alias f2[0:0] = DR[4:4] {
      Attribute intel_desc = "f2 description";
      Attribute intel_AccessType = "RW/V";
   }
   Alias f3[0:0] = DR[5:5] {
      Attribute intel_desc = "f3 description";
      Attribute intel_AccessType = "WO";
   }
} // end of ip_with_tap_def_regA_def

//---------------------------
Module ip_with_tap_def_bypass_def {

   Attribute intel_desc = "TAP BYPASS Register";

   ScanInPort    si;
   ScanOutPort   so   { Source DR[0];}
   ResetPort     rstn { ActivePolarity 0;}
   SelectPort    sel;

   ScanRegister DR[0:0] {
      ScanInSource   si;
      ResetValue     1'b0;
      CaptureSource  1'b0;
   }
   Alias dr[0:0] = DR[0:0] {
      Attribute intel_desc = "A one bit <no action> register.";
      Attribute intel_AccessType = "RO";
   }
} // end of ip_with_tap_def_bypass_def

