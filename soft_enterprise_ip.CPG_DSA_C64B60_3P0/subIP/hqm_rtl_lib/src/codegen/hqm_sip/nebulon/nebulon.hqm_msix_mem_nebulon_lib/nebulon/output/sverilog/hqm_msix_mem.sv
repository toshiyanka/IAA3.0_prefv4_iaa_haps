///
///  INTEL CONFIDENTIAL
///
///  Copyright 2022 Intel Corporation All Rights Reserved.
///
///  The source code contained or described herein and all documents related
///  to the source code ("Material") are owned by Intel Corporation or its
///  suppliers or licensors. Title to the Material remains with Intel
///  Corporation or its suppliers and licensors. The Material contains trade
///  secrets and proprietary and confidential information of Intel or its
///  suppliers and licensors. The Material is protected by worldwide copyright
///  and trade secret laws and treaty provisions. No part of the Material may
///  be used, copied, reproduced, modified, published, uploaded, posted,
///  transmitted, distributed, or disclosed in any way without Intel's prior
///  express written permission.
///
///  No license under any patent, copyright, trade secret or other intellectual
///  property right is granted to or conferred upon you by disclosure or
///  delivery of the Materials, either expressly, by implication, inducement,
///  estoppel or otherwise. Any license under such intellectual property rights
///  must be express and approved by Intel in writing.
///

//                                                                             
// File:            hqm_msix_mem.sv                                            
// Nebulon version: d22ww21.1                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2022 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             



// The NEBULON_RTLGEN_TEMPLATE env was: /p/hdk/rtl/proj_tools/nebulon_data/shdk74/20.35.01_gen3/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/overhead_templates::/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_include_template:/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_pkg_template
//lintra push -60039
//lintra push -68099
// This include is still needed for RTLGEN_LCB
`include "rtlgen_include_hqm_msix_mem_map.vh"
`include "rtlgen_pkg_hqm_msix_mem_map.vh"
`include "hqm_msix_mem_pkg.vh"

//lintra push -68094
//lintra push -60115

// ===================================================================
// Flops macros 
// ===================================================================

`ifndef RTLGEN_HQM_MSIX_MEM_FF
`define RTLGEN_HQM_MSIX_MEM_FF(rtl_clk, rst_n, rst_val, d, q) \
    always_ff @(posedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_FF

`ifndef RTLGEN_HQM_MSIX_MEM_EN_FF
`define RTLGEN_HQM_MSIX_MEM_EN_FF(rtl_clk, rst_n, rst_val, en, d, q) \
    always_ff @(posedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_EN_FF

`ifndef RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE
`define RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE(rtl_clk, rst_n, rst_val, d, q) \
    always_ff @(negedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE

`ifndef RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE
`define RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE(rtl_clk, rst_n, rst_val, en, d, q) \
    always_ff @(negedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE

`ifndef RTLGEN_HQM_MSIX_MEM_FF_RSTD
`define RTLGEN_HQM_MSIX_MEM_FF_RSTD(rtl_clk, rst_n, rst_val, d, q) \
   genvar \gen_``d`` ; \
   generate \
      if (1) begin : \ff_rstd_``d`` \
         logic [$bits(q)-1:0] rst_vec, set_vec, d_vec, q_vec; \
         assign rst_vec = !rst_n ? ~rst_val : '0; \
         assign set_vec = !rst_n ? rst_val : '0; \
         assign d_vec = d; \
         assign q = q_vec; \
         for ( \gen_``d`` = 0 ; \gen_``d`` < $bits(q) ; \gen_``d`` = \gen_``d`` + 1)  \
            always_ff @(posedge rtl_clk, posedge rst_vec[ \gen_``d`` ], posedge set_vec[ \gen_``d`` ]) \
               if (rst_vec[ \gen_``d`` ]) \
                  q_vec[ \gen_``d`` ] <= '0; \
               else if (set_vec[ \gen_``d`` ]) \
                  q_vec[ \gen_``d`` ] <= '1; \
               else   \
                  q_vec[ \gen_``d`` ] <= d_vec[ \gen_``d`` ]; \
      end \
   endgenerate       
`endif // RTLGEN_HQM_MSIX_MEM_FF_RSTD


module rtlgen_hqm_msix_mem_en_ff_rstd(rtl_clk_var, rst_n_var, rst_val_var, en_var, d_var, q_var);
parameter DATA_WIDTH=1;
input logic rtl_clk_var, rst_n_var, en_var;
input logic [DATA_WIDTH-1:0] rst_val_var, d_var;
output logic [DATA_WIDTH-1:0] q_var;

   genvar gen_var ; 
   generate 
      if (1) begin : rtlgen_en_ff_rstd
         logic [DATA_WIDTH-1:0] rst_vec, set_vec, d_vec, q_vec; 
         assign rst_vec = !rst_n_var ? ~rst_val_var : '0; 
         assign set_vec = !rst_n_var ? rst_val_var : '0; 
         assign d_vec = d_var; 
         assign q_var = q_vec; 
         for ( gen_var = 0 ; gen_var < DATA_WIDTH; gen_var = gen_var + 1)  
            always_ff @(posedge rtl_clk_var, posedge rst_vec[ gen_var ], posedge set_vec[ gen_var ]) 
               if (rst_vec[ gen_var ]) 
                  q_vec[ gen_var ] <= '0; 
               else if (set_vec[ gen_var ]) 
                  q_vec[ gen_var ] <= '1; 
               else if (en_var)  
                  q_vec[ gen_var ] <= d_vec[ gen_var ]; 
      end 
   endgenerate       

endmodule 

`ifndef RTLGEN_HQM_MSIX_MEM_EN_FF_RSTD
`define RTLGEN_HQM_MSIX_MEM_EN_FF_RSTD(rtl_clk, rst_n, rst_val, en, d, q) \
rtlgen_hqm_msix_mem_en_ff_rstd #(.DATA_WIDTH($bits(q))) \``d``_en_ff_rstd (.rtl_clk_var(rtl_clk), .rst_n_var(rst_n), .rst_val_var(rst_val), .en_var(en), .d_var(d), .q_var(q));
`endif // RTLGEN_HQM_MSIX_MEM_EN_FF_RSTD



`ifndef RTLGEN_HQM_MSIX_MEM_FF_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_FF_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
    always_ff @(posedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_FF_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_EN_FF_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_EN_FF_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
    always_ff @(posedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_EN_FF_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
    always_ff @(negedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_FF_NEGEDGE_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
    always_ff @(negedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_EN_FF_NEGEDGE_SYNCRST

// BOTHRST is cancelled. Should not be used. 
//
// `ifndef RTLGEN_HQM_MSIX_MEM_FF_BOTHRST
// `define RTLGEN_HQM_MSIX_MEM_FF_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, d, q) \
//     always_ff @(posedge rtl_clk, negedge rst_n) \
//         if (!rst_n) q <= rst_val; \
//         else if (!syncrst_n) q <= rst_val; \
//         else        q <= d;
// `endif // RTLGEN_HQM_MSIX_MEM_FF_BOTHRST
// 
// `ifndef RTLGEN_HQM_MSIX_MEM_EN_FF_BOTHRST
// `define RTLGEN_HQM_MSIX_MEM_EN_FF_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, en, d, q) \
//     always_ff @(posedge rtl_clk, negedge rst_n) \
//         if (!rst_n) q <= rst_val; \
//         else if (!syncrst_n) q <= rst_val; \
//         else if (en) q <= d;
// 
// `endif // RTLGEN_HQM_MSIX_MEM_EN_FF_BOTHRST


// ===================================================================
// Latch macros -- compatible with nhm_macros RST_LATCH & EN_RST_LATCH
// ===================================================================

`ifndef RTLGEN_HQM_MSIX_MEM_LATCH_LOW
`define RTLGEN_HQM_MSIX_MEM_LATCH_LOW(rtl_clk, d, q) \
   always_latch if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) q <= d;   
`endif // RTLGEN_HQM_MSIX_MEM_LATCH_LOW

`ifndef RTLGEN_HQM_MSIX_MEM_PH2_FF
`define RTLGEN_HQM_MSIX_MEM_PH2_FF(rtl_clk, d, q) \
    always_ff @(posedge rtl_clk) \
     q <= d;
`endif // RTLGEN_HQM_MSIX_MEM_PH2_FF

// Can't be override
`ifndef RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASSIGN
`define RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASSIGN(n) \
   `RTLGEN_HQM_MSIX_MEM_LATCH_LOW(gated_clk,``n``,``n``_low)
`endif // RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASSIGN

// Can't be override
`ifndef RTLGEN_HQM_MSIX_MEM_PH2_FF_ASSIGN
`define RTLGEN_HQM_MSIX_MEM_PH2_FF_ASSIGN(n) \
   `RTLGEN_HQM_MSIX_MEM_PH2_FF(gated_clk,``n``,``n``_low)
`endif // RTLGEN_HQM_MSIX_MEM_PH2_FF_ASSIGN

`ifndef RTLGEN_HQM_MSIX_MEM_LATCH
`define RTLGEN_HQM_MSIX_MEM_LATCH(rtl_clk, rst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if (!rst_n) q <= rst_val;                  \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) q <= d; \
      end                                           
`endif // RTLGEN_HQM_MSIX_MEM_LATCH

// In order not to touch regular LATCH_LOW (without reset) for backward compatible, 
//  an additional LATCH_LOW macro was added for reset with suffix _ASYNCRST 
`ifndef RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASYNCRST
`define RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASYNCRST(rtl_clk, rst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if (!rst_n) q <= rst_val;                  \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) q <= d; \
      end                                           
`endif // RTLGEN_HQM_MSIX_MEM_LATCH_LOW_ASYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_EN_LATCH
`define RTLGEN_HQM_MSIX_MEM_EN_LATCH(rtl_clk, rst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if (!rst_n) q <= rst_val;                         \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) begin \
              if (en) q <= d;                              \
         end                                               \
      end                                                  
`endif // RTLGEN_HQM_MSIX_MEM_EN_LATCH

`ifndef RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW
`define RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW(rtl_clk, rst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if (!rst_n) q <= rst_val;                         \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) begin \
              if (en) q <= d;                              \
         end                                               \
      end                                                  
`endif // RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW

`ifndef RTLGEN_HQM_MSIX_MEM_LATCH_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LATCH_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) \
            if (!syncrst_n) q <= rst_val;           \
            else            q <=  d;                \
      end                                           
`endif // RTLGEN_HQM_MSIX_MEM_LATCH_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LATCH_LOW_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) \
            if (!syncrst_n) q <= rst_val;           \
            else            q <=  d;                \
      end                                           
`endif // RTLGEN_HQM_MSIX_MEM_LATCH_LOW_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_EN_LATCH_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_EN_LATCH_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk)))  \
            if (!syncrst_n) q <= rst_val;                  \
            else if (en)    q <=  d;                       \
      end                                                  
`endif // RTLGEN_HQM_MSIX_MEM_EN_LATCH_SYNCRST

`ifndef RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk)))  \
            if (!syncrst_n) q <= rst_val;                  \
            else if (en)    q <=  d;                       \
      end                                                  
`endif // RTLGEN_HQM_MSIX_MEM_EN_LATCH_LOW_SYNCRST

// BOTHRST is cancelled. Should not be used. 
// 
// `ifndef RTLGEN_HQM_MSIX_MEM_LATCH_BOTHRST
// `define RTLGEN_HQM_MSIX_MEM_LATCH_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, d, q) \
//    always_latch                                     \
//       begin                                         \
//          if (!rst_n) q <= rst_val;                  \
//          else if (`ifdef LINTRA _OL(* ol_clock *) `endif (rtl_clk)) \
//             if (!syncrst_n) q <= rst_val;           \
//             else            q <=  d;                \
//       end                                           
// `endif // RTLGEN_HQM_MSIX_MEM_LATCH_BOTHRST
// 
// `ifndef RTLGEN_HQM_MSIX_MEM_EN_LATCH_BOTHRST
// `define RTLGEN_HQM_MSIX_MEM_EN_LATCH_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, en, d, q) \
//    always_latch                                     \
//       begin                                         \
//          if (!rst_n) q <= rst_val;                  \
//          else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) \
//             if (!syncrst_n) q <= rst_val;           \
//             else if (en)    q <=  d;                \
//       end                                           
// `endif // RTLGEN_HQM_MSIX_MEM_EN_LATCH_BOTHRST


// ===================================================================
// LCB macros 
// ===================================================================

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES
`define RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES(clock, enable, lcb_clk) \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & enable;
`endif // RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES_SYNCRST(clock, enable, lcb_clk, sync_rst) \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & (enable | {$bits(lcb_clk){!sync_rst}});
`endif // RTLGEN_HQM_MSIX_MEM_LCB_HOLD_REQ_2CYCLES_SYNCRST


`ifndef RTLGEN_HQM_MSIX_MEM_LCB_DELAY_FFEN
`define RTLGEN_HQM_MSIX_MEM_LCB_DELAY_FFEN(clock, delay_rst_n, enable, lcb_clk, dly_seq_type, close_ff_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_close_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   logic [$bits(lcb_clk)-1:0] ``enable``_close; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   always_comb ``enable``_dly_up = ``enable``_nxt | ``enable``_close; \
   always_comb ``enable``_close_up = ``enable``_dly | ``enable``_close; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) begin \
  `RTLGEN_HQM_MSIX_MEM_``close_ff_type``(clock,delay_rst_n,1'b0,``enable``_close_up[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ],``enable``_close[ ``enable``_gen_var ]) \
  `RTLGEN_HQM_MSIX_MEM_``dly_seq_type``(clock,delay_rst_n,1'b0,``enable``_dly_up[ ``enable``_gen_var ],``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
         end      \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN


`ifndef RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN
`define RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock, delay_rst_n, enable, lcb_clk, seq_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   always_comb ``enable``_up = ``enable``_nxt | ``enable``_dly; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) \
  `RTLGEN_HQM_MSIX_MEM_``seq_type``(clock,delay_rst_n,1'b0,``enable``_up[ ``enable``_gen_var ],``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_DELAY
`define RTLGEN_HQM_MSIX_MEM_LCB_DELAY(clock, delay_rst_n, enable, lcb_clk, seq_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) \
  `RTLGEN_HQM_MSIX_MEM_``seq_type``(clock,delay_rst_n,1'b0,``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_MSIX_MEM_LCB_DELAY

// LCB MODE: LATCH_FFEN_LOW
`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_FFEN(clock,delay_rst_n,enable,lcb_clk,EN_LATCH_LOW,EN_FF_NEGEDGE,enable) 
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_FFEN(clock,1'b1,enable,lcb_clk,EN_LATCH_LOW_SYNCRST,EN_FF_NEGEDGE_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}}) 
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_FFEN_LOW_SYNCRST

// LCB MODE: LATCH_EN_LOW
`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_LATCH_LOW,enable)
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_LATCH_LOW_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_EN_LOW_SYNCRST

// LCB MODE: LATCH_LOW
`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY(clock,delay_rst_n,enable,lcb_clk,LATCH_LOW_ASYNCRST,enable)
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY(clock,1'b1,enable,lcb_clk,LATCH_LOW_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_MSIX_MEM_LCB_LATCH_LOW_SYNCRST

// LCB MODE: FF_NEGEDGE
`ifndef RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE
`define RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE(clock, delay_rst_n, enable, lcb_clk)  \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_FF_NEGEDGE,enable)
`endif // RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_FF_NEGEDGE_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_MSIX_MEM_LCB_FF_NEGEDGE_SYNCRST

// LCB MODE: FF_POSEDGE
`ifndef RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE
`define RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE(clock, delay_rst_n, enable, lcb_clk)  \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_FF,enable)
`endif // RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE

`ifndef RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE_SYNCRST
`define RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_MSIX_MEM_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_FF_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_MSIX_MEM_LCB_FF_POSEDGE_SYNCRST



//lintra pop

module hqm_msix_mem ( //lintra s-2096
    // Clocks


    // Resets
    hqm_inp_gated_rst_n,


    // Register Inputs
    new_HQM_MSIX_PBA,

    handcode_reg_rdata_MSG_ADDR_L,
    handcode_reg_rdata_MSG_ADDR_U,
    handcode_reg_rdata_MSG_DATA,
    handcode_reg_rdata_VECTOR_CTRL,

    handcode_rvalid_MSG_ADDR_L,
    handcode_rvalid_MSG_ADDR_U,
    handcode_rvalid_MSG_DATA,
    handcode_rvalid_VECTOR_CTRL,

    handcode_wvalid_MSG_ADDR_L,
    handcode_wvalid_MSG_ADDR_U,
    handcode_wvalid_MSG_DATA,
    handcode_wvalid_VECTOR_CTRL,

    handcode_error_MSG_ADDR_L,
    handcode_error_MSG_ADDR_U,
    handcode_error_MSG_DATA,
    handcode_error_VECTOR_CTRL,


    // Register Outputs
    HQM_MSIX_PBA,


    // Register signals for HandCoded registers
    handcode_reg_wdata_MSG_ADDR_L,
    handcode_reg_wdata_MSG_ADDR_U,
    handcode_reg_wdata_MSG_DATA,
    handcode_reg_wdata_VECTOR_CTRL,

    we_MSG_ADDR_L,
    we_MSG_ADDR_U,
    we_MSG_DATA,
    we_VECTOR_CTRL,

    re_MSG_ADDR_L,
    re_MSG_ADDR_U,
    re_MSG_DATA,
    re_VECTOR_CTRL,






    // Config Access
    req,
    ack
    

);

import hqm_msix_mem_pkg::*;
import rtlgen_pkg_hqm_msix_mem_map::*;

parameter  HQM_MSIX_MEM_MEM_ADDR_MSB = 47;
parameter [HQM_MSIX_MEM_MEM_ADDR_MSB:0] HQM_MSIX_MEM_MAP_OFFSET = {HQM_MSIX_MEM_MEM_ADDR_MSB+1{1'b0}};
localparam  ADDR_LSB_BUS_ALIGN = 2;
`define HQM_MSIX_PBA_CR_ADDR_def(INDEX) HQM_MSIX_PBA_CR_ADDR``INDEX``[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_MSIX_MEM_MAP_OFFSET[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN]
localparam [2:0][HQM_MSIX_MEM_MEM_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] HQM_MSIX_PBA_DECODE_ADDR = {`HQM_MSIX_PBA_CR_ADDR_def([2]),`HQM_MSIX_PBA_CR_ADDR_def([1]),`HQM_MSIX_PBA_CR_ADDR_def([0])};

    // Clocks


    // Resets
input logic  hqm_inp_gated_rst_n;


    // Register Inputs
input new_HQM_MSIX_PBA_t [2:0] new_HQM_MSIX_PBA;

input MSG_ADDR_L_t  handcode_reg_rdata_MSG_ADDR_L;
input MSG_ADDR_U_t  handcode_reg_rdata_MSG_ADDR_U;
input MSG_DATA_t  handcode_reg_rdata_MSG_DATA;
input VECTOR_CTRL_t  handcode_reg_rdata_VECTOR_CTRL;

input handcode_rvalid_MSG_ADDR_L_t  handcode_rvalid_MSG_ADDR_L;
input handcode_rvalid_MSG_ADDR_U_t  handcode_rvalid_MSG_ADDR_U;
input handcode_rvalid_MSG_DATA_t  handcode_rvalid_MSG_DATA;
input handcode_rvalid_VECTOR_CTRL_t  handcode_rvalid_VECTOR_CTRL;

input handcode_wvalid_MSG_ADDR_L_t  handcode_wvalid_MSG_ADDR_L;
input handcode_wvalid_MSG_ADDR_U_t  handcode_wvalid_MSG_ADDR_U;
input handcode_wvalid_MSG_DATA_t  handcode_wvalid_MSG_DATA;
input handcode_wvalid_VECTOR_CTRL_t  handcode_wvalid_VECTOR_CTRL;

input handcode_error_MSG_ADDR_L_t  handcode_error_MSG_ADDR_L;
input handcode_error_MSG_ADDR_U_t  handcode_error_MSG_ADDR_U;
input handcode_error_MSG_DATA_t  handcode_error_MSG_DATA;
input handcode_error_VECTOR_CTRL_t  handcode_error_VECTOR_CTRL;


    // Register Outputs
output HQM_MSIX_PBA_t [2:0] HQM_MSIX_PBA;


    // Register signals for HandCoded registers
output MSG_ADDR_L_t  handcode_reg_wdata_MSG_ADDR_L;
output MSG_ADDR_U_t  handcode_reg_wdata_MSG_ADDR_U;
output MSG_DATA_t  handcode_reg_wdata_MSG_DATA;
output VECTOR_CTRL_t  handcode_reg_wdata_VECTOR_CTRL;

output we_MSG_ADDR_L_t  we_MSG_ADDR_L;
output we_MSG_ADDR_U_t  we_MSG_ADDR_U;
output we_MSG_DATA_t  we_MSG_DATA;
output we_VECTOR_CTRL_t  we_VECTOR_CTRL;

output re_MSG_ADDR_L_t  re_MSG_ADDR_L;
output re_MSG_ADDR_U_t  re_MSG_ADDR_U;
output re_MSG_DATA_t  re_MSG_DATA;
output re_VECTOR_CTRL_t  re_VECTOR_CTRL;






    // Config Access
input hqm_msix_mem_cr_req_t  req;
output hqm_msix_mem_cr_ack_t  ack;
    

// ======================================================================
// begin decode and addr logic section {


function automatic logic f_IsMEMRd (
    input logic [3:0] req_opcode
);
    f_IsMEMRd = (req_opcode == MRD); 
endfunction : f_IsMEMRd

function automatic logic f_IsMEMWr (
    input logic [3:0] req_opcode
);
    f_IsMEMWr = (req_opcode == MWR); 
endfunction : f_IsMEMWr

function automatic logic [CR_REQ_ADDR_HI:0] f_MEMAddr (
    input hqm_msix_mem_cr_req_t req
);
begin
    f_MEMAddr[CR_REQ_ADDR_HI:0] = 48'h0;
    f_MEMAddr[CR_MEM_ADDR_HI:0] = 
       req.addr.mem.offset[CR_MEM_ADDR_HI:0];
end
endfunction : f_MEMAddr


function automatic logic f_IsRdOpCode (
    input logic [3:0] req_opcode
);
    f_IsRdOpCode = (!req_opcode[0]); 
endfunction : f_IsRdOpCode

function automatic logic f_IsWrOpCode (
    input logic [3:0] req_opcode
);
    f_IsWrOpCode = (req_opcode[0]); 
endfunction : f_IsWrOpCode

// Shared registers definitions





logic [3:0] req_opcode;
always_comb req_opcode = {1'b0, req.opcode[2:0]};

logic req_valid;
assign req_valid = req.valid;


logic IsWrOpcode;
logic IsRdOpcode;
assign IsWrOpcode = f_IsWrOpCode(req_opcode);
assign IsRdOpcode = f_IsRdOpCode(req_opcode);

logic IsMEMRd;
logic IsMEMWr;
assign IsMEMRd = f_IsMEMRd(req_opcode);
assign IsMEMWr = f_IsMEMWr(req_opcode);


logic [47:0] req_addr;
always_comb begin : REQ_ADDR_BLOCK
    unique casez (req_opcode) 
        MRD: begin 
            req_addr = f_MEMAddr(req);
        end 
        MWR: begin
            req_addr = f_MEMAddr(req);
        end 
        default: begin
           req_addr = 48'h0;
        end
    endcase 
end

logic [HQM_MSIX_MEM_MEM_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] case_req_addr_HQM_MSIX_MEM_MEM;
assign case_req_addr_HQM_MSIX_MEM_MEM = req_addr[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
logic [3:0] be;
always_comb be = {4{req.valid}} & req.be;
logic [3:0] sai_successfull_per_byte;
logic [31:0] read_data;
logic [31:0] write_data;




// ======================================================================
// begin register logic section {

// ----------------------------------------------------------------------
// MSG_ADDR_L using HANDCODED_REG template.
logic addr_decode_MSG_ADDR_L;
logic write_req_MSG_ADDR_L;
logic read_req_MSG_ADDR_L;

always_comb begin 
   unique casez (req_addr[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN]) 
      {40'b0??,4'h?,2'b00},
      {44'h40,2'b00}:
          addr_decode_MSG_ADDR_L = req.valid;
      default: 
         addr_decode_MSG_ADDR_L = 1'b0; 
   endcase
end

always_comb write_req_MSG_ADDR_L = f_IsMEMWr(req_opcode) && addr_decode_MSG_ADDR_L ;
always_comb read_req_MSG_ADDR_L  = f_IsMEMRd(req_opcode) && addr_decode_MSG_ADDR_L ;

always_comb we_MSG_ADDR_L = {4{write_req_MSG_ADDR_L}} & req.be[3:0];
always_comb re_MSG_ADDR_L = {4{read_req_MSG_ADDR_L}} & req.be[3:0];
always_comb handcode_reg_wdata_MSG_ADDR_L = req.data[31:0];


// ----------------------------------------------------------------------
// MSG_ADDR_U using HANDCODED_REG template.
logic addr_decode_MSG_ADDR_U;
logic write_req_MSG_ADDR_U;
logic read_req_MSG_ADDR_U;

always_comb begin 
   unique casez (req_addr[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN]) 
      {40'b0??,4'h?,2'b01},
      {44'h40,2'b01}:
          addr_decode_MSG_ADDR_U = req.valid;
      default: 
         addr_decode_MSG_ADDR_U = 1'b0; 
   endcase
end

always_comb write_req_MSG_ADDR_U = f_IsMEMWr(req_opcode) && addr_decode_MSG_ADDR_U ;
always_comb read_req_MSG_ADDR_U  = f_IsMEMRd(req_opcode) && addr_decode_MSG_ADDR_U ;

always_comb we_MSG_ADDR_U = {4{write_req_MSG_ADDR_U}} & req.be[3:0];
always_comb re_MSG_ADDR_U = {4{read_req_MSG_ADDR_U}} & req.be[3:0];
always_comb handcode_reg_wdata_MSG_ADDR_U = req.data[31:0];


// ----------------------------------------------------------------------
// MSG_DATA using HANDCODED_REG template.
logic addr_decode_MSG_DATA;
logic write_req_MSG_DATA;
logic read_req_MSG_DATA;

always_comb begin 
   unique casez (req_addr[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN]) 
      {40'b0??,4'h?,2'b10},
      {44'h40,2'b10}:
          addr_decode_MSG_DATA = req.valid;
      default: 
         addr_decode_MSG_DATA = 1'b0; 
   endcase
end

always_comb write_req_MSG_DATA = f_IsMEMWr(req_opcode) && addr_decode_MSG_DATA ;
always_comb read_req_MSG_DATA  = f_IsMEMRd(req_opcode) && addr_decode_MSG_DATA ;

always_comb we_MSG_DATA = {4{write_req_MSG_DATA}} & req.be[3:0];
always_comb re_MSG_DATA = {4{read_req_MSG_DATA}} & req.be[3:0];
always_comb handcode_reg_wdata_MSG_DATA = req.data[31:0];


// ----------------------------------------------------------------------
// VECTOR_CTRL using HANDCODED_REG template.
logic addr_decode_VECTOR_CTRL;
logic write_req_VECTOR_CTRL;
logic read_req_VECTOR_CTRL;

always_comb begin 
   unique casez (req_addr[HQM_MSIX_MEM_MEM_ADDR_MSB:ADDR_LSB_BUS_ALIGN]) 
      {40'b0??,4'h?,2'b11},
      {44'h40,2'b11}:
          addr_decode_VECTOR_CTRL = req.valid;
      default: 
         addr_decode_VECTOR_CTRL = 1'b0; 
   endcase
end

always_comb write_req_VECTOR_CTRL = f_IsMEMWr(req_opcode) && addr_decode_VECTOR_CTRL ;
always_comb read_req_VECTOR_CTRL  = f_IsMEMRd(req_opcode) && addr_decode_VECTOR_CTRL ;

always_comb we_VECTOR_CTRL = {4{write_req_VECTOR_CTRL}} & req.be[3:0];
always_comb re_VECTOR_CTRL = {4{read_req_VECTOR_CTRL}} & req.be[3:0];
always_comb handcode_reg_wdata_VECTOR_CTRL = req.data[31:0];


//---------------------------------------------------------------------
// HQM_MSIX_PBA Address Decode
// ----------------------------------------------------------------------
// HQM_MSIX_PBA.PENDING x8 RO/V, using RO/V template.
assign HQM_MSIX_PBA[0].PENDING = new_HQM_MSIX_PBA[0].PENDING;

assign HQM_MSIX_PBA[1].PENDING = new_HQM_MSIX_PBA[1].PENDING;

assign HQM_MSIX_PBA[2].PENDING = new_HQM_MSIX_PBA[2].PENDING;



// Shared registers assignments


// end register logic section }

always_comb begin : MISS_VALID_BLOCK

   unique casez (req_opcode) 
      MRD: begin
         ack.read_valid = req_valid;
         ack.write_valid  = 1'b0; 
         ack.write_miss = ack.write_valid; 
         unique casez (case_req_addr_HQM_MSIX_MEM_MEM) 
           {40'b0??,4'h?,2'b00},
           {44'h40,2'b00}: begin
              ack.read_valid = req.valid && (handcode_rvalid_MSG_ADDR_L || ~(|re_MSG_ADDR_L));
              ack.read_miss = handcode_error_MSG_ADDR_L;
           end
           {40'b0??,4'h?,2'b01},
           {44'h40,2'b01}: begin
              ack.read_valid = req.valid && (handcode_rvalid_MSG_ADDR_U || ~(|re_MSG_ADDR_U));
              ack.read_miss = handcode_error_MSG_ADDR_U;
           end
           {40'b0??,4'h?,2'b10},
           {44'h40,2'b10}: begin
              ack.read_valid = req.valid && (handcode_rvalid_MSG_DATA || ~(|re_MSG_DATA));
              ack.read_miss = handcode_error_MSG_DATA;
           end
           {40'b0??,4'h?,2'b11},
           {44'h40,2'b11}: begin
              ack.read_valid = req.valid && (handcode_rvalid_VECTOR_CTRL || ~(|re_VECTOR_CTRL));
              ack.read_miss = handcode_error_VECTOR_CTRL;
           end
           HQM_MSIX_PBA_DECODE_ADDR[0]: ack.read_miss = 1'b0;
           HQM_MSIX_PBA_DECODE_ADDR[1]: ack.read_miss = 1'b0;
           HQM_MSIX_PBA_DECODE_ADDR[2]: ack.read_miss = 1'b0;
            default: ack.read_miss  = ack.read_valid; 
         endcase
      end    
      MWR: begin
         ack.write_valid = req_valid;
         ack.read_valid  = 1'b0; 
         ack.read_miss = ack.read_valid;
         unique casez (case_req_addr_HQM_MSIX_MEM_MEM) 
           {40'b0??,4'h?,2'b00},
           {44'h40,2'b00}: begin
              ack.write_valid = req.valid && (handcode_wvalid_MSG_ADDR_L || ~(|we_MSG_ADDR_L));
              ack.write_miss = handcode_error_MSG_ADDR_L;
           end
           {40'b0??,4'h?,2'b01},
           {44'h40,2'b01}: begin
              ack.write_valid = req.valid && (handcode_wvalid_MSG_ADDR_U || ~(|we_MSG_ADDR_U));
              ack.write_miss = handcode_error_MSG_ADDR_U;
           end
           {40'b0??,4'h?,2'b10},
           {44'h40,2'b10}: begin
              ack.write_valid = req.valid && (handcode_wvalid_MSG_DATA || ~(|we_MSG_DATA));
              ack.write_miss = handcode_error_MSG_DATA;
           end
           {40'b0??,4'h?,2'b11},
           {44'h40,2'b11}: begin
              ack.write_valid = req.valid && (handcode_wvalid_VECTOR_CTRL || ~(|we_VECTOR_CTRL));
              ack.write_miss = handcode_error_VECTOR_CTRL;
           end
           HQM_MSIX_PBA_DECODE_ADDR[0]: ack.write_miss = 1'b0;
           HQM_MSIX_PBA_DECODE_ADDR[1]: ack.write_miss = 1'b0;
           HQM_MSIX_PBA_DECODE_ADDR[2]: ack.write_miss = 1'b0;
            default: ack.write_miss = ack.write_valid;
         endcase 
      end  
      default: begin
         ack.write_valid  = req_valid & IsWrOpcode;
         ack.read_valid  = req_valid & IsRdOpcode;
         ack.read_miss  = ack.read_valid;
         ack.write_miss = ack.write_valid;
      end 
   endcase 
end

always_comb begin : SAI_BLOCK

   unique casez (req_opcode) 
      MRD: 
         unique casez (case_req_addr_HQM_MSIX_MEM_MEM) 
           {40'b0??,4'h?,2'b00},
           {44'h40,2'b00}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b01},
           {44'h40,2'b01}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b10},
           {44'h40,2'b10}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b11},
           {44'h40,2'b11}: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[0]: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[1]: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[2]: sai_successfull_per_byte = {{4{1'b1}}};
            default: sai_successfull_per_byte = {4{1'b1}};
         endcase 
      MWR: 
         unique casez (case_req_addr_HQM_MSIX_MEM_MEM) 
           {40'b0??,4'h?,2'b00},
           {44'h40,2'b00}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b01},
           {44'h40,2'b01}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b10},
           {44'h40,2'b10}: sai_successfull_per_byte = {{4{1'b1}}};
           {40'b0??,4'h?,2'b11},
           {44'h40,2'b11}: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[0]: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[1]: sai_successfull_per_byte = {{4{1'b1}}};
           HQM_MSIX_PBA_DECODE_ADDR[2]: sai_successfull_per_byte = {{4{1'b1}}};
            default: sai_successfull_per_byte = {4{1'b1}};
         endcase 
      default: sai_successfull_per_byte = {4{1'b1}};
   endcase 
end


always_comb ack.sai_successfull = &(sai_successfull_per_byte | ~be);


// end decode and addr logic section }

// ======================================================================
// begin rdata section {

always_comb begin : READ_DATA_BLOCK

   unique casez (req_opcode) 
      MRD:
         unique casez (case_req_addr_HQM_MSIX_MEM_MEM) 
           {40'b0??,4'h?,2'b00},
           {44'h40,2'b00}: read_data = handcode_reg_rdata_MSG_ADDR_L;
           {40'b0??,4'h?,2'b01},
           {44'h40,2'b01}: read_data = handcode_reg_rdata_MSG_ADDR_U;
           {40'b0??,4'h?,2'b10},
           {44'h40,2'b10}: read_data = handcode_reg_rdata_MSG_DATA;
           {40'b0??,4'h?,2'b11},
           {44'h40,2'b11}: read_data = handcode_reg_rdata_VECTOR_CTRL;
           HQM_MSIX_PBA_DECODE_ADDR[0]: read_data = {HQM_MSIX_PBA[0]};
           HQM_MSIX_PBA_DECODE_ADDR[1]: read_data = {HQM_MSIX_PBA[1]};
           HQM_MSIX_PBA_DECODE_ADDR[2]: read_data = {HQM_MSIX_PBA[2]};
         default : read_data = '0; 
      endcase
      default : read_data = '0;  
   endcase
end

always_comb ack.data = read_data & { {8{be[3] & sai_successfull_per_byte[3]}}, {8{be[2] & sai_successfull_per_byte[2]}}, {8{be[1] & sai_successfull_per_byte[1]}}, {8{be[0] & sai_successfull_per_byte[0]}} };

always_comb write_data = req.data;


// end rdata section }

// ======================================================================
// begin register RSVD init section {


// end register RSVD init section }


// ======================================================================
// begin unit parity section {


// end unit parity section }


endmodule
//lintra pop
//lintra pop
