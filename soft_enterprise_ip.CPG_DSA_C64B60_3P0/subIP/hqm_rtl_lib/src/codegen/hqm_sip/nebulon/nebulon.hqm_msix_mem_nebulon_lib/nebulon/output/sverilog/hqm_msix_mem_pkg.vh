///
///  INTEL CONFIDENTIAL
///
///  Copyright 2022 Intel Corporation All Rights Reserved.
///
///  The source code contained or described herein and all documents related
///  to the source code ("Material") are owned by Intel Corporation or its
///  suppliers or licensors. Title to the Material remains with Intel
///  Corporation or its suppliers and licensors. The Material contains trade
///  secrets and proprietary and confidential information of Intel or its
///  suppliers and licensors. The Material is protected by worldwide copyright
///  and trade secret laws and treaty provisions. No part of the Material may
///  be used, copied, reproduced, modified, published, uploaded, posted,
///  transmitted, distributed, or disclosed in any way without Intel's prior
///  express written permission.
///
///  No license under any patent, copyright, trade secret or other intellectual
///  property right is granted to or conferred upon you by disclosure or
///  delivery of the Materials, either expressly, by implication, inducement,
///  estoppel or otherwise. Any license under such intellectual property rights
///  must be express and approved by Intel in writing.
///

//                                                                             
// File:            hqm_msix_mem_pkg.vh                                        
// Nebulon version: d22ww21.1                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2022 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


// The NEBULON_RTLGEN_TEMPLATE env was: /p/hdk/rtl/proj_tools/nebulon_data/shdk74/20.35.01_gen3/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/overhead_templates::/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_include_template:/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_pkg_template

`ifndef HQM_MSIX_MEM_PKG_VH
`define HQM_MSIX_MEM_PKG_VH

`include "rtlgen_include_hqm_msix_mem_map.vh"
`include "rtlgen_pkg_hqm_msix_mem_map.vh"

package hqm_msix_mem_pkg;

import rtlgen_pkg_hqm_msix_mem_map::*;

typedef cfg_req_32bit_t hqm_msix_mem_cr_req_t;
typedef cfg_ack_32bit_t hqm_msix_mem_cr_ack_t;
typedef struct packed {
   logic treg_trdy; 
   logic treg_cerr;   
   logic [31:0] treg_rdata;
} hqm_msix_mem_sb_ack_t;

// Comments were moved out of macro, due to collage failure
// treg_data 
//    Assumption1: (treg_trdy == 0 | treg_cerr == 0) => treg_rdata   
//    Assumption2: non relevant fields & reserved are also set to 0  
// treg_trdy
//    Regular case: All banks should return same treg_trdy value.    
//    Special case: Multi cycle read/write from handcoded memory.    
//               One bank hold ack until result is ready          
//    For this case all acks are AND                               
// treg_cerr
//    Assumption: treg_trdy=0 => treg_cerr=0                         
//    Regular case: return error when all banks return error         
//    Spacial case: when bank with multi cycle request, hold the     
//                request, its ack treg_trdy=0 && treg_cerr=0     
//               when bank with multi cycle ready, all banks      
//            return ack, since the request is hold for all banks 

`ifndef RTLGEN_MERGE_SB_ACK_LIST
`define RTLGEN_MERGE_SB_ACK_LIST(sb_ack_list,merged_sb_ack)         \
  always_comb begin                                                 \
     merged_sb_ack.treg_rdata = '0;                                 \
     for (int i=0; i<$size(sb_ack_list); i++) begin                 \
        merged_sb_ack.treg_rdata |= sb_ack_list[i].treg_rdata;      \
     end                                                            \
  end                                                               \
                                                                    \
  always_comb begin                                                 \
     merged_sb_ack.treg_trdy = '1;                                  \
     for (int i=0; i<$size(sb_ack_list); i = i + 1) begin           \
        merged_sb_ack.treg_trdy &= sb_ack_list[i].treg_trdy;        \
     end                                                            \
  end                                                               \
                                                                    \
  always_comb begin                                                 \
     merged_sb_ack.treg_cerr = '0;                                  \
     for (int i=0; i<$size(sb_ack_list); i = i + 1) begin           \
        merged_sb_ack.treg_cerr |= sb_ack_list[i].treg_cerr;        \
     end                                                            \
  end                                                               
`endif // RTLGEN_MERGE_SB_ACK_LIST                                  

// sai_successfull - acknowledge with zero value must have valid=1 and miss=0
// read/write valid - all acknowledges should have the same valid
// read/write miss - return miss when all banks return miss
`ifndef RTLGEN_MERGE_CR_ACK_LIST
`define RTLGEN_MERGE_CR_ACK_LIST(cr_ack_list,merged_cr_ack)       \
   always_comb begin                                              \
      merged_cr_ack.data = '0;                                    \
      for (int i=0; i<$size(cr_ack_list); i++) begin              \
         merged_cr_ack.data |= cr_ack_list[i].data;               \
      end                                                         \
   end                                                            \
   always_comb begin                                              \
      merged_cr_ack.read_valid = '1;                              \
      for (int i=0; i<$size(cr_ack_list); i = i + 1) begin        \
         merged_cr_ack.read_valid &= cr_ack_list[i].read_valid;   \
      end                                                         \
   end                                                            \
   always_comb begin                                              \
      merged_cr_ack.write_valid = '1;                             \
      for (int i=0; i<$size(cr_ack_list); i = i + 1) begin        \
         merged_cr_ack.write_valid &= cr_ack_list[i].write_valid; \
      end                                                         \
   end                                                            \
   always_comb begin                                                      \
      merged_cr_ack.sai_successfull = '1;                                 \
      for (int i=0; i<$size(cr_ack_list); i = i + 1) begin                \
         merged_cr_ack.sai_successfull &= cr_ack_list[i].sai_successfull; \
      end                                                                 \
   end                                                                    \
   always_comb begin                                            \
      merged_cr_ack.read_miss = '1;                             \
      for (int i=0; i<$size(cr_ack_list); i = i + 1) begin      \
         merged_cr_ack.read_miss &= cr_ack_list[i].read_miss;   \
      end                                                       \
   end                                                          \
   always_comb begin                                            \
      merged_cr_ack.write_miss = '1;                            \
      for (int i=0; i<$size(cr_ack_list); i = i + 1) begin      \
         merged_cr_ack.write_miss &= cr_ack_list[i].write_miss; \
      end                                                       \
   end                                                          
`endif // RTLGEN_MERGE_CR_ACK_LIST                         

// ===================================================
// register structs

typedef struct packed {
    logic [29:0] MSG_ADDR_L;  // RW
    logic  [1:0] RSVD;  // RW
} MSG_ADDR_L_t;

localparam MSG_ADDR_L_REG_STRIDE = 48'h4;
localparam MSG_ADDR_L_REG_ENTRIES = 1;
localparam MSIX_TABLE_REGFILE_STRIDE = 48'h10;
localparam MSIX_TABLE_REGFILE_ENTRIES = 65;
localparam MSG_ADDR_L_CR_ADDR = 48'h0;
localparam MSG_ADDR_L_SIZE = 32;
localparam MSG_ADDR_L_MSG_ADDR_L_LO = 2;
localparam MSG_ADDR_L_MSG_ADDR_L_HI = 31;
localparam MSG_ADDR_L_MSG_ADDR_L_RESET = 30'h0;
localparam MSG_ADDR_L_RSVD_LO = 0;
localparam MSG_ADDR_L_RSVD_HI = 1;
localparam MSG_ADDR_L_RSVD_RESET = 2'h0;
localparam MSG_ADDR_L_USEMASK = 32'hFFFFFFFF;
localparam MSG_ADDR_L_RO_MASK = 32'h0;
localparam MSG_ADDR_L_WO_MASK = 32'h0;
localparam MSG_ADDR_L_RESET = 32'h0;

typedef struct packed {
    logic [31:0] MSG_ADDR_U;  // RW
} MSG_ADDR_U_t;

localparam MSG_ADDR_U_REG_STRIDE = 48'h4;
localparam MSG_ADDR_U_REG_ENTRIES = 1;
localparam MSG_ADDR_U_CR_ADDR = 48'h4;
localparam MSG_ADDR_U_SIZE = 32;
localparam MSG_ADDR_U_MSG_ADDR_U_LO = 0;
localparam MSG_ADDR_U_MSG_ADDR_U_HI = 31;
localparam MSG_ADDR_U_MSG_ADDR_U_RESET = 32'h0;
localparam MSG_ADDR_U_USEMASK = 32'hFFFFFFFF;
localparam MSG_ADDR_U_RO_MASK = 32'h0;
localparam MSG_ADDR_U_WO_MASK = 32'h0;
localparam MSG_ADDR_U_RESET = 32'h0;

typedef struct packed {
    logic [31:0] MSG_DATA;  // RW
} MSG_DATA_t;

localparam MSG_DATA_REG_STRIDE = 48'h4;
localparam MSG_DATA_REG_ENTRIES = 1;
localparam MSG_DATA_CR_ADDR = 48'h8;
localparam MSG_DATA_SIZE = 32;
localparam MSG_DATA_MSG_DATA_LO = 0;
localparam MSG_DATA_MSG_DATA_HI = 31;
localparam MSG_DATA_MSG_DATA_RESET = 32'h0;
localparam MSG_DATA_USEMASK = 32'hFFFFFFFF;
localparam MSG_DATA_RO_MASK = 32'h0;
localparam MSG_DATA_WO_MASK = 32'h0;
localparam MSG_DATA_RESET = 32'h0;

typedef struct packed {
    logic [30:0] reserved0;  // RSVD
    logic  [0:0] VEC_MASK;  // RW
} VECTOR_CTRL_t;

localparam VECTOR_CTRL_REG_STRIDE = 48'h4;
localparam VECTOR_CTRL_REG_ENTRIES = 1;
localparam VECTOR_CTRL_CR_ADDR = 48'hC;
localparam VECTOR_CTRL_SIZE = 32;
localparam VECTOR_CTRL_VEC_MASK_LO = 0;
localparam VECTOR_CTRL_VEC_MASK_HI = 0;
localparam VECTOR_CTRL_VEC_MASK_RESET = 1'h1;
localparam VECTOR_CTRL_USEMASK = 32'h1;
localparam VECTOR_CTRL_RO_MASK = 32'h0;
localparam VECTOR_CTRL_WO_MASK = 32'h0;
localparam VECTOR_CTRL_RESET = 32'h1;

typedef struct packed {
    logic [31:0] PENDING;  // RO/V
} HQM_MSIX_PBA_t;

localparam HQM_MSIX_PBA_REG_STRIDE = 48'h4;
localparam HQM_MSIX_PBA_REG_ENTRIES = 3;
localparam [2:0][47:0] HQM_MSIX_PBA_CR_ADDR = {48'h1008, 48'h1004, 48'h1000};
localparam HQM_MSIX_PBA_SIZE = 32;
localparam HQM_MSIX_PBA_PENDING_LO = 0;
localparam HQM_MSIX_PBA_PENDING_HI = 31;
localparam HQM_MSIX_PBA_PENDING_RESET = 32'h0;
localparam HQM_MSIX_PBA_USEMASK = 32'hFFFFFFFF;
localparam HQM_MSIX_PBA_RO_MASK = 32'hFFFFFFFF;
localparam HQM_MSIX_PBA_WO_MASK = 32'h0;
localparam HQM_MSIX_PBA_RESET = 32'h0;

typedef struct packed {
    HQM_MSIX_PBA_t [2:0] HQM_MSIX_PBA;
} hqm_msix_mem_registers_t;

// ===================================================
// load

// ===================================================
// lock

// ===================================================
// valid (so far used by WO registers)

// ===================================================
// new

typedef struct packed {
    logic [31:0] PENDING;  // RO/V
} new_HQM_MSIX_PBA_t;

typedef struct packed {
    new_HQM_MSIX_PBA_t [2:0] HQM_MSIX_PBA;
} hqm_msix_mem_new_t;

// ===================================================
// HandCoded Control structure
//   (used by project HandCoded specified registers)

typedef logic [3:0] we_MSG_ADDR_L_t;

typedef logic [3:0] we_MSG_ADDR_U_t;

typedef logic [3:0] we_MSG_DATA_t;

typedef logic [3:0] we_VECTOR_CTRL_t;

typedef struct packed {
    we_MSG_ADDR_L_t MSG_ADDR_L;
    we_MSG_ADDR_U_t MSG_ADDR_U;
    we_MSG_DATA_t MSG_DATA;
    we_VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_handcoded_t;

typedef logic [3:0] re_MSG_ADDR_L_t;

typedef logic [3:0] re_MSG_ADDR_U_t;

typedef logic [3:0] re_MSG_DATA_t;

typedef logic [3:0] re_VECTOR_CTRL_t;

typedef struct packed {
    re_MSG_ADDR_L_t MSG_ADDR_L;
    re_MSG_ADDR_U_t MSG_ADDR_U;
    re_MSG_DATA_t MSG_DATA;
    re_VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_re_t;

typedef logic handcode_rvalid_MSG_ADDR_L_t;

typedef logic handcode_rvalid_MSG_ADDR_U_t;

typedef logic handcode_rvalid_MSG_DATA_t;

typedef logic handcode_rvalid_VECTOR_CTRL_t;

typedef struct packed {
    handcode_rvalid_MSG_ADDR_L_t MSG_ADDR_L;
    handcode_rvalid_MSG_ADDR_U_t MSG_ADDR_U;
    handcode_rvalid_MSG_DATA_t MSG_DATA;
    handcode_rvalid_VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_rvalid_t;

typedef logic handcode_wvalid_MSG_ADDR_L_t;

typedef logic handcode_wvalid_MSG_ADDR_U_t;

typedef logic handcode_wvalid_MSG_DATA_t;

typedef logic handcode_wvalid_VECTOR_CTRL_t;

typedef struct packed {
    handcode_wvalid_MSG_ADDR_L_t MSG_ADDR_L;
    handcode_wvalid_MSG_ADDR_U_t MSG_ADDR_U;
    handcode_wvalid_MSG_DATA_t MSG_DATA;
    handcode_wvalid_VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_wvalid_t;

typedef logic handcode_error_MSG_ADDR_L_t;

typedef logic handcode_error_MSG_ADDR_U_t;

typedef logic handcode_error_MSG_DATA_t;

typedef logic handcode_error_VECTOR_CTRL_t;

typedef struct packed {
    handcode_error_MSG_ADDR_L_t MSG_ADDR_L;
    handcode_error_MSG_ADDR_U_t MSG_ADDR_U;
    handcode_error_MSG_DATA_t MSG_DATA;
    handcode_error_VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_error_t;

// ===================================================
// HandCoded Read/Write Structure
//    (used by project HandCoded specified registers)

// ===================================================
// HandCoded Read/Write Structure
//    (used by project HandCoded specified registers)

typedef struct packed {
    MSG_ADDR_L_t MSG_ADDR_L;
    MSG_ADDR_U_t MSG_ADDR_U;
    MSG_DATA_t MSG_DATA;
    VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_reg_read_t;

typedef struct packed {
    MSG_ADDR_L_t MSG_ADDR_L;
    MSG_ADDR_U_t MSG_ADDR_U;
    MSG_DATA_t MSG_DATA;
    VECTOR_CTRL_t VECTOR_CTRL;
} hqm_msix_mem_hc_reg_write_t;

// ===================================================
// RW/V2 Structure

// ===================================================
// Parity Bit Structure

// ===================================================
// Watch Signals Structure


endpackage: hqm_msix_mem_pkg

`endif // HQM_MSIX_MEM_PKG_VH
