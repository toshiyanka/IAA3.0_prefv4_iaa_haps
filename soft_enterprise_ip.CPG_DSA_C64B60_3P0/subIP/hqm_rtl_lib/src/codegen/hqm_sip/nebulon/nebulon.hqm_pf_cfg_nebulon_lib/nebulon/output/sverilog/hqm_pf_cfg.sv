///
///  INTEL CONFIDENTIAL
///
///  Copyright 2022 Intel Corporation All Rights Reserved.
///
///  The source code contained or described herein and all documents related
///  to the source code ("Material") are owned by Intel Corporation or its
///  suppliers or licensors. Title to the Material remains with Intel
///  Corporation or its suppliers and licensors. The Material contains trade
///  secrets and proprietary and confidential information of Intel or its
///  suppliers and licensors. The Material is protected by worldwide copyright
///  and trade secret laws and treaty provisions. No part of the Material may
///  be used, copied, reproduced, modified, published, uploaded, posted,
///  transmitted, distributed, or disclosed in any way without Intel's prior
///  express written permission.
///
///  No license under any patent, copyright, trade secret or other intellectual
///  property right is granted to or conferred upon you by disclosure or
///  delivery of the Materials, either expressly, by implication, inducement,
///  estoppel or otherwise. Any license under such intellectual property rights
///  must be express and approved by Intel in writing.
///

//                                                                             
// File:            hqm_pf_cfg.sv                                              
// Nebulon version: d22ww21.1                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2022 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             



// The NEBULON_RTLGEN_TEMPLATE env was: /p/hdk/rtl/proj_tools/nebulon_data/shdk74/20.35.01_gen3/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/rtltemplates:/p/hdk/rtl/cad/x86-64_linux26/dt/nebulon/d20ww52.1/generators/overhead_templates::/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_include_template:/nfs/site/disks/crt_tools_007/dt/nebulon/d22ww21.1/generators/rtlgen_pkg_template
//lintra push -60039
//lintra push -68099
// This include is still needed for RTLGEN_LCB
`include "rtlgen_include_hqm_pf_cfg.vh"
`include "rtlgen_pkg_hqm_pf_cfg.vh"
`include "hqm_pf_cfg_pkg.vh"

//lintra push -68094
//lintra push -60115

// ===================================================================
// Flops macros 
// ===================================================================

`ifndef RTLGEN_HQM_PF_CFG_FF
`define RTLGEN_HQM_PF_CFG_FF(rtl_clk, rst_n, rst_val, d, q) \
    always_ff @(posedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_PF_CFG_FF

`ifndef RTLGEN_HQM_PF_CFG_EN_FF
`define RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, rst_n, rst_val, en, d, q) \
    always_ff @(posedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_PF_CFG_EN_FF

`ifndef RTLGEN_HQM_PF_CFG_FF_NEGEDGE
`define RTLGEN_HQM_PF_CFG_FF_NEGEDGE(rtl_clk, rst_n, rst_val, d, q) \
    always_ff @(negedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_PF_CFG_FF_NEGEDGE

`ifndef RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE
`define RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE(rtl_clk, rst_n, rst_val, en, d, q) \
    always_ff @(negedge rtl_clk, negedge rst_n) \
        if (!rst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE

`ifndef RTLGEN_HQM_PF_CFG_FF_RSTD
`define RTLGEN_HQM_PF_CFG_FF_RSTD(rtl_clk, rst_n, rst_val, d, q) \
   genvar \gen_``d`` ; \
   generate \
      if (1) begin : \ff_rstd_``d`` \
         logic [$bits(q)-1:0] rst_vec, set_vec, d_vec, q_vec; \
         assign rst_vec = !rst_n ? ~rst_val : '0; \
         assign set_vec = !rst_n ? rst_val : '0; \
         assign d_vec = d; \
         assign q = q_vec; \
         for ( \gen_``d`` = 0 ; \gen_``d`` < $bits(q) ; \gen_``d`` = \gen_``d`` + 1)  \
            always_ff @(posedge rtl_clk, posedge rst_vec[ \gen_``d`` ], posedge set_vec[ \gen_``d`` ]) \
               if (rst_vec[ \gen_``d`` ]) \
                  q_vec[ \gen_``d`` ] <= '0; \
               else if (set_vec[ \gen_``d`` ]) \
                  q_vec[ \gen_``d`` ] <= '1; \
               else   \
                  q_vec[ \gen_``d`` ] <= d_vec[ \gen_``d`` ]; \
      end \
   endgenerate       
`endif // RTLGEN_HQM_PF_CFG_FF_RSTD


module rtlgen_hqm_pf_cfg_en_ff_rstd(rtl_clk_var, rst_n_var, rst_val_var, en_var, d_var, q_var);
parameter DATA_WIDTH=1;
input logic rtl_clk_var, rst_n_var, en_var;
input logic [DATA_WIDTH-1:0] rst_val_var, d_var;
output logic [DATA_WIDTH-1:0] q_var;

   genvar gen_var ; 
   generate 
      if (1) begin : rtlgen_en_ff_rstd
         logic [DATA_WIDTH-1:0] rst_vec, set_vec, d_vec, q_vec; 
         assign rst_vec = !rst_n_var ? ~rst_val_var : '0; 
         assign set_vec = !rst_n_var ? rst_val_var : '0; 
         assign d_vec = d_var; 
         assign q_var = q_vec; 
         for ( gen_var = 0 ; gen_var < DATA_WIDTH; gen_var = gen_var + 1)  
            always_ff @(posedge rtl_clk_var, posedge rst_vec[ gen_var ], posedge set_vec[ gen_var ]) 
               if (rst_vec[ gen_var ]) 
                  q_vec[ gen_var ] <= '0; 
               else if (set_vec[ gen_var ]) 
                  q_vec[ gen_var ] <= '1; 
               else if (en_var)  
                  q_vec[ gen_var ] <= d_vec[ gen_var ]; 
      end 
   endgenerate       

endmodule 

`ifndef RTLGEN_HQM_PF_CFG_EN_FF_RSTD
`define RTLGEN_HQM_PF_CFG_EN_FF_RSTD(rtl_clk, rst_n, rst_val, en, d, q) \
rtlgen_hqm_pf_cfg_en_ff_rstd #(.DATA_WIDTH($bits(q))) \``d``_en_ff_rstd (.rtl_clk_var(rtl_clk), .rst_n_var(rst_n), .rst_val_var(rst_val), .en_var(en), .d_var(d), .q_var(q));
`endif // RTLGEN_HQM_PF_CFG_EN_FF_RSTD



`ifndef RTLGEN_HQM_PF_CFG_FF_SYNCRST
`define RTLGEN_HQM_PF_CFG_FF_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
    always_ff @(posedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_PF_CFG_FF_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_EN_FF_SYNCRST
`define RTLGEN_HQM_PF_CFG_EN_FF_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
    always_ff @(posedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_PF_CFG_EN_FF_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_PF_CFG_FF_NEGEDGE_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
    always_ff @(negedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else        q <= d;
`endif // RTLGEN_HQM_PF_CFG_FF_NEGEDGE_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
    always_ff @(negedge rtl_clk) \
        if (!syncrst_n) q <= rst_val; \
        else \
            if (en) q <= d;
`endif // RTLGEN_HQM_PF_CFG_EN_FF_NEGEDGE_SYNCRST

// BOTHRST is cancelled. Should not be used. 
//
// `ifndef RTLGEN_HQM_PF_CFG_FF_BOTHRST
// `define RTLGEN_HQM_PF_CFG_FF_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, d, q) \
//     always_ff @(posedge rtl_clk, negedge rst_n) \
//         if (!rst_n) q <= rst_val; \
//         else if (!syncrst_n) q <= rst_val; \
//         else        q <= d;
// `endif // RTLGEN_HQM_PF_CFG_FF_BOTHRST
// 
// `ifndef RTLGEN_HQM_PF_CFG_EN_FF_BOTHRST
// `define RTLGEN_HQM_PF_CFG_EN_FF_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, en, d, q) \
//     always_ff @(posedge rtl_clk, negedge rst_n) \
//         if (!rst_n) q <= rst_val; \
//         else if (!syncrst_n) q <= rst_val; \
//         else if (en) q <= d;
// 
// `endif // RTLGEN_HQM_PF_CFG_EN_FF_BOTHRST


// ===================================================================
// Latch macros -- compatible with nhm_macros RST_LATCH & EN_RST_LATCH
// ===================================================================

`ifndef RTLGEN_HQM_PF_CFG_LATCH_LOW
`define RTLGEN_HQM_PF_CFG_LATCH_LOW(rtl_clk, d, q) \
   always_latch if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) q <= d;   
`endif // RTLGEN_HQM_PF_CFG_LATCH_LOW

`ifndef RTLGEN_HQM_PF_CFG_PH2_FF
`define RTLGEN_HQM_PF_CFG_PH2_FF(rtl_clk, d, q) \
    always_ff @(posedge rtl_clk) \
     q <= d;
`endif // RTLGEN_HQM_PF_CFG_PH2_FF

// Can't be override
`ifndef RTLGEN_HQM_PF_CFG_LATCH_LOW_ASSIGN
`define RTLGEN_HQM_PF_CFG_LATCH_LOW_ASSIGN(n) \
   `RTLGEN_HQM_PF_CFG_LATCH_LOW(gated_clk,``n``,``n``_low)
`endif // RTLGEN_HQM_PF_CFG_LATCH_LOW_ASSIGN

// Can't be override
`ifndef RTLGEN_HQM_PF_CFG_PH2_FF_ASSIGN
`define RTLGEN_HQM_PF_CFG_PH2_FF_ASSIGN(n) \
   `RTLGEN_HQM_PF_CFG_PH2_FF(gated_clk,``n``,``n``_low)
`endif // RTLGEN_HQM_PF_CFG_PH2_FF_ASSIGN

`ifndef RTLGEN_HQM_PF_CFG_LATCH
`define RTLGEN_HQM_PF_CFG_LATCH(rtl_clk, rst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if (!rst_n) q <= rst_val;                  \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) q <= d; \
      end                                           
`endif // RTLGEN_HQM_PF_CFG_LATCH

// In order not to touch regular LATCH_LOW (without reset) for backward compatible, 
//  an additional LATCH_LOW macro was added for reset with suffix _ASYNCRST 
`ifndef RTLGEN_HQM_PF_CFG_LATCH_LOW_ASYNCRST
`define RTLGEN_HQM_PF_CFG_LATCH_LOW_ASYNCRST(rtl_clk, rst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if (!rst_n) q <= rst_val;                  \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) q <= d; \
      end                                           
`endif // RTLGEN_HQM_PF_CFG_LATCH_LOW_ASYNCRST

`ifndef RTLGEN_HQM_PF_CFG_EN_LATCH
`define RTLGEN_HQM_PF_CFG_EN_LATCH(rtl_clk, rst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if (!rst_n) q <= rst_val;                         \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) begin \
              if (en) q <= d;                              \
         end                                               \
      end                                                  
`endif // RTLGEN_HQM_PF_CFG_EN_LATCH

`ifndef RTLGEN_HQM_PF_CFG_EN_LATCH_LOW
`define RTLGEN_HQM_PF_CFG_EN_LATCH_LOW(rtl_clk, rst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if (!rst_n) q <= rst_val;                         \
         else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) begin \
              if (en) q <= d;                              \
         end                                               \
      end                                                  
`endif // RTLGEN_HQM_PF_CFG_EN_LATCH_LOW

`ifndef RTLGEN_HQM_PF_CFG_LATCH_SYNCRST
`define RTLGEN_HQM_PF_CFG_LATCH_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) \
            if (!syncrst_n) q <= rst_val;           \
            else            q <=  d;                \
      end                                           
`endif // RTLGEN_HQM_PF_CFG_LATCH_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_PF_CFG_LATCH_LOW_SYNCRST(rtl_clk, syncrst_n, rst_val, d, q) \
   always_latch                                     \
      begin                                         \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk))) \
            if (!syncrst_n) q <= rst_val;           \
            else            q <=  d;                \
      end                                           
`endif // RTLGEN_HQM_PF_CFG_LATCH_LOW_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_EN_LATCH_SYNCRST
`define RTLGEN_HQM_PF_CFG_EN_LATCH_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk)))  \
            if (!syncrst_n) q <= rst_val;                  \
            else if (en)    q <=  d;                       \
      end                                                  
`endif // RTLGEN_HQM_PF_CFG_EN_LATCH_SYNCRST

`ifndef RTLGEN_HQM_PF_CFG_EN_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_PF_CFG_EN_LATCH_LOW_SYNCRST(rtl_clk, syncrst_n, rst_val, en, d, q) \
   always_latch                                            \
      begin                                                \
         if ((`ifdef LINTRA_OL (* ol_clock *) `endif (~rtl_clk)))  \
            if (!syncrst_n) q <= rst_val;                  \
            else if (en)    q <=  d;                       \
      end                                                  
`endif // RTLGEN_HQM_PF_CFG_EN_LATCH_LOW_SYNCRST

// BOTHRST is cancelled. Should not be used. 
// 
// `ifndef RTLGEN_HQM_PF_CFG_LATCH_BOTHRST
// `define RTLGEN_HQM_PF_CFG_LATCH_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, d, q) \
//    always_latch                                     \
//       begin                                         \
//          if (!rst_n) q <= rst_val;                  \
//          else if (`ifdef LINTRA _OL(* ol_clock *) `endif (rtl_clk)) \
//             if (!syncrst_n) q <= rst_val;           \
//             else            q <=  d;                \
//       end                                           
// `endif // RTLGEN_HQM_PF_CFG_LATCH_BOTHRST
// 
// `ifndef RTLGEN_HQM_PF_CFG_EN_LATCH_BOTHRST
// `define RTLGEN_HQM_PF_CFG_EN_LATCH_BOTHRST(rtl_clk, rst_n, syncrst_n, rst_val, en, d, q) \
//    always_latch                                     \
//       begin                                         \
//          if (!rst_n) q <= rst_val;                  \
//          else if ((`ifdef LINTRA_OL (* ol_clock *) `endif (rtl_clk))) \
//             if (!syncrst_n) q <= rst_val;           \
//             else if (en)    q <=  d;                \
//       end                                           
// `endif // RTLGEN_HQM_PF_CFG_EN_LATCH_BOTHRST


// ===================================================================
// LCB macros 
// ===================================================================

`ifndef RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES
`define RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES(clock, enable, lcb_clk) \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & enable;
`endif // RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES

`ifndef RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES_SYNCRST(clock, enable, lcb_clk, sync_rst) \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & (enable | {$bits(lcb_clk){!sync_rst}});
`endif // RTLGEN_HQM_PF_CFG_LCB_HOLD_REQ_2CYCLES_SYNCRST


`ifndef RTLGEN_HQM_PF_CFG_LCB_DELAY_FFEN
`define RTLGEN_HQM_PF_CFG_LCB_DELAY_FFEN(clock, delay_rst_n, enable, lcb_clk, dly_seq_type, close_ff_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_close_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   logic [$bits(lcb_clk)-1:0] ``enable``_close; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   always_comb ``enable``_dly_up = ``enable``_nxt | ``enable``_close; \
   always_comb ``enable``_close_up = ``enable``_dly | ``enable``_close; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) begin \
  `RTLGEN_HQM_PF_CFG_``close_ff_type``(clock,delay_rst_n,1'b0,``enable``_close_up[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ],``enable``_close[ ``enable``_gen_var ]) \
  `RTLGEN_HQM_PF_CFG_``dly_seq_type``(clock,delay_rst_n,1'b0,``enable``_dly_up[ ``enable``_gen_var ],``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
         end      \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_PF_CFG_LCB_DELAY_EN


`ifndef RTLGEN_HQM_PF_CFG_LCB_DELAY_EN
`define RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock, delay_rst_n, enable, lcb_clk, seq_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_up;  \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   always_comb ``enable``_up = ``enable``_nxt | ``enable``_dly; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) \
  `RTLGEN_HQM_PF_CFG_``seq_type``(clock,delay_rst_n,1'b0,``enable``_up[ ``enable``_gen_var ],``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_PF_CFG_LCB_DELAY_EN

`ifndef RTLGEN_HQM_PF_CFG_LCB_DELAY
`define RTLGEN_HQM_PF_CFG_LCB_DELAY(clock, delay_rst_n, enable, lcb_clk, seq_type, nxt_expr) \
   logic [$bits(lcb_clk)-1:0] ``enable``_nxt; \
   logic [$bits(lcb_clk)-1:0] ``enable``_dly; \
   always_comb ``enable``_nxt = ``nxt_expr``; \
   genvar ``enable``_gen_var ; \
   generate \
      if (1) begin : rtlgen_lcb_``enable``_dly \
         for ( ``enable``_gen_var = 0 ; ``enable``_gen_var < $bits(lcb_clk); ``enable``_gen_var = ``enable``_gen_var + 1) \
  `RTLGEN_HQM_PF_CFG_``seq_type``(clock,delay_rst_n,1'b0,``enable``_nxt[ ``enable``_gen_var ],``enable``_dly[ ``enable``_gen_var ]) \
      end      \
   endgenerate \
   always_comb lcb_clk = {$bits(lcb_clk){clock}} & ``enable``_dly;
`endif // RTLGEN_HQM_PF_CFG_LCB_DELAY

// LCB MODE: LATCH_FFEN_LOW
`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_FFEN(clock,delay_rst_n,enable,lcb_clk,EN_LATCH_LOW,EN_FF_NEGEDGE,enable) 
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW

`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_FFEN(clock,1'b1,enable,lcb_clk,EN_LATCH_LOW_SYNCRST,EN_FF_NEGEDGE_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}}) 
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_FFEN_LOW_SYNCRST

// LCB MODE: LATCH_EN_LOW
`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_LATCH_LOW,enable)
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW

`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_LATCH_LOW_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_EN_LOW_SYNCRST

// LCB MODE: LATCH_LOW
`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW(clock, delay_rst_n, enable, lcb_clk) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY(clock,delay_rst_n,enable,lcb_clk,LATCH_LOW_ASYNCRST,enable)
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW

`ifndef RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY(clock,1'b1,enable,lcb_clk,LATCH_LOW_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_PF_CFG_LCB_LATCH_LOW_SYNCRST

// LCB MODE: FF_NEGEDGE
`ifndef RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE
`define RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE(clock, delay_rst_n, enable, lcb_clk)  \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_FF_NEGEDGE,enable)
`endif // RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE

`ifndef RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_FF_NEGEDGE_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_PF_CFG_LCB_FF_NEGEDGE_SYNCRST

// LCB MODE: FF_POSEDGE
`ifndef RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE
`define RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE(clock, delay_rst_n, enable, lcb_clk)  \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,delay_rst_n,enable,lcb_clk,EN_FF,enable)
`endif // RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE

`ifndef RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE_SYNCRST
`define RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE_SYNCRST(clock, delay_rst_n, enable, lcb_clk, sync_rst) \
   `RTLGEN_HQM_PF_CFG_LCB_DELAY_EN(clock,1'b1,enable,lcb_clk,EN_FF_SYNCRST,enable|{$bits(lcb_clk){!sync_rst}})
`endif // RTLGEN_HQM_PF_CFG_LCB_FF_POSEDGE_SYNCRST



//lintra pop

module hqm_pf_cfg ( //lintra s-2096
    // Clocks
    gated_clk,
    rtl_clk,

    // Resets
    hqm_csr_pf0_pwr_rst_n,
    hqm_csr_pf0_rst_n,
    prim_gated_rst_b,


    // Register Inputs
    load_AER_CAP_CONTROL,
    load_AER_CAP_CORR_ERR_STATUS,
    load_AER_CAP_HEADER_LOG_0,
    load_AER_CAP_HEADER_LOG_1,
    load_AER_CAP_HEADER_LOG_2,
    load_AER_CAP_HEADER_LOG_3,
    load_AER_CAP_TLP_PREFIX_LOG_0,
    load_AER_CAP_UNCORR_ERR_STATUS,
    load_DEVICE_STATUS,
    load_PCIE_CAP_DEVICE_STATUS,

    new_AER_CAP_CONTROL,
    new_AER_CAP_CORR_ERR_STATUS,
    new_AER_CAP_HEADER_LOG_0,
    new_AER_CAP_HEADER_LOG_1,
    new_AER_CAP_HEADER_LOG_2,
    new_AER_CAP_HEADER_LOG_3,
    new_AER_CAP_TLP_PREFIX_LOG_0,
    new_AER_CAP_UNCORR_ERR_STATUS,
    new_DEVICE_ID,
    new_DEVICE_STATUS,
    new_HEADER_TYPE,
    new_PCIE_CAP,
    new_PCIE_CAP_DEVICE_CAP_2,
    new_PCIE_CAP_DEVICE_STATUS,
    new_REVISION_ID_CLASS_CODE,


    // Register Outputs
    ACS_CAP,
    ACS_CAP_CONTROL,
    ACS_CAP_ID,
    ACS_CAP_VERSION_NEXT_PTR,
    AER_CAP_CONTROL,
    AER_CAP_CORR_ERR_MASK,
    AER_CAP_CORR_ERR_STATUS,
    AER_CAP_ERROR_SOURCE_IDENT,
    AER_CAP_HEADER_LOG_0,
    AER_CAP_HEADER_LOG_1,
    AER_CAP_HEADER_LOG_2,
    AER_CAP_HEADER_LOG_3,
    AER_CAP_ID,
    AER_CAP_ROOT_ERROR_COMMAND,
    AER_CAP_ROOT_ERROR_STATUS,
    AER_CAP_TLP_PREFIX_LOG_0,
    AER_CAP_TLP_PREFIX_LOG_1,
    AER_CAP_TLP_PREFIX_LOG_2,
    AER_CAP_TLP_PREFIX_LOG_3,
    AER_CAP_UNCORR_ERR_MASK,
    AER_CAP_UNCORR_ERR_SEV,
    AER_CAP_UNCORR_ERR_STATUS,
    AER_CAP_VERSION_NEXT_PTR,
    ATS_CAP,
    ATS_CAP_CONTROL,
    ATS_CAP_ID,
    ATS_CAP_VERSION_NEXT_PTR,
    CACHE_LINE_SIZE,
    CAP_PTR,
    CSR_BAR_L,
    CSR_BAR_U,
    DEVICE_COMMAND,
    DEVICE_ID,
    DEVICE_STATUS,
    DVSEC_CAP_ID,
    DVSEC_CAP_VERSION_NEXT_PTR,
    DVSEC_HDR1,
    DVSEC_HDR2,
    FUNC_BAR_L,
    FUNC_BAR_U,
    HEADER_TYPE,
    INT_LINE,
    INT_PIN,
    MSIX_CAP_CONTROL,
    MSIX_CAP_ID,
    MSIX_CAP_NEXT_CAP_PTR,
    MSIX_CAP_PBA_OFFSET_BIR,
    MSIX_CAP_TABLE_OFFSET_BIR,
    PASID_CAP,
    PASID_CAP_ID,
    PASID_CAP_VERSION_NEXT_PTR,
    PASID_CONTROL,
    PCIE_CAP,
    PCIE_CAP_DEVICE_CAP,
    PCIE_CAP_DEVICE_CAP_2,
    PCIE_CAP_DEVICE_CONTROL,
    PCIE_CAP_DEVICE_CONTROL_2,
    PCIE_CAP_DEVICE_STATUS,
    PCIE_CAP_ID,
    PCIE_CAP_LINK_CAP,
    PCIE_CAP_LINK_CONTROL,
    PCIE_CAP_LINK_STATUS,
    PCIE_CAP_NEXT_CAP_PTR,
    PM_CAP,
    PM_CAP_CONTROL_STATUS,
    PM_CAP_ID,
    PM_CAP_NEXT_CAP_PTR,
    REVISION_ID_CLASS_CODE,
    SCIOV_CAP,
    SCIOV_IMS,
    SCIOV_SUPP_PGSZ,
    SCIOV_SYS_PGSZ,
    SUBSYSTEM_ID,
    SUBSYSTEM_VENDOR_ID,
    VENDOR_ID,


    // Register signals for HandCoded registers





    // Config Access
    req,
    ack
    

);

import hqm_pf_cfg_pkg::*;
import rtlgen_pkg_hqm_pf_cfg::*;

parameter  HQM_PF_CFG_CFG_ADDR_MSB = 11;
parameter [HQM_PF_CFG_CFG_ADDR_MSB:0] HQM_PF_CFG_OFFSET = {HQM_PF_CFG_CFG_ADDR_MSB+1{1'b0}};
localparam  ADDR_LSB_BUS_ALIGN = 2;
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] VENDOR_ID_DECODE_ADDR = VENDOR_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DEVICE_ID_DECODE_ADDR = DEVICE_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DEVICE_COMMAND_DECODE_ADDR = DEVICE_COMMAND_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DEVICE_STATUS_DECODE_ADDR = DEVICE_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] REVISION_ID_CLASS_CODE_DECODE_ADDR = REVISION_ID_CLASS_CODE_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] CACHE_LINE_SIZE_DECODE_ADDR = CACHE_LINE_SIZE_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] HEADER_TYPE_DECODE_ADDR = HEADER_TYPE_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] FUNC_BAR_L_DECODE_ADDR = FUNC_BAR_L_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] FUNC_BAR_U_DECODE_ADDR = FUNC_BAR_U_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] CSR_BAR_L_DECODE_ADDR = CSR_BAR_L_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] CSR_BAR_U_DECODE_ADDR = CSR_BAR_U_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SUBSYSTEM_VENDOR_ID_DECODE_ADDR = SUBSYSTEM_VENDOR_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SUBSYSTEM_ID_DECODE_ADDR = SUBSYSTEM_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] CAP_PTR_DECODE_ADDR = CAP_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] INT_LINE_DECODE_ADDR = INT_LINE_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] INT_PIN_DECODE_ADDR = INT_PIN_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] MSIX_CAP_ID_DECODE_ADDR = MSIX_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] MSIX_CAP_NEXT_CAP_PTR_DECODE_ADDR = MSIX_CAP_NEXT_CAP_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] MSIX_CAP_CONTROL_DECODE_ADDR = MSIX_CAP_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR = MSIX_CAP_TABLE_OFFSET_BIR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR = MSIX_CAP_PBA_OFFSET_BIR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_ID_DECODE_ADDR = PCIE_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_NEXT_CAP_PTR_DECODE_ADDR = PCIE_CAP_NEXT_CAP_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DECODE_ADDR = PCIE_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DEVICE_CAP_DECODE_ADDR = PCIE_CAP_DEVICE_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR = PCIE_CAP_DEVICE_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DEVICE_STATUS_DECODE_ADDR = PCIE_CAP_DEVICE_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_LINK_CAP_DECODE_ADDR = PCIE_CAP_LINK_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_LINK_CONTROL_DECODE_ADDR = PCIE_CAP_LINK_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_LINK_STATUS_DECODE_ADDR = PCIE_CAP_LINK_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR = PCIE_CAP_DEVICE_CAP_2_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR = PCIE_CAP_DEVICE_CONTROL_2_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PM_CAP_ID_DECODE_ADDR = PM_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PM_CAP_NEXT_CAP_PTR_DECODE_ADDR = PM_CAP_NEXT_CAP_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PM_CAP_DECODE_ADDR = PM_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PM_CAP_CONTROL_STATUS_DECODE_ADDR = PM_CAP_CONTROL_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ACS_CAP_ID_DECODE_ADDR = ACS_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ACS_CAP_VERSION_NEXT_PTR_DECODE_ADDR = ACS_CAP_VERSION_NEXT_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ACS_CAP_DECODE_ADDR = ACS_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ACS_CAP_CONTROL_DECODE_ADDR = ACS_CAP_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PASID_CAP_ID_DECODE_ADDR = PASID_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PASID_CAP_VERSION_NEXT_PTR_DECODE_ADDR = PASID_CAP_VERSION_NEXT_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PASID_CAP_DECODE_ADDR = PASID_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] PASID_CONTROL_DECODE_ADDR = PASID_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DVSEC_CAP_ID_DECODE_ADDR = DVSEC_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DVSEC_CAP_VERSION_NEXT_PTR_DECODE_ADDR = DVSEC_CAP_VERSION_NEXT_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DVSEC_HDR1_DECODE_ADDR = DVSEC_HDR1_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] DVSEC_HDR2_DECODE_ADDR = DVSEC_HDR2_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SCIOV_CAP_DECODE_ADDR = SCIOV_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SCIOV_SUPP_PGSZ_DECODE_ADDR = SCIOV_SUPP_PGSZ_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SCIOV_SYS_PGSZ_DECODE_ADDR = SCIOV_SYS_PGSZ_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] SCIOV_IMS_DECODE_ADDR = SCIOV_IMS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_ID_DECODE_ADDR = AER_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_VERSION_NEXT_PTR_DECODE_ADDR = AER_CAP_VERSION_NEXT_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR = AER_CAP_UNCORR_ERR_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR = AER_CAP_UNCORR_ERR_MASK_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR = AER_CAP_UNCORR_ERR_SEV_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_CORR_ERR_STATUS_DECODE_ADDR = AER_CAP_CORR_ERR_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_CORR_ERR_MASK_DECODE_ADDR = AER_CAP_CORR_ERR_MASK_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_CONTROL_DECODE_ADDR = AER_CAP_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_HEADER_LOG_0_DECODE_ADDR = AER_CAP_HEADER_LOG_0_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_HEADER_LOG_1_DECODE_ADDR = AER_CAP_HEADER_LOG_1_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_HEADER_LOG_2_DECODE_ADDR = AER_CAP_HEADER_LOG_2_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_HEADER_LOG_3_DECODE_ADDR = AER_CAP_HEADER_LOG_3_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR = AER_CAP_ROOT_ERROR_COMMAND_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR = AER_CAP_ROOT_ERROR_STATUS_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR = AER_CAP_ERROR_SOURCE_IDENT_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR = AER_CAP_TLP_PREFIX_LOG_0_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR = AER_CAP_TLP_PREFIX_LOG_1_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR = AER_CAP_TLP_PREFIX_LOG_2_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR = AER_CAP_TLP_PREFIX_LOG_3_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ATS_CAP_ID_DECODE_ADDR = ATS_CAP_ID_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ATS_CAP_VERSION_NEXT_PTR_DECODE_ADDR = ATS_CAP_VERSION_NEXT_PTR_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ATS_CAP_DECODE_ADDR = ATS_CAP_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
localparam [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] ATS_CAP_CONTROL_DECODE_ADDR = ATS_CAP_CONTROL_CR_ADDR[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] + HQM_PF_CFG_OFFSET[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];

    // Clocks
input logic  gated_clk;
input logic  rtl_clk;

    // Resets
input logic  hqm_csr_pf0_pwr_rst_n;
input logic  hqm_csr_pf0_rst_n;
input logic  prim_gated_rst_b;


    // Register Inputs
input load_AER_CAP_CONTROL_t  load_AER_CAP_CONTROL;
input load_AER_CAP_CORR_ERR_STATUS_t  load_AER_CAP_CORR_ERR_STATUS;
input load_AER_CAP_HEADER_LOG_0_t  load_AER_CAP_HEADER_LOG_0;
input load_AER_CAP_HEADER_LOG_1_t  load_AER_CAP_HEADER_LOG_1;
input load_AER_CAP_HEADER_LOG_2_t  load_AER_CAP_HEADER_LOG_2;
input load_AER_CAP_HEADER_LOG_3_t  load_AER_CAP_HEADER_LOG_3;
input load_AER_CAP_TLP_PREFIX_LOG_0_t  load_AER_CAP_TLP_PREFIX_LOG_0;
input load_AER_CAP_UNCORR_ERR_STATUS_t  load_AER_CAP_UNCORR_ERR_STATUS;
input load_DEVICE_STATUS_t  load_DEVICE_STATUS;
input load_PCIE_CAP_DEVICE_STATUS_t  load_PCIE_CAP_DEVICE_STATUS;

input new_AER_CAP_CONTROL_t  new_AER_CAP_CONTROL;
input new_AER_CAP_CORR_ERR_STATUS_t  new_AER_CAP_CORR_ERR_STATUS;
input new_AER_CAP_HEADER_LOG_0_t  new_AER_CAP_HEADER_LOG_0;
input new_AER_CAP_HEADER_LOG_1_t  new_AER_CAP_HEADER_LOG_1;
input new_AER_CAP_HEADER_LOG_2_t  new_AER_CAP_HEADER_LOG_2;
input new_AER_CAP_HEADER_LOG_3_t  new_AER_CAP_HEADER_LOG_3;
input new_AER_CAP_TLP_PREFIX_LOG_0_t  new_AER_CAP_TLP_PREFIX_LOG_0;
input new_AER_CAP_UNCORR_ERR_STATUS_t  new_AER_CAP_UNCORR_ERR_STATUS;
input new_DEVICE_ID_t  new_DEVICE_ID;
input new_DEVICE_STATUS_t  new_DEVICE_STATUS;
input new_HEADER_TYPE_t  new_HEADER_TYPE;
input new_PCIE_CAP_t  new_PCIE_CAP;
input new_PCIE_CAP_DEVICE_CAP_2_t  new_PCIE_CAP_DEVICE_CAP_2;
input new_PCIE_CAP_DEVICE_STATUS_t  new_PCIE_CAP_DEVICE_STATUS;
input new_REVISION_ID_CLASS_CODE_t  new_REVISION_ID_CLASS_CODE;


    // Register Outputs
output ACS_CAP_t  ACS_CAP;
output ACS_CAP_CONTROL_t  ACS_CAP_CONTROL;
output ACS_CAP_ID_t  ACS_CAP_ID;
output ACS_CAP_VERSION_NEXT_PTR_t  ACS_CAP_VERSION_NEXT_PTR;
output AER_CAP_CONTROL_t  AER_CAP_CONTROL;
output AER_CAP_CORR_ERR_MASK_t  AER_CAP_CORR_ERR_MASK;
output AER_CAP_CORR_ERR_STATUS_t  AER_CAP_CORR_ERR_STATUS;
output AER_CAP_ERROR_SOURCE_IDENT_t  AER_CAP_ERROR_SOURCE_IDENT;
output AER_CAP_HEADER_LOG_0_t  AER_CAP_HEADER_LOG_0;
output AER_CAP_HEADER_LOG_1_t  AER_CAP_HEADER_LOG_1;
output AER_CAP_HEADER_LOG_2_t  AER_CAP_HEADER_LOG_2;
output AER_CAP_HEADER_LOG_3_t  AER_CAP_HEADER_LOG_3;
output AER_CAP_ID_t  AER_CAP_ID;
output AER_CAP_ROOT_ERROR_COMMAND_t  AER_CAP_ROOT_ERROR_COMMAND;
output AER_CAP_ROOT_ERROR_STATUS_t  AER_CAP_ROOT_ERROR_STATUS;
output AER_CAP_TLP_PREFIX_LOG_0_t  AER_CAP_TLP_PREFIX_LOG_0;
output AER_CAP_TLP_PREFIX_LOG_1_t  AER_CAP_TLP_PREFIX_LOG_1;
output AER_CAP_TLP_PREFIX_LOG_2_t  AER_CAP_TLP_PREFIX_LOG_2;
output AER_CAP_TLP_PREFIX_LOG_3_t  AER_CAP_TLP_PREFIX_LOG_3;
output AER_CAP_UNCORR_ERR_MASK_t  AER_CAP_UNCORR_ERR_MASK;
output AER_CAP_UNCORR_ERR_SEV_t  AER_CAP_UNCORR_ERR_SEV;
output AER_CAP_UNCORR_ERR_STATUS_t  AER_CAP_UNCORR_ERR_STATUS;
output AER_CAP_VERSION_NEXT_PTR_t  AER_CAP_VERSION_NEXT_PTR;
output ATS_CAP_t  ATS_CAP;
output ATS_CAP_CONTROL_t  ATS_CAP_CONTROL;
output ATS_CAP_ID_t  ATS_CAP_ID;
output ATS_CAP_VERSION_NEXT_PTR_t  ATS_CAP_VERSION_NEXT_PTR;
output CACHE_LINE_SIZE_t  CACHE_LINE_SIZE;
output CAP_PTR_t  CAP_PTR;
output CSR_BAR_L_t  CSR_BAR_L;
output CSR_BAR_U_t  CSR_BAR_U;
output DEVICE_COMMAND_t  DEVICE_COMMAND;
output DEVICE_ID_t  DEVICE_ID;
output DEVICE_STATUS_t  DEVICE_STATUS;
output DVSEC_CAP_ID_t  DVSEC_CAP_ID;
output DVSEC_CAP_VERSION_NEXT_PTR_t  DVSEC_CAP_VERSION_NEXT_PTR;
output DVSEC_HDR1_t  DVSEC_HDR1;
output DVSEC_HDR2_t  DVSEC_HDR2;
output FUNC_BAR_L_t  FUNC_BAR_L;
output FUNC_BAR_U_t  FUNC_BAR_U;
output HEADER_TYPE_t  HEADER_TYPE;
output INT_LINE_t  INT_LINE;
output INT_PIN_t  INT_PIN;
output MSIX_CAP_CONTROL_t  MSIX_CAP_CONTROL;
output MSIX_CAP_ID_t  MSIX_CAP_ID;
output MSIX_CAP_NEXT_CAP_PTR_t  MSIX_CAP_NEXT_CAP_PTR;
output MSIX_CAP_PBA_OFFSET_BIR_t  MSIX_CAP_PBA_OFFSET_BIR;
output MSIX_CAP_TABLE_OFFSET_BIR_t  MSIX_CAP_TABLE_OFFSET_BIR;
output PASID_CAP_t  PASID_CAP;
output PASID_CAP_ID_t  PASID_CAP_ID;
output PASID_CAP_VERSION_NEXT_PTR_t  PASID_CAP_VERSION_NEXT_PTR;
output PASID_CONTROL_t  PASID_CONTROL;
output PCIE_CAP_t  PCIE_CAP;
output PCIE_CAP_DEVICE_CAP_t  PCIE_CAP_DEVICE_CAP;
output PCIE_CAP_DEVICE_CAP_2_t  PCIE_CAP_DEVICE_CAP_2;
output PCIE_CAP_DEVICE_CONTROL_t  PCIE_CAP_DEVICE_CONTROL;
output PCIE_CAP_DEVICE_CONTROL_2_t  PCIE_CAP_DEVICE_CONTROL_2;
output PCIE_CAP_DEVICE_STATUS_t  PCIE_CAP_DEVICE_STATUS;
output PCIE_CAP_ID_t  PCIE_CAP_ID;
output PCIE_CAP_LINK_CAP_t  PCIE_CAP_LINK_CAP;
output PCIE_CAP_LINK_CONTROL_t  PCIE_CAP_LINK_CONTROL;
output PCIE_CAP_LINK_STATUS_t  PCIE_CAP_LINK_STATUS;
output PCIE_CAP_NEXT_CAP_PTR_t  PCIE_CAP_NEXT_CAP_PTR;
output PM_CAP_t  PM_CAP;
output PM_CAP_CONTROL_STATUS_t  PM_CAP_CONTROL_STATUS;
output PM_CAP_ID_t  PM_CAP_ID;
output PM_CAP_NEXT_CAP_PTR_t  PM_CAP_NEXT_CAP_PTR;
output REVISION_ID_CLASS_CODE_t  REVISION_ID_CLASS_CODE;
output SCIOV_CAP_t  SCIOV_CAP;
output SCIOV_IMS_t  SCIOV_IMS;
output SCIOV_SUPP_PGSZ_t  SCIOV_SUPP_PGSZ;
output SCIOV_SYS_PGSZ_t  SCIOV_SYS_PGSZ;
output SUBSYSTEM_ID_t  SUBSYSTEM_ID;
output SUBSYSTEM_VENDOR_ID_t  SUBSYSTEM_VENDOR_ID;
output VENDOR_ID_t  VENDOR_ID;


    // Register signals for HandCoded registers





    // Config Access
input hqm_pf_cfg_cr_req_t  req;
output hqm_pf_cfg_cr_ack_t  ack;
    

// ======================================================================
// begin decode and addr logic section {


function automatic logic f_IsCFGRd (
    input logic [3:0] req_opcode
);
    f_IsCFGRd = (req_opcode == CFGRD); 
endfunction : f_IsCFGRd

function automatic logic f_IsCFGWr (
    input logic [3:0] req_opcode
);
    f_IsCFGWr = (req_opcode == CFGWR); 
endfunction : f_IsCFGWr

function automatic logic [CR_REQ_ADDR_HI:0] f_CFGAddr (
    input hqm_pf_cfg_cr_req_t req
);
begin
    f_CFGAddr[CR_REQ_ADDR_HI:0] = 48'h0;
    f_CFGAddr[CR_CFG_ADDR_HI:0] = 
       req.addr.cfg.offset[CR_CFG_ADDR_HI:0];
end
endfunction : f_CFGAddr


function automatic logic f_IsRdOpCode (
    input logic [3:0] req_opcode
);
    f_IsRdOpCode = (!req_opcode[0]); 
endfunction : f_IsRdOpCode

function automatic logic f_IsWrOpCode (
    input logic [3:0] req_opcode
);
    f_IsWrOpCode = (req_opcode[0]); 
endfunction : f_IsWrOpCode

// Shared registers definitions





logic [3:0] req_opcode;
always_comb req_opcode = {1'b0, req.opcode[2:0]};

logic req_valid;
assign req_valid = req.valid;


logic IsWrOpcode;
logic IsRdOpcode;
assign IsWrOpcode = f_IsWrOpCode(req_opcode);
assign IsRdOpcode = f_IsRdOpCode(req_opcode);

logic IsCFGRd;
logic IsCFGWr;
assign IsCFGRd = f_IsCFGRd(req_opcode);
assign IsCFGWr = f_IsCFGWr(req_opcode);


logic [47:0] req_addr;
always_comb begin : REQ_ADDR_BLOCK
    unique casez (req_opcode) 
        CFGRD: begin 
            req_addr = f_CFGAddr(req);
        end 
        CFGWR: begin
            req_addr = f_CFGAddr(req);
        end 
        default: begin
           req_addr = 48'h0;
        end
    endcase 
end

logic [HQM_PF_CFG_CFG_ADDR_MSB-ADDR_LSB_BUS_ALIGN:0] case_req_addr_HQM_PF_CFG_CFG;
assign case_req_addr_HQM_PF_CFG_CFG = req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN];
logic [3:0] be;
always_comb be = {4{req.valid}} & req.be;
logic [3:0] sai_successfull_per_byte;
logic [31:0] read_data;
logic [31:0] write_data;




// ======================================================================
// begin register logic section {

//---------------------------------------------------------------------
// VENDOR_ID Address Decode

// ----------------------------------------------------------------------
// VENDOR_ID.VID x8 RO, using RO template.
assign VENDOR_ID.VID = 16'h8086;



//---------------------------------------------------------------------
// DEVICE_ID Address Decode
// ----------------------------------------------------------------------
// DEVICE_ID.DID x8 RO/V, using RO/V template.
assign DEVICE_ID.DID = new_DEVICE_ID.DID;




//---------------------------------------------------------------------
// DEVICE_COMMAND Address Decode
logic  addr_decode_DEVICE_COMMAND;
logic  write_req_DEVICE_COMMAND;
always_comb begin
   addr_decode_DEVICE_COMMAND = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == DEVICE_COMMAND_DECODE_ADDR) && req.valid ;
   write_req_DEVICE_COMMAND = IsCFGWr && addr_decode_DEVICE_COMMAND;
end

// ----------------------------------------------------------------------
// DEVICE_COMMAND.IO x1 RO, using RO template.
assign DEVICE_COMMAND.IO = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.MEM x1 RW, using RW template.
logic [0:0] up_DEVICE_COMMAND_MEM;
always_comb begin
 up_DEVICE_COMMAND_MEM =
    ({1{write_req_DEVICE_COMMAND }} &
    be[0:0]);
end

logic [0:0] nxt_DEVICE_COMMAND_MEM;
always_comb begin
 nxt_DEVICE_COMMAND_MEM = write_data[1:1];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_COMMAND_MEM[0], nxt_DEVICE_COMMAND_MEM[0:0], DEVICE_COMMAND.MEM[0:0])

// ----------------------------------------------------------------------
// DEVICE_COMMAND.BM x1 RW, using RW template.
logic [0:0] up_DEVICE_COMMAND_BM;
always_comb begin
 up_DEVICE_COMMAND_BM =
    ({1{write_req_DEVICE_COMMAND }} &
    be[0:0]);
end

logic [0:0] nxt_DEVICE_COMMAND_BM;
always_comb begin
 nxt_DEVICE_COMMAND_BM = write_data[2:2];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_COMMAND_BM[0], nxt_DEVICE_COMMAND_BM[0:0], DEVICE_COMMAND.BM[0:0])

// ----------------------------------------------------------------------
// DEVICE_COMMAND.SS x1 RO, using RO template.
assign DEVICE_COMMAND.SS = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.MWE x1 RO, using RO template.
assign DEVICE_COMMAND.MWE = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.VPS x1 RO, using RO template.
assign DEVICE_COMMAND.VPS = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.PER x1 RW, using RW template.
logic [0:0] up_DEVICE_COMMAND_PER;
always_comb begin
 up_DEVICE_COMMAND_PER =
    ({1{write_req_DEVICE_COMMAND }} &
    be[0:0]);
end

logic [0:0] nxt_DEVICE_COMMAND_PER;
always_comb begin
 nxt_DEVICE_COMMAND_PER = write_data[6:6];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_COMMAND_PER[0], nxt_DEVICE_COMMAND_PER[0:0], DEVICE_COMMAND.PER[0:0])

// ----------------------------------------------------------------------
// DEVICE_COMMAND.RESERVED1 x1 RO, using RO template.
assign DEVICE_COMMAND.RESERVED1 = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.SER x1 RW, using RW template.
logic [0:0] up_DEVICE_COMMAND_SER;
always_comb begin
 up_DEVICE_COMMAND_SER =
    ({1{write_req_DEVICE_COMMAND }} &
    be[1:1]);
end

logic [0:0] nxt_DEVICE_COMMAND_SER;
always_comb begin
 nxt_DEVICE_COMMAND_SER = write_data[8:8];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_COMMAND_SER[0], nxt_DEVICE_COMMAND_SER[0:0], DEVICE_COMMAND.SER[0:0])

// ----------------------------------------------------------------------
// DEVICE_COMMAND.FBTB x1 RO, using RO template.
assign DEVICE_COMMAND.FBTB = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_COMMAND.INTD x1 RW, using RW template.
logic [0:0] up_DEVICE_COMMAND_INTD;
always_comb begin
 up_DEVICE_COMMAND_INTD =
    ({1{write_req_DEVICE_COMMAND }} &
    be[1:1]);
end

logic [0:0] nxt_DEVICE_COMMAND_INTD;
always_comb begin
 nxt_DEVICE_COMMAND_INTD = write_data[10:10];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_COMMAND_INTD[0], nxt_DEVICE_COMMAND_INTD[0:0], DEVICE_COMMAND.INTD[0:0])

// ----------------------------------------------------------------------
// DEVICE_COMMAND.RESERVED x5 RO, using RO template.
assign DEVICE_COMMAND.RESERVED = 5'h0;



//---------------------------------------------------------------------
// DEVICE_STATUS Address Decode
logic  addr_decode_DEVICE_STATUS;
logic  write_req_DEVICE_STATUS;
always_comb begin
   addr_decode_DEVICE_STATUS = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == DEVICE_STATUS_DECODE_ADDR) && req.valid ;
   write_req_DEVICE_STATUS = IsCFGWr && addr_decode_DEVICE_STATUS;
end

// ----------------------------------------------------------------------
// DEVICE_STATUS.RESERVED2 x3 RO, using RO template.
assign DEVICE_STATUS.RESERVED2 = 3'h0;


// ----------------------------------------------------------------------
// DEVICE_STATUS.INTSTS x1 RO/V, using RO/V template.
assign DEVICE_STATUS.INTSTS = new_DEVICE_STATUS.INTSTS;




// ----------------------------------------------------------------------
// DEVICE_STATUS.CL x1 RO, using RO template.
assign DEVICE_STATUS.CL = 1'h1;



// ----------------------------------------------------------------------
// DEVICE_STATUS.MC66 x1 RO, using RO template.
assign DEVICE_STATUS.MC66 = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_STATUS.RESERVED1 x1 RO, using RO template.
assign DEVICE_STATUS.RESERVED1 = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_STATUS.FB2B x1 RO, using RO template.
assign DEVICE_STATUS.FB2B = 1'h0;



// ----------------------------------------------------------------------
// DEVICE_STATUS.MDPE x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_MDPE;
always_comb begin
 req_up_DEVICE_STATUS_MDPE[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_MDPE;
always_comb begin
 clr_DEVICE_STATUS_MDPE = write_data[24:24] & req_up_DEVICE_STATUS_MDPE;

end
logic [0:0] swwr_DEVICE_STATUS_MDPE;
logic [0:0] sw_nxt_DEVICE_STATUS_MDPE;
always_comb begin
 swwr_DEVICE_STATUS_MDPE = clr_DEVICE_STATUS_MDPE;
 sw_nxt_DEVICE_STATUS_MDPE = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_MDPE;
logic [0:0] nxt_DEVICE_STATUS_MDPE;
always_comb begin
 up_DEVICE_STATUS_MDPE = 
   swwr_DEVICE_STATUS_MDPE | {1{load_DEVICE_STATUS.MDPE}};
end
always_comb begin
 nxt_DEVICE_STATUS_MDPE[0] = 
    load_DEVICE_STATUS.MDPE ?
    new_DEVICE_STATUS.MDPE[0] :
    sw_nxt_DEVICE_STATUS_MDPE[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_MDPE[0], nxt_DEVICE_STATUS_MDPE[0], DEVICE_STATUS.MDPE[0])

// ----------------------------------------------------------------------
// DEVICE_STATUS.DST x2 RO, using RO template.
assign DEVICE_STATUS.DST = 2'h0;



// ----------------------------------------------------------------------
// DEVICE_STATUS.STA x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_STA;
always_comb begin
 req_up_DEVICE_STATUS_STA[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_STA;
always_comb begin
 clr_DEVICE_STATUS_STA = write_data[27:27] & req_up_DEVICE_STATUS_STA;

end
logic [0:0] swwr_DEVICE_STATUS_STA;
logic [0:0] sw_nxt_DEVICE_STATUS_STA;
always_comb begin
 swwr_DEVICE_STATUS_STA = clr_DEVICE_STATUS_STA;
 sw_nxt_DEVICE_STATUS_STA = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_STA;
logic [0:0] nxt_DEVICE_STATUS_STA;
always_comb begin
 up_DEVICE_STATUS_STA = 
   swwr_DEVICE_STATUS_STA | {1{load_DEVICE_STATUS.STA}};
end
always_comb begin
 nxt_DEVICE_STATUS_STA[0] = 
    load_DEVICE_STATUS.STA ?
    new_DEVICE_STATUS.STA[0] :
    sw_nxt_DEVICE_STATUS_STA[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_STA[0], nxt_DEVICE_STATUS_STA[0], DEVICE_STATUS.STA[0])

// ----------------------------------------------------------------------
// DEVICE_STATUS.RTA x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_RTA;
always_comb begin
 req_up_DEVICE_STATUS_RTA[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_RTA;
always_comb begin
 clr_DEVICE_STATUS_RTA = write_data[28:28] & req_up_DEVICE_STATUS_RTA;

end
logic [0:0] swwr_DEVICE_STATUS_RTA;
logic [0:0] sw_nxt_DEVICE_STATUS_RTA;
always_comb begin
 swwr_DEVICE_STATUS_RTA = clr_DEVICE_STATUS_RTA;
 sw_nxt_DEVICE_STATUS_RTA = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_RTA;
logic [0:0] nxt_DEVICE_STATUS_RTA;
always_comb begin
 up_DEVICE_STATUS_RTA = 
   swwr_DEVICE_STATUS_RTA | {1{load_DEVICE_STATUS.RTA}};
end
always_comb begin
 nxt_DEVICE_STATUS_RTA[0] = 
    load_DEVICE_STATUS.RTA ?
    new_DEVICE_STATUS.RTA[0] :
    sw_nxt_DEVICE_STATUS_RTA[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_RTA[0], nxt_DEVICE_STATUS_RTA[0], DEVICE_STATUS.RTA[0])

// ----------------------------------------------------------------------
// DEVICE_STATUS.RMA x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_RMA;
always_comb begin
 req_up_DEVICE_STATUS_RMA[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_RMA;
always_comb begin
 clr_DEVICE_STATUS_RMA = write_data[29:29] & req_up_DEVICE_STATUS_RMA;

end
logic [0:0] swwr_DEVICE_STATUS_RMA;
logic [0:0] sw_nxt_DEVICE_STATUS_RMA;
always_comb begin
 swwr_DEVICE_STATUS_RMA = clr_DEVICE_STATUS_RMA;
 sw_nxt_DEVICE_STATUS_RMA = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_RMA;
logic [0:0] nxt_DEVICE_STATUS_RMA;
always_comb begin
 up_DEVICE_STATUS_RMA = 
   swwr_DEVICE_STATUS_RMA | {1{load_DEVICE_STATUS.RMA}};
end
always_comb begin
 nxt_DEVICE_STATUS_RMA[0] = 
    load_DEVICE_STATUS.RMA ?
    new_DEVICE_STATUS.RMA[0] :
    sw_nxt_DEVICE_STATUS_RMA[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_RMA[0], nxt_DEVICE_STATUS_RMA[0], DEVICE_STATUS.RMA[0])

// ----------------------------------------------------------------------
// DEVICE_STATUS.SSE x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_SSE;
always_comb begin
 req_up_DEVICE_STATUS_SSE[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_SSE;
always_comb begin
 clr_DEVICE_STATUS_SSE = write_data[30:30] & req_up_DEVICE_STATUS_SSE;

end
logic [0:0] swwr_DEVICE_STATUS_SSE;
logic [0:0] sw_nxt_DEVICE_STATUS_SSE;
always_comb begin
 swwr_DEVICE_STATUS_SSE = clr_DEVICE_STATUS_SSE;
 sw_nxt_DEVICE_STATUS_SSE = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_SSE;
logic [0:0] nxt_DEVICE_STATUS_SSE;
always_comb begin
 up_DEVICE_STATUS_SSE = 
   swwr_DEVICE_STATUS_SSE | {1{load_DEVICE_STATUS.SSE}};
end
always_comb begin
 nxt_DEVICE_STATUS_SSE[0] = 
    load_DEVICE_STATUS.SSE ?
    new_DEVICE_STATUS.SSE[0] :
    sw_nxt_DEVICE_STATUS_SSE[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_SSE[0], nxt_DEVICE_STATUS_SSE[0], DEVICE_STATUS.SSE[0])

// ----------------------------------------------------------------------
// DEVICE_STATUS.DPE x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_DEVICE_STATUS_DPE;
always_comb begin
 req_up_DEVICE_STATUS_DPE[0:0] = 
   {1{write_req_DEVICE_STATUS & be[3]}}
;
end

logic [0:0] clr_DEVICE_STATUS_DPE;
always_comb begin
 clr_DEVICE_STATUS_DPE = write_data[31:31] & req_up_DEVICE_STATUS_DPE;

end
logic [0:0] swwr_DEVICE_STATUS_DPE;
logic [0:0] sw_nxt_DEVICE_STATUS_DPE;
always_comb begin
 swwr_DEVICE_STATUS_DPE = clr_DEVICE_STATUS_DPE;
 sw_nxt_DEVICE_STATUS_DPE = {1{1'b0}};

end
logic [0:0] up_DEVICE_STATUS_DPE;
logic [0:0] nxt_DEVICE_STATUS_DPE;
always_comb begin
 up_DEVICE_STATUS_DPE = 
   swwr_DEVICE_STATUS_DPE | {1{load_DEVICE_STATUS.DPE}};
end
always_comb begin
 nxt_DEVICE_STATUS_DPE[0] = 
    load_DEVICE_STATUS.DPE ?
    new_DEVICE_STATUS.DPE[0] :
    sw_nxt_DEVICE_STATUS_DPE[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_DEVICE_STATUS_DPE[0], nxt_DEVICE_STATUS_DPE[0], DEVICE_STATUS.DPE[0])

//---------------------------------------------------------------------
// REVISION_ID_CLASS_CODE Address Decode
// ----------------------------------------------------------------------
// REVISION_ID_CLASS_CODE.RIDL x4 RO/V, using RO/V template.
assign REVISION_ID_CLASS_CODE.RIDL = new_REVISION_ID_CLASS_CODE.RIDL;



// ----------------------------------------------------------------------
// REVISION_ID_CLASS_CODE.RIDU x4 RO/V, using RO/V template.
assign REVISION_ID_CLASS_CODE.RIDU = new_REVISION_ID_CLASS_CODE.RIDU;




// ----------------------------------------------------------------------
// REVISION_ID_CLASS_CODE.CC x8 RO, using RO template.
assign REVISION_ID_CLASS_CODE.CC = 24'hB4000;



//---------------------------------------------------------------------
// CACHE_LINE_SIZE Address Decode
logic  addr_decode_CACHE_LINE_SIZE;
logic  write_req_CACHE_LINE_SIZE;
always_comb begin
   addr_decode_CACHE_LINE_SIZE = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == CACHE_LINE_SIZE_DECODE_ADDR) && req.valid ;
   write_req_CACHE_LINE_SIZE = IsCFGWr && addr_decode_CACHE_LINE_SIZE;
end

// ----------------------------------------------------------------------
// CACHE_LINE_SIZE.CLS x8 RW, using RW template.
logic [0:0] up_CACHE_LINE_SIZE_CLS;
always_comb begin
 up_CACHE_LINE_SIZE_CLS =
    ({1{write_req_CACHE_LINE_SIZE }} &
    be[0:0]);
end

logic [7:0] nxt_CACHE_LINE_SIZE_CLS;
always_comb begin
 nxt_CACHE_LINE_SIZE_CLS = write_data[7:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_CACHE_LINE_SIZE_CLS[0], nxt_CACHE_LINE_SIZE_CLS[7:0], CACHE_LINE_SIZE.CLS[7:0])

//---------------------------------------------------------------------
// HEADER_TYPE Address Decode

// ----------------------------------------------------------------------
// HEADER_TYPE.HDR x7 RO, using RO template.
assign HEADER_TYPE.HDR = 7'h0;


// ----------------------------------------------------------------------
// HEADER_TYPE.MFD x1 RO/V, using RO/V template.
assign HEADER_TYPE.MFD = new_HEADER_TYPE.MFD;




//---------------------------------------------------------------------
// FUNC_BAR_L Address Decode
logic  addr_decode_FUNC_BAR_L;
logic  write_req_FUNC_BAR_L;
always_comb begin
   addr_decode_FUNC_BAR_L = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == FUNC_BAR_L_DECODE_ADDR) && req.valid ;
   write_req_FUNC_BAR_L = IsCFGWr && addr_decode_FUNC_BAR_L;
end

// ----------------------------------------------------------------------
// FUNC_BAR_L.MEM x1 RO, using RO template.
assign FUNC_BAR_L.MEM = 1'h0;



// ----------------------------------------------------------------------
// FUNC_BAR_L.TYP x2 RO, using RO template.
assign FUNC_BAR_L.TYP = 2'h2;



// ----------------------------------------------------------------------
// FUNC_BAR_L.PREF x1 RO, using RO template.
assign FUNC_BAR_L.PREF = 1'h1;



// ----------------------------------------------------------------------
// FUNC_BAR_L.ZERO x2 RO, using RO template.
assign FUNC_BAR_L.ZERO = 22'h0;



// ----------------------------------------------------------------------
// FUNC_BAR_L.ADDR_L x6 RW, using RW template.
logic [0:0] up_FUNC_BAR_L_ADDR_L;
always_comb begin
 up_FUNC_BAR_L_ADDR_L =
    ({1{write_req_FUNC_BAR_L }} &
    be[3:3]);
end

logic [5:0] nxt_FUNC_BAR_L_ADDR_L;
always_comb begin
 nxt_FUNC_BAR_L_ADDR_L = write_data[31:26];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 6'h0, up_FUNC_BAR_L_ADDR_L[0], nxt_FUNC_BAR_L_ADDR_L[5:0], FUNC_BAR_L.ADDR_L[5:0])

//---------------------------------------------------------------------
// FUNC_BAR_U Address Decode
logic  addr_decode_FUNC_BAR_U;
logic  write_req_FUNC_BAR_U;
always_comb begin
   addr_decode_FUNC_BAR_U = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == FUNC_BAR_U_DECODE_ADDR) && req.valid ;
   write_req_FUNC_BAR_U = IsCFGWr && addr_decode_FUNC_BAR_U;
end

// ----------------------------------------------------------------------
// FUNC_BAR_U.ADDR x8 RW, using RW template.
logic [3:0] up_FUNC_BAR_U_ADDR;
always_comb begin
 up_FUNC_BAR_U_ADDR =
    ({4{write_req_FUNC_BAR_U }} &
    be[3:0]);
end

logic [31:0] nxt_FUNC_BAR_U_ADDR;
always_comb begin
 nxt_FUNC_BAR_U_ADDR = write_data[31:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_FUNC_BAR_U_ADDR[0], nxt_FUNC_BAR_U_ADDR[7:0], FUNC_BAR_U.ADDR[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_FUNC_BAR_U_ADDR[1], nxt_FUNC_BAR_U_ADDR[15:8], FUNC_BAR_U.ADDR[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_FUNC_BAR_U_ADDR[2], nxt_FUNC_BAR_U_ADDR[23:16], FUNC_BAR_U.ADDR[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_FUNC_BAR_U_ADDR[3], nxt_FUNC_BAR_U_ADDR[31:24], FUNC_BAR_U.ADDR[31:24])

//---------------------------------------------------------------------
// CSR_BAR_L Address Decode

// ----------------------------------------------------------------------
// CSR_BAR_L.MEM x1 RO, using RO template.
assign CSR_BAR_L.MEM = 1'h0;



// ----------------------------------------------------------------------
// CSR_BAR_L.TYP x2 RO, using RO template.
assign CSR_BAR_L.TYP = 2'h2;



// ----------------------------------------------------------------------
// CSR_BAR_L.PREF x1 RO, using RO template.
assign CSR_BAR_L.PREF = 1'h1;



// ----------------------------------------------------------------------
// CSR_BAR_L.ZERO x8 RO, using RO template.
assign CSR_BAR_L.ZERO = 28'h0;



//---------------------------------------------------------------------
// CSR_BAR_U Address Decode
logic  addr_decode_CSR_BAR_U;
logic  write_req_CSR_BAR_U;
always_comb begin
   addr_decode_CSR_BAR_U = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == CSR_BAR_U_DECODE_ADDR) && req.valid ;
   write_req_CSR_BAR_U = IsCFGWr && addr_decode_CSR_BAR_U;
end

// ----------------------------------------------------------------------
// CSR_BAR_U.ADDR x8 RW, using RW template.
logic [3:0] up_CSR_BAR_U_ADDR;
always_comb begin
 up_CSR_BAR_U_ADDR =
    ({4{write_req_CSR_BAR_U }} &
    be[3:0]);
end

logic [31:0] nxt_CSR_BAR_U_ADDR;
always_comb begin
 nxt_CSR_BAR_U_ADDR = write_data[31:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_CSR_BAR_U_ADDR[0], nxt_CSR_BAR_U_ADDR[7:0], CSR_BAR_U.ADDR[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_CSR_BAR_U_ADDR[1], nxt_CSR_BAR_U_ADDR[15:8], CSR_BAR_U.ADDR[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_CSR_BAR_U_ADDR[2], nxt_CSR_BAR_U_ADDR[23:16], CSR_BAR_U.ADDR[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_CSR_BAR_U_ADDR[3], nxt_CSR_BAR_U_ADDR[31:24], CSR_BAR_U.ADDR[31:24])

//---------------------------------------------------------------------
// SUBSYSTEM_VENDOR_ID Address Decode
logic  addr_decode_SUBSYSTEM_VENDOR_ID;
logic  write_req_SUBSYSTEM_VENDOR_ID;
always_comb begin
   addr_decode_SUBSYSTEM_VENDOR_ID = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == SUBSYSTEM_VENDOR_ID_DECODE_ADDR) && req.valid ;
   write_req_SUBSYSTEM_VENDOR_ID = IsCFGWr && addr_decode_SUBSYSTEM_VENDOR_ID;
end

// ----------------------------------------------------------------------
// SUBSYSTEM_VENDOR_ID.SVID x8 RW/O, using RW/O template.
logic [1:0] up_SUBSYSTEM_VENDOR_ID_SVID, 
    written_SUBSYSTEM_VENDOR_ID_SVID,
    written_nxt_SUBSYSTEM_VENDOR_ID_SVID;

always_comb written_nxt_SUBSYSTEM_VENDOR_ID_SVID =
    written_SUBSYSTEM_VENDOR_ID_SVID |
    up_SUBSYSTEM_VENDOR_ID_SVID;

`RTLGEN_HQM_PF_CFG_FF(gated_clk, hqm_csr_pf0_rst_n, '0, written_nxt_SUBSYSTEM_VENDOR_ID_SVID, written_SUBSYSTEM_VENDOR_ID_SVID)

always_comb up_SUBSYSTEM_VENDOR_ID_SVID = ~written_SUBSYSTEM_VENDOR_ID_SVID &
    ({2{write_req_SUBSYSTEM_VENDOR_ID }} &
    be[1:0]);

logic [15:0] nxt_SUBSYSTEM_VENDOR_ID_SVID;
always_comb begin
 nxt_SUBSYSTEM_VENDOR_ID_SVID = write_data[15:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h86, up_SUBSYSTEM_VENDOR_ID_SVID[0], nxt_SUBSYSTEM_VENDOR_ID_SVID[7:0], SUBSYSTEM_VENDOR_ID.SVID[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h80, up_SUBSYSTEM_VENDOR_ID_SVID[1], nxt_SUBSYSTEM_VENDOR_ID_SVID[15:8], SUBSYSTEM_VENDOR_ID.SVID[15:8])

//---------------------------------------------------------------------
// SUBSYSTEM_ID Address Decode

// ----------------------------------------------------------------------
// SUBSYSTEM_ID.SID x8 RO, using RO template.
assign SUBSYSTEM_ID.SID = 16'h0;



//---------------------------------------------------------------------
// CAP_PTR Address Decode

// ----------------------------------------------------------------------
// CAP_PTR.CP x8 RO, using RO template.
assign CAP_PTR.CP = 8'h60;



//---------------------------------------------------------------------
// INT_LINE Address Decode
logic  addr_decode_INT_LINE;
logic  write_req_INT_LINE;
always_comb begin
   addr_decode_INT_LINE = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == INT_LINE_DECODE_ADDR) && req.valid ;
   write_req_INT_LINE = IsCFGWr && addr_decode_INT_LINE;
end

// ----------------------------------------------------------------------
// INT_LINE.IRQL x8 RW, using RW template.
logic [0:0] up_INT_LINE_IRQL;
always_comb begin
 up_INT_LINE_IRQL =
    ({1{write_req_INT_LINE }} &
    be[0:0]);
end

logic [7:0] nxt_INT_LINE_IRQL;
always_comb begin
 nxt_INT_LINE_IRQL = write_data[7:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 8'h0, up_INT_LINE_IRQL[0], nxt_INT_LINE_IRQL[7:0], INT_LINE.IRQL[7:0])

//---------------------------------------------------------------------
// INT_PIN Address Decode

// ----------------------------------------------------------------------
// INT_PIN.IRQP x8 RO, using RO template.
assign INT_PIN.IRQP = 8'h0;



//---------------------------------------------------------------------
// MSIX_CAP_ID Address Decode

// ----------------------------------------------------------------------
// MSIX_CAP_ID.MSIX x8 RO, using RO template.
assign MSIX_CAP_ID.MSIX = 8'h11;



//---------------------------------------------------------------------
// MSIX_CAP_NEXT_CAP_PTR Address Decode

// ----------------------------------------------------------------------
// MSIX_CAP_NEXT_CAP_PTR.CAP_PTR x8 RO, using RO template.
assign MSIX_CAP_NEXT_CAP_PTR.CAP_PTR = 8'h6C;



//---------------------------------------------------------------------
// MSIX_CAP_CONTROL Address Decode
logic  addr_decode_MSIX_CAP_CONTROL;
logic  write_req_MSIX_CAP_CONTROL;
always_comb begin
   addr_decode_MSIX_CAP_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == MSIX_CAP_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_MSIX_CAP_CONTROL = IsCFGWr && addr_decode_MSIX_CAP_CONTROL;
end

// ----------------------------------------------------------------------
// MSIX_CAP_CONTROL.TS x3 RO, using RO template.
assign MSIX_CAP_CONTROL.TS = 11'h40;



// ----------------------------------------------------------------------
// MSIX_CAP_CONTROL.RESERVED x3 RO, using RO template.
assign MSIX_CAP_CONTROL.RESERVED = 3'h0;



// ----------------------------------------------------------------------
// MSIX_CAP_CONTROL.FM x1 RW, using RW template.
logic [0:0] up_MSIX_CAP_CONTROL_FM;
always_comb begin
 up_MSIX_CAP_CONTROL_FM =
    ({1{write_req_MSIX_CAP_CONTROL }} &
    be[3:3]);
end

logic [0:0] nxt_MSIX_CAP_CONTROL_FM;
always_comb begin
 nxt_MSIX_CAP_CONTROL_FM = write_data[30:30];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_MSIX_CAP_CONTROL_FM[0], nxt_MSIX_CAP_CONTROL_FM[0:0], MSIX_CAP_CONTROL.FM[0:0])

// ----------------------------------------------------------------------
// MSIX_CAP_CONTROL.MSIXEN x1 RW, using RW template.
logic [0:0] up_MSIX_CAP_CONTROL_MSIXEN;
always_comb begin
 up_MSIX_CAP_CONTROL_MSIXEN =
    ({1{write_req_MSIX_CAP_CONTROL }} &
    be[3:3]);
end

logic [0:0] nxt_MSIX_CAP_CONTROL_MSIXEN;
always_comb begin
 nxt_MSIX_CAP_CONTROL_MSIXEN = write_data[31:31];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_MSIX_CAP_CONTROL_MSIXEN[0], nxt_MSIX_CAP_CONTROL_MSIXEN[0:0], MSIX_CAP_CONTROL.MSIXEN[0:0])

//---------------------------------------------------------------------
// MSIX_CAP_TABLE_OFFSET_BIR Address Decode

// ----------------------------------------------------------------------
// MSIX_CAP_TABLE_OFFSET_BIR.TBIR x3 RO, using RO template.
assign MSIX_CAP_TABLE_OFFSET_BIR.TBIR = 3'h0;



// ----------------------------------------------------------------------
// MSIX_CAP_TABLE_OFFSET_BIR.TO x8 RO, using RO template.
assign MSIX_CAP_TABLE_OFFSET_BIR.TO = 29'h200000;



//---------------------------------------------------------------------
// MSIX_CAP_PBA_OFFSET_BIR Address Decode

// ----------------------------------------------------------------------
// MSIX_CAP_PBA_OFFSET_BIR.PBABIR x3 RO, using RO template.
assign MSIX_CAP_PBA_OFFSET_BIR.PBABIR = 3'h0;



// ----------------------------------------------------------------------
// MSIX_CAP_PBA_OFFSET_BIR.PBAO x8 RO, using RO template.
assign MSIX_CAP_PBA_OFFSET_BIR.PBAO = 29'h200200;



//---------------------------------------------------------------------
// PCIE_CAP_ID Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP_ID.PCIECID x8 RO, using RO template.
assign PCIE_CAP_ID.PCIECID = 8'h10;



//---------------------------------------------------------------------
// PCIE_CAP_NEXT_CAP_PTR Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP_NEXT_CAP_PTR.CAP_PTR x8 RO, using RO template.
assign PCIE_CAP_NEXT_CAP_PTR.CAP_PTR = 8'hB0;



//---------------------------------------------------------------------
// PCIE_CAP Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP.CV x4 RO, using RO template.
assign PCIE_CAP.CV = 4'h2;


// ----------------------------------------------------------------------
// PCIE_CAP.DPT x4 RO/V, using RO/V template.
assign PCIE_CAP.DPT = new_PCIE_CAP.DPT;




// ----------------------------------------------------------------------
// PCIE_CAP.SI x1 RO, using RO template.
assign PCIE_CAP.SI = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP.IMN x5 RO, using RO template.
assign PCIE_CAP.IMN = 5'h0;



// ----------------------------------------------------------------------
// PCIE_CAP.RESERVED x2 RO, using RO template.
assign PCIE_CAP.RESERVED = 2'h0;



//---------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.MPS x3 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.MPS = 3'h2;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.PFS x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.PFS = 2'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.ETFS x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.ETFS = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.EL0L x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.EL0L = 3'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.EL1L x3 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.EL1L = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.ATTN x3 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.ATTN = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.RBEP x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.RBEP = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.RESERVED1 x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.RESERVED1 = 2'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.CSPV x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.CSPV = 8'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.CSPS x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.CSPS = 2'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.FLR x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.FLR = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP.RESERVED0 x3 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP.RESERVED0 = 3'h0;



//---------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL Address Decode
logic  addr_decode_PCIE_CAP_DEVICE_CONTROL;
logic  write_req_PCIE_CAP_DEVICE_CONTROL;
always_comb begin
   addr_decode_PCIE_CAP_DEVICE_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_PCIE_CAP_DEVICE_CONTROL = IsCFGWr && addr_decode_PCIE_CAP_DEVICE_CONTROL;
end

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.CERE x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_CERE;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_CERE =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_CERE;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_CERE = write_data[0:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_CERE[0], nxt_PCIE_CAP_DEVICE_CONTROL_CERE[0:0], PCIE_CAP_DEVICE_CONTROL.CERE[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.NERE x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_NERE;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_NERE =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_NERE;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_NERE = write_data[1:1];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_NERE[0], nxt_PCIE_CAP_DEVICE_CONTROL_NERE[0:0], PCIE_CAP_DEVICE_CONTROL.NERE[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.FERE x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_FERE;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_FERE =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_FERE;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_FERE = write_data[2:2];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_FERE[0], nxt_PCIE_CAP_DEVICE_CONTROL_FERE[0:0], PCIE_CAP_DEVICE_CONTROL.FERE[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.URRO x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_URRO;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_URRO =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_URRO;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_URRO = write_data[3:3];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_URRO[0], nxt_PCIE_CAP_DEVICE_CONTROL_URRO[0:0], PCIE_CAP_DEVICE_CONTROL.URRO[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.ERO x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_ERO;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_ERO =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_ERO;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_ERO = write_data[4:4];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h1, up_PCIE_CAP_DEVICE_CONTROL_ERO[0], nxt_PCIE_CAP_DEVICE_CONTROL_ERO[0:0], PCIE_CAP_DEVICE_CONTROL.ERO[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.MPS x3 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_MPS;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_MPS =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[0:0]);
end

logic [2:0] nxt_PCIE_CAP_DEVICE_CONTROL_MPS;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_MPS = write_data[7:5];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, prim_gated_rst_b, 3'h0, up_PCIE_CAP_DEVICE_CONTROL_MPS[0], nxt_PCIE_CAP_DEVICE_CONTROL_MPS[2:0], PCIE_CAP_DEVICE_CONTROL.MPS[2:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.ETFE x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_ETFE;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_ETFE =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[1:1]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_ETFE;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_ETFE = write_data[8:8];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h1, up_PCIE_CAP_DEVICE_CONTROL_ETFE[0], nxt_PCIE_CAP_DEVICE_CONTROL_ETFE[0:0], PCIE_CAP_DEVICE_CONTROL.ETFE[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.PFE x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CONTROL.PFE = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.APME x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CONTROL.APME = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.ENS x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_ENS;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_ENS =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[1:1]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_ENS;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_ENS = write_data[11:11];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h1, up_PCIE_CAP_DEVICE_CONTROL_ENS[0], nxt_PCIE_CAP_DEVICE_CONTROL_ENS[0:0], PCIE_CAP_DEVICE_CONTROL.ENS[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.MRS x3 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_MRS;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_MRS =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[1:1]);
end

logic [2:0] nxt_PCIE_CAP_DEVICE_CONTROL_MRS;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_MRS = write_data[14:12];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 3'h2, up_PCIE_CAP_DEVICE_CONTROL_MRS[0], nxt_PCIE_CAP_DEVICE_CONTROL_MRS[2:0], PCIE_CAP_DEVICE_CONTROL.MRS[2:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL.STARTFLR x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_STARTFLR;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_STARTFLR =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL }} &
    be[1:1]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_STARTFLR;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_STARTFLR = write_data[15:15];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_STARTFLR[0], nxt_PCIE_CAP_DEVICE_CONTROL_STARTFLR[0:0], PCIE_CAP_DEVICE_CONTROL.STARTFLR[0:0])

//---------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS Address Decode
logic  addr_decode_PCIE_CAP_DEVICE_STATUS;
logic  write_req_PCIE_CAP_DEVICE_STATUS;
always_comb begin
   addr_decode_PCIE_CAP_DEVICE_STATUS = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PCIE_CAP_DEVICE_STATUS_DECODE_ADDR) && req.valid ;
   write_req_PCIE_CAP_DEVICE_STATUS = IsCFGWr && addr_decode_PCIE_CAP_DEVICE_STATUS;
end

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.CED x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_PCIE_CAP_DEVICE_STATUS_CED;
always_comb begin
 req_up_PCIE_CAP_DEVICE_STATUS_CED[0:0] = 
   {1{write_req_PCIE_CAP_DEVICE_STATUS & be[2]}}
;
end

logic [0:0] clr_PCIE_CAP_DEVICE_STATUS_CED;
always_comb begin
 clr_PCIE_CAP_DEVICE_STATUS_CED = write_data[16:16] & req_up_PCIE_CAP_DEVICE_STATUS_CED;

end
logic [0:0] swwr_PCIE_CAP_DEVICE_STATUS_CED;
logic [0:0] sw_nxt_PCIE_CAP_DEVICE_STATUS_CED;
always_comb begin
 swwr_PCIE_CAP_DEVICE_STATUS_CED = clr_PCIE_CAP_DEVICE_STATUS_CED;
 sw_nxt_PCIE_CAP_DEVICE_STATUS_CED = {1{1'b0}};

end
logic [0:0] up_PCIE_CAP_DEVICE_STATUS_CED;
logic [0:0] nxt_PCIE_CAP_DEVICE_STATUS_CED;
always_comb begin
 up_PCIE_CAP_DEVICE_STATUS_CED = 
   swwr_PCIE_CAP_DEVICE_STATUS_CED | {1{load_PCIE_CAP_DEVICE_STATUS.CED}};
end
always_comb begin
 nxt_PCIE_CAP_DEVICE_STATUS_CED[0] = 
    load_PCIE_CAP_DEVICE_STATUS.CED ?
    new_PCIE_CAP_DEVICE_STATUS.CED[0] :
    sw_nxt_PCIE_CAP_DEVICE_STATUS_CED[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_STATUS_CED[0], nxt_PCIE_CAP_DEVICE_STATUS_CED[0], PCIE_CAP_DEVICE_STATUS.CED[0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.NED x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_PCIE_CAP_DEVICE_STATUS_NED;
always_comb begin
 req_up_PCIE_CAP_DEVICE_STATUS_NED[0:0] = 
   {1{write_req_PCIE_CAP_DEVICE_STATUS & be[2]}}
;
end

logic [0:0] clr_PCIE_CAP_DEVICE_STATUS_NED;
always_comb begin
 clr_PCIE_CAP_DEVICE_STATUS_NED = write_data[17:17] & req_up_PCIE_CAP_DEVICE_STATUS_NED;

end
logic [0:0] swwr_PCIE_CAP_DEVICE_STATUS_NED;
logic [0:0] sw_nxt_PCIE_CAP_DEVICE_STATUS_NED;
always_comb begin
 swwr_PCIE_CAP_DEVICE_STATUS_NED = clr_PCIE_CAP_DEVICE_STATUS_NED;
 sw_nxt_PCIE_CAP_DEVICE_STATUS_NED = {1{1'b0}};

end
logic [0:0] up_PCIE_CAP_DEVICE_STATUS_NED;
logic [0:0] nxt_PCIE_CAP_DEVICE_STATUS_NED;
always_comb begin
 up_PCIE_CAP_DEVICE_STATUS_NED = 
   swwr_PCIE_CAP_DEVICE_STATUS_NED | {1{load_PCIE_CAP_DEVICE_STATUS.NED}};
end
always_comb begin
 nxt_PCIE_CAP_DEVICE_STATUS_NED[0] = 
    load_PCIE_CAP_DEVICE_STATUS.NED ?
    new_PCIE_CAP_DEVICE_STATUS.NED[0] :
    sw_nxt_PCIE_CAP_DEVICE_STATUS_NED[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_STATUS_NED[0], nxt_PCIE_CAP_DEVICE_STATUS_NED[0], PCIE_CAP_DEVICE_STATUS.NED[0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.FED x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_PCIE_CAP_DEVICE_STATUS_FED;
always_comb begin
 req_up_PCIE_CAP_DEVICE_STATUS_FED[0:0] = 
   {1{write_req_PCIE_CAP_DEVICE_STATUS & be[2]}}
;
end

logic [0:0] clr_PCIE_CAP_DEVICE_STATUS_FED;
always_comb begin
 clr_PCIE_CAP_DEVICE_STATUS_FED = write_data[18:18] & req_up_PCIE_CAP_DEVICE_STATUS_FED;

end
logic [0:0] swwr_PCIE_CAP_DEVICE_STATUS_FED;
logic [0:0] sw_nxt_PCIE_CAP_DEVICE_STATUS_FED;
always_comb begin
 swwr_PCIE_CAP_DEVICE_STATUS_FED = clr_PCIE_CAP_DEVICE_STATUS_FED;
 sw_nxt_PCIE_CAP_DEVICE_STATUS_FED = {1{1'b0}};

end
logic [0:0] up_PCIE_CAP_DEVICE_STATUS_FED;
logic [0:0] nxt_PCIE_CAP_DEVICE_STATUS_FED;
always_comb begin
 up_PCIE_CAP_DEVICE_STATUS_FED = 
   swwr_PCIE_CAP_DEVICE_STATUS_FED | {1{load_PCIE_CAP_DEVICE_STATUS.FED}};
end
always_comb begin
 nxt_PCIE_CAP_DEVICE_STATUS_FED[0] = 
    load_PCIE_CAP_DEVICE_STATUS.FED ?
    new_PCIE_CAP_DEVICE_STATUS.FED[0] :
    sw_nxt_PCIE_CAP_DEVICE_STATUS_FED[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_STATUS_FED[0], nxt_PCIE_CAP_DEVICE_STATUS_FED[0], PCIE_CAP_DEVICE_STATUS.FED[0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.URD x1 RW/1C/V, using RW/1C/V template.
// clear the each bit when writing a 1
logic [0:0] req_up_PCIE_CAP_DEVICE_STATUS_URD;
always_comb begin
 req_up_PCIE_CAP_DEVICE_STATUS_URD[0:0] = 
   {1{write_req_PCIE_CAP_DEVICE_STATUS & be[2]}}
;
end

logic [0:0] clr_PCIE_CAP_DEVICE_STATUS_URD;
always_comb begin
 clr_PCIE_CAP_DEVICE_STATUS_URD = write_data[19:19] & req_up_PCIE_CAP_DEVICE_STATUS_URD;

end
logic [0:0] swwr_PCIE_CAP_DEVICE_STATUS_URD;
logic [0:0] sw_nxt_PCIE_CAP_DEVICE_STATUS_URD;
always_comb begin
 swwr_PCIE_CAP_DEVICE_STATUS_URD = clr_PCIE_CAP_DEVICE_STATUS_URD;
 sw_nxt_PCIE_CAP_DEVICE_STATUS_URD = {1{1'b0}};

end
logic [0:0] up_PCIE_CAP_DEVICE_STATUS_URD;
logic [0:0] nxt_PCIE_CAP_DEVICE_STATUS_URD;
always_comb begin
 up_PCIE_CAP_DEVICE_STATUS_URD = 
   swwr_PCIE_CAP_DEVICE_STATUS_URD | {1{load_PCIE_CAP_DEVICE_STATUS.URD}};
end
always_comb begin
 nxt_PCIE_CAP_DEVICE_STATUS_URD[0] = 
    load_PCIE_CAP_DEVICE_STATUS.URD ?
    new_PCIE_CAP_DEVICE_STATUS.URD[0] :
    sw_nxt_PCIE_CAP_DEVICE_STATUS_URD[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_STATUS_URD[0], nxt_PCIE_CAP_DEVICE_STATUS_URD[0], PCIE_CAP_DEVICE_STATUS.URD[0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.APD x1 RO, using RO template.
assign PCIE_CAP_DEVICE_STATUS.APD = 1'h0;


// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.TP x1 RO/V, using RO/V template.
assign PCIE_CAP_DEVICE_STATUS.TP = new_PCIE_CAP_DEVICE_STATUS.TP;




// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_STATUS.RESERVED x8 RO, using RO template.
assign PCIE_CAP_DEVICE_STATUS.RESERVED = 10'h0;



//---------------------------------------------------------------------
// PCIE_CAP_LINK_CAP Address Decode
logic  addr_decode_PCIE_CAP_LINK_CAP;
logic  write_req_PCIE_CAP_LINK_CAP;
always_comb begin
   addr_decode_PCIE_CAP_LINK_CAP = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PCIE_CAP_LINK_CAP_DECODE_ADDR) && req.valid ;
   write_req_PCIE_CAP_LINK_CAP = IsCFGWr && addr_decode_PCIE_CAP_LINK_CAP;
end

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.MAXSPEED x4 RO, using RO template.
assign PCIE_CAP_LINK_CAP.MAXSPEED = 4'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.LINKW x2 RO, using RO template.
assign PCIE_CAP_LINK_CAP.LINKW = 6'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.ASLPM x2 RO, using RO template.
assign PCIE_CAP_LINK_CAP.ASLPM = 2'h3;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.L0EL x3 RO, using RO template.
assign PCIE_CAP_LINK_CAP.L0EL = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.L1EL x2 RO, using RO template.
assign PCIE_CAP_LINK_CAP.L1EL = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.NA_IOSF x3 RO, using RO template.
assign PCIE_CAP_LINK_CAP.NA_IOSF = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.LBN x1 RO, using RO template.
assign PCIE_CAP_LINK_CAP.LBN = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.ASPM x1 RO, using RO template.
assign PCIE_CAP_LINK_CAP.ASPM = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.RESERVED x1 RO, using RO template.
assign PCIE_CAP_LINK_CAP.RESERVED = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CAP.PORTNUM x8 RW/O/P, using RW/O/P template.
logic [0:0] up_PCIE_CAP_LINK_CAP_PORTNUM,
    written_PCIE_CAP_LINK_CAP_PORTNUM,
    written_nxt_PCIE_CAP_LINK_CAP_PORTNUM;

always_comb written_nxt_PCIE_CAP_LINK_CAP_PORTNUM = written_PCIE_CAP_LINK_CAP_PORTNUM | up_PCIE_CAP_LINK_CAP_PORTNUM;
`RTLGEN_HQM_PF_CFG_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, '0, written_nxt_PCIE_CAP_LINK_CAP_PORTNUM, written_PCIE_CAP_LINK_CAP_PORTNUM)

always_comb up_PCIE_CAP_LINK_CAP_PORTNUM = ~written_PCIE_CAP_LINK_CAP_PORTNUM &
    {1{write_req_PCIE_CAP_LINK_CAP}} &
    be[3:3];

logic [7:0] nxt_PCIE_CAP_LINK_CAP_PORTNUM;
always_comb begin
 nxt_PCIE_CAP_LINK_CAP_PORTNUM = write_data[31:24];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_PCIE_CAP_LINK_CAP_PORTNUM[0], nxt_PCIE_CAP_LINK_CAP_PORTNUM[7:0], PCIE_CAP_LINK_CAP.PORTNUM[7:0])

//---------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL Address Decode
logic  addr_decode_PCIE_CAP_LINK_CONTROL;
logic  write_req_PCIE_CAP_LINK_CONTROL;
always_comb begin
   addr_decode_PCIE_CAP_LINK_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PCIE_CAP_LINK_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_PCIE_CAP_LINK_CONTROL = IsCFGWr && addr_decode_PCIE_CAP_LINK_CONTROL;
end

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.ASPMC x2 RW, using RW template.
logic [0:0] up_PCIE_CAP_LINK_CONTROL_ASPMC;
always_comb begin
 up_PCIE_CAP_LINK_CONTROL_ASPMC =
    ({1{write_req_PCIE_CAP_LINK_CONTROL }} &
    be[0:0]);
end

logic [1:0] nxt_PCIE_CAP_LINK_CONTROL_ASPMC;
always_comb begin
 nxt_PCIE_CAP_LINK_CONTROL_ASPMC = write_data[1:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, prim_gated_rst_b, 2'h0, up_PCIE_CAP_LINK_CONTROL_ASPMC[0], nxt_PCIE_CAP_LINK_CONTROL_ASPMC[1:0], PCIE_CAP_LINK_CONTROL.ASPMC[1:0])

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.RESERVED2 x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.RESERVED2 = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.RCB x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_LINK_CONTROL_RCB;
always_comb begin
 up_PCIE_CAP_LINK_CONTROL_RCB =
    ({1{write_req_PCIE_CAP_LINK_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_LINK_CONTROL_RCB;
always_comb begin
 nxt_PCIE_CAP_LINK_CONTROL_RCB = write_data[3:3];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, prim_gated_rst_b, 1'h0, up_PCIE_CAP_LINK_CONTROL_RCB[0], nxt_PCIE_CAP_LINK_CONTROL_RCB[0:0], PCIE_CAP_LINK_CONTROL.RCB[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.LINKDIS x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.LINKDIS = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.RETRAIN x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.RETRAIN = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.CCLKCFG x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_LINK_CONTROL_CCLKCFG;
always_comb begin
 up_PCIE_CAP_LINK_CONTROL_CCLKCFG =
    ({1{write_req_PCIE_CAP_LINK_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_LINK_CONTROL_CCLKCFG;
always_comb begin
 nxt_PCIE_CAP_LINK_CONTROL_CCLKCFG = write_data[6:6];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, prim_gated_rst_b, 1'h0, up_PCIE_CAP_LINK_CONTROL_CCLKCFG[0], nxt_PCIE_CAP_LINK_CONTROL_CCLKCFG[0:0], PCIE_CAP_LINK_CONTROL.CCLKCFG[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.EXTSYNC x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_LINK_CONTROL_EXTSYNC;
always_comb begin
 up_PCIE_CAP_LINK_CONTROL_EXTSYNC =
    ({1{write_req_PCIE_CAP_LINK_CONTROL }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_LINK_CONTROL_EXTSYNC;
always_comb begin
 nxt_PCIE_CAP_LINK_CONTROL_EXTSYNC = write_data[7:7];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, prim_gated_rst_b, 1'h0, up_PCIE_CAP_LINK_CONTROL_EXTSYNC[0], nxt_PCIE_CAP_LINK_CONTROL_EXTSYNC[0:0], PCIE_CAP_LINK_CONTROL.EXTSYNC[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.ECLKPM x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.ECLKPM = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.WD x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.WD = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.LBWMINTE x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.LBWMINTE = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.LBWINTE x1 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.LBWINTE = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_CONTROL.RESERVED x4 RO, using RO template.
assign PCIE_CAP_LINK_CONTROL.RESERVED = 4'h0;



//---------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.NLS x4 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.NLS = 4'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.NLW x2 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.NLW = 6'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.LTE x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.LTE = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.LTINPROG x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.LTINPROG = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.SCLKCFG x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.SCLKCFG = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.DLACT x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.DLACT = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.LBWMS x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.LBWMS = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_LINK_STATUS.RESERVED x1 RO, using RO template.
assign PCIE_CAP_LINK_STATUS.RESERVED = 1'h0;



//---------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2 Address Decode

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.CTORS x4 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.CTORS = 4'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.CTODS x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.CTODS = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.RESERVED x8 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.RESERVED = 11'h0;


// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.CMP10BTAGS x1 RO/V, using RO/V template.
assign PCIE_CAP_DEVICE_CAP_2.CMP10BTAGS = new_PCIE_CAP_DEVICE_CAP_2.CMP10BTAGS;




// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.REQ10BTAGS x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.REQ10BTAGS = 1'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.RESERVED2 x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.RESERVED2 = 2'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.EFFS x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.EFFS = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.E2ETLPPS x1 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.E2ETLPPS = 1'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.MAXE2ETLPP x2 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.MAXE2ETLPP = 2'h1;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CAP_2.RESERVED3 x8 RO, using RO template.
assign PCIE_CAP_DEVICE_CAP_2.RESERVED3 = 8'h0;



//---------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2 Address Decode
logic  addr_decode_PCIE_CAP_DEVICE_CONTROL_2;
logic  write_req_PCIE_CAP_DEVICE_CONTROL_2;
always_comb begin
   addr_decode_PCIE_CAP_DEVICE_CONTROL_2 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR) && req.valid ;
   write_req_PCIE_CAP_DEVICE_CONTROL_2 = IsCFGWr && addr_decode_PCIE_CAP_DEVICE_CONTROL_2;
end

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2.CTOV x4 RO, using RO template.
assign PCIE_CAP_DEVICE_CONTROL_2.CTOV = 4'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2.CTODIS x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_2_CTODIS;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_2_CTODIS =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL_2 }} &
    be[0:0]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_2_CTODIS;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_2_CTODIS = write_data[4:4];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_2_CTODIS[0], nxt_PCIE_CAP_DEVICE_CONTROL_2_CTODIS[0:0], PCIE_CAP_DEVICE_CONTROL_2.CTODIS[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2.RESERVED0 x3 RO, using RO template.
assign PCIE_CAP_DEVICE_CONTROL_2.RESERVED0 = 3'h0;



// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2.EIDO x1 RW, using RW template.
logic [0:0] up_PCIE_CAP_DEVICE_CONTROL_2_EIDO;
always_comb begin
 up_PCIE_CAP_DEVICE_CONTROL_2_EIDO =
    ({1{write_req_PCIE_CAP_DEVICE_CONTROL_2 }} &
    be[1:1]);
end

logic [0:0] nxt_PCIE_CAP_DEVICE_CONTROL_2_EIDO;
always_comb begin
 nxt_PCIE_CAP_DEVICE_CONTROL_2_EIDO = write_data[8:8];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PCIE_CAP_DEVICE_CONTROL_2_EIDO[0], nxt_PCIE_CAP_DEVICE_CONTROL_2_EIDO[0:0], PCIE_CAP_DEVICE_CONTROL_2.EIDO[0:0])

// ----------------------------------------------------------------------
// PCIE_CAP_DEVICE_CONTROL_2.RESERVED1 x7 RO, using RO template.
assign PCIE_CAP_DEVICE_CONTROL_2.RESERVED1 = 7'h0;



//---------------------------------------------------------------------
// PM_CAP_ID Address Decode

// ----------------------------------------------------------------------
// PM_CAP_ID.PMID x8 RO, using RO template.
assign PM_CAP_ID.PMID = 8'h1;



//---------------------------------------------------------------------
// PM_CAP_NEXT_CAP_PTR Address Decode

// ----------------------------------------------------------------------
// PM_CAP_NEXT_CAP_PTR.CAP_PTR x8 RO, using RO template.
assign PM_CAP_NEXT_CAP_PTR.CAP_PTR = 8'h0;



//---------------------------------------------------------------------
// PM_CAP Address Decode

// ----------------------------------------------------------------------
// PM_CAP.PMV x3 RO, using RO template.
assign PM_CAP.PMV = 3'h3;



// ----------------------------------------------------------------------
// PM_CAP.PMC x1 RO, using RO template.
assign PM_CAP.PMC = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP.IROR2D0 x1 RO, using RO template.
assign PM_CAP.IROR2D0 = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP.DSI x1 RO, using RO template.
assign PM_CAP.DSI = 1'h1;



// ----------------------------------------------------------------------
// PM_CAP.AC x1 RO, using RO template.
assign PM_CAP.AC = 3'h0;



// ----------------------------------------------------------------------
// PM_CAP.D1 x1 RO, using RO template.
assign PM_CAP.D1 = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP.D2 x1 RO, using RO template.
assign PM_CAP.D2 = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP.PME x5 RO, using RO template.
assign PM_CAP.PME = 5'h0;



//---------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS Address Decode
logic  addr_decode_PM_CAP_CONTROL_STATUS;
logic  write_req_PM_CAP_CONTROL_STATUS;
always_comb begin
   addr_decode_PM_CAP_CONTROL_STATUS = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PM_CAP_CONTROL_STATUS_DECODE_ADDR) && req.valid ;
   write_req_PM_CAP_CONTROL_STATUS = IsCFGWr && addr_decode_PM_CAP_CONTROL_STATUS;
end

// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.PS x2 RW, using RW template.
logic [0:0] up_PM_CAP_CONTROL_STATUS_PS;
always_comb begin
 up_PM_CAP_CONTROL_STATUS_PS =
    ({1{write_req_PM_CAP_CONTROL_STATUS }} &
    be[0:0]);
end

logic [1:0] nxt_PM_CAP_CONTROL_STATUS_PS;
always_comb begin
 nxt_PM_CAP_CONTROL_STATUS_PS = write_data[1:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 2'h0, up_PM_CAP_CONTROL_STATUS_PS[0], nxt_PM_CAP_CONTROL_STATUS_PS[1:0], PM_CAP_CONTROL_STATUS.PS[1:0])

// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.RESERVED2 x1 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.RESERVED2 = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.NSR x1 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.NSR = 1'h1;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.RESERVED1 x4 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.RESERVED1 = 4'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.PME x1 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.PME = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.DSEL x4 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.DSEL = 4'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.DSC x2 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.DSC = 2'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.PMS x1 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.PMS = 1'h0;



// ----------------------------------------------------------------------
// PM_CAP_CONTROL_STATUS.RESERVED x8 RO, using RO template.
assign PM_CAP_CONTROL_STATUS.RESERVED = 16'h0;



//---------------------------------------------------------------------
// ACS_CAP_ID Address Decode

// ----------------------------------------------------------------------
// ACS_CAP_ID.ACSCID x8 RO, using RO template.
assign ACS_CAP_ID.ACSCID = 16'hD;



//---------------------------------------------------------------------
// ACS_CAP_VERSION_NEXT_PTR Address Decode

// ----------------------------------------------------------------------
// ACS_CAP_VERSION_NEXT_PTR.ACSCV x4 RO, using RO template.
assign ACS_CAP_VERSION_NEXT_PTR.ACSCV = 4'h1;



// ----------------------------------------------------------------------
// ACS_CAP_VERSION_NEXT_PTR.CAP_PTR x8 RO, using RO template.
assign ACS_CAP_VERSION_NEXT_PTR.CAP_PTR = 12'h148;



//---------------------------------------------------------------------
// ACS_CAP Address Decode

// ----------------------------------------------------------------------
// ACS_CAP.ACSSV x1 RO, using RO template.
assign ACS_CAP.ACSSV = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSTB x1 RO, using RO template.
assign ACS_CAP.ACSTB = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSP2PRR x1 RO, using RO template.
assign ACS_CAP.ACSP2PRR = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSP2PCR x1 RO, using RO template.
assign ACS_CAP.ACSP2PCR = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSUF x1 RO, using RO template.
assign ACS_CAP.ACSUF = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSP2PEC x1 RO, using RO template.
assign ACS_CAP.ACSP2PEC = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSDTP2P x1 RO, using RO template.
assign ACS_CAP.ACSDTP2P = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.RESERVED1 x1 RO, using RO template.
assign ACS_CAP.RESERVED1 = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP.ACSECVS x8 RO, using RO template.
assign ACS_CAP.ACSECVS = 8'h0;



//---------------------------------------------------------------------
// ACS_CAP_CONTROL Address Decode

// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSSVE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSSVE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSTBE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSTBE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSP2PRRE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSP2PRRE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSP2PCRE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSP2PCRE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSUFE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSUFE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSP2PECE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSP2PECE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.ACSDTP2PE x1 RO, using RO template.
assign ACS_CAP_CONTROL.ACSDTP2PE = 1'h0;



// ----------------------------------------------------------------------
// ACS_CAP_CONTROL.RESERVED x8 RO, using RO template.
assign ACS_CAP_CONTROL.RESERVED = 9'h0;



//---------------------------------------------------------------------
// PASID_CAP_ID Address Decode

// ----------------------------------------------------------------------
// PASID_CAP_ID.CAP_ID x8 RO, using RO template.
assign PASID_CAP_ID.CAP_ID = 16'h1B;



//---------------------------------------------------------------------
// PASID_CAP_VERSION_NEXT_PTR Address Decode

// ----------------------------------------------------------------------
// PASID_CAP_VERSION_NEXT_PTR.SRIOVCV x4 RO, using RO template.
assign PASID_CAP_VERSION_NEXT_PTR.SRIOVCV = 4'h1;



// ----------------------------------------------------------------------
// PASID_CAP_VERSION_NEXT_PTR.CAP_PTR x8 RO, using RO template.
assign PASID_CAP_VERSION_NEXT_PTR.CAP_PTR = 12'h150;



//---------------------------------------------------------------------
// PASID_CAP Address Decode

// ----------------------------------------------------------------------
// PASID_CAP.RESERVED0 x1 RO, using RO template.
assign PASID_CAP.RESERVED0 = 1'h0;



// ----------------------------------------------------------------------
// PASID_CAP.EXEC_PERM_SUPP x1 RO, using RO template.
assign PASID_CAP.EXEC_PERM_SUPP = 1'h0;



// ----------------------------------------------------------------------
// PASID_CAP.PRIV_MODE_SUPP x1 RO, using RO template.
assign PASID_CAP.PRIV_MODE_SUPP = 1'h0;



// ----------------------------------------------------------------------
// PASID_CAP.RESERVED1 x5 RO, using RO template.
assign PASID_CAP.RESERVED1 = 5'h0;



// ----------------------------------------------------------------------
// PASID_CAP.MAX_PASID_WIDTH x5 RO, using RO template.
assign PASID_CAP.MAX_PASID_WIDTH = 5'h14;



// ----------------------------------------------------------------------
// PASID_CAP.RESERVED2 x3 RO, using RO template.
assign PASID_CAP.RESERVED2 = 3'h0;



//---------------------------------------------------------------------
// PASID_CONTROL Address Decode
logic  addr_decode_PASID_CONTROL;
logic  write_req_PASID_CONTROL;
always_comb begin
   addr_decode_PASID_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == PASID_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_PASID_CONTROL = IsCFGWr && addr_decode_PASID_CONTROL;
end

// ----------------------------------------------------------------------
// PASID_CONTROL.PASID_ENABLE x1 RW, using RW template.
logic [0:0] up_PASID_CONTROL_PASID_ENABLE;
always_comb begin
 up_PASID_CONTROL_PASID_ENABLE =
    ({1{write_req_PASID_CONTROL }} &
    be[2:2]);
end

logic [0:0] nxt_PASID_CONTROL_PASID_ENABLE;
always_comb begin
 nxt_PASID_CONTROL_PASID_ENABLE = write_data[16:16];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_PASID_CONTROL_PASID_ENABLE[0], nxt_PASID_CONTROL_PASID_ENABLE[0:0], PASID_CONTROL.PASID_ENABLE[0:0])

// ----------------------------------------------------------------------
// PASID_CONTROL.EXEC_PERM_ENABLE x1 RO, using RO template.
assign PASID_CONTROL.EXEC_PERM_ENABLE = 1'h0;



// ----------------------------------------------------------------------
// PASID_CONTROL.PRIV_MODE_ENABLE x1 RO, using RO template.
assign PASID_CONTROL.PRIV_MODE_ENABLE = 1'h0;



// ----------------------------------------------------------------------
// PASID_CONTROL.RESERVED x8 RO, using RO template.
assign PASID_CONTROL.RESERVED = 13'h0;



//---------------------------------------------------------------------
// DVSEC_CAP_ID Address Decode

// ----------------------------------------------------------------------
// DVSEC_CAP_ID.CAP_ID x8 RO, using RO template.
assign DVSEC_CAP_ID.CAP_ID = 16'h23;



//---------------------------------------------------------------------
// DVSEC_CAP_VERSION_NEXT_PTR Address Decode

// ----------------------------------------------------------------------
// DVSEC_CAP_VERSION_NEXT_PTR.DVSECCV x4 RO, using RO template.
assign DVSEC_CAP_VERSION_NEXT_PTR.DVSECCV = 4'h1;



// ----------------------------------------------------------------------
// DVSEC_CAP_VERSION_NEXT_PTR.CAP_PTR x8 RO, using RO template.
assign DVSEC_CAP_VERSION_NEXT_PTR.CAP_PTR = 12'h168;



//---------------------------------------------------------------------
// DVSEC_HDR1 Address Decode

// ----------------------------------------------------------------------
// DVSEC_HDR1.DVSEC_VENDOR_ID x8 RO, using RO template.
assign DVSEC_HDR1.DVSEC_VENDOR_ID = 16'h8086;



// ----------------------------------------------------------------------
// DVSEC_HDR1.DVSEC_REVISION x4 RO, using RO template.
assign DVSEC_HDR1.DVSEC_REVISION = 4'h0;



// ----------------------------------------------------------------------
// DVSEC_HDR1.DVSEC_LENGTH x8 RO, using RO template.
assign DVSEC_HDR1.DVSEC_LENGTH = 12'h18;



//---------------------------------------------------------------------
// DVSEC_HDR2 Address Decode

// ----------------------------------------------------------------------
// DVSEC_HDR2.DVSEC_ID x8 RO, using RO template.
assign DVSEC_HDR2.DVSEC_ID = 16'h5;



//---------------------------------------------------------------------
// SCIOV_CAP Address Decode

// ----------------------------------------------------------------------
// SCIOV_CAP.RESERVED0 x8 RO, using RO template.
assign SCIOV_CAP.RESERVED0 = 8'h0;



// ----------------------------------------------------------------------
// SCIOV_CAP.AIS_DEPENDENT x1 RO, using RO template.
assign SCIOV_CAP.AIS_DEPENDENT = 1'h0;



// ----------------------------------------------------------------------
// SCIOV_CAP.HOMOGEN_FUNC x1 RO, using RO template.
assign SCIOV_CAP.HOMOGEN_FUNC = 1'h0;



// ----------------------------------------------------------------------
// SCIOV_CAP.RESERVED2 x6 RO, using RO template.
assign SCIOV_CAP.RESERVED2 = 6'h0;



//---------------------------------------------------------------------
// SCIOV_SUPP_PGSZ Address Decode

// ----------------------------------------------------------------------
// SCIOV_SUPP_PGSZ.SUPP_PGSZ x1 RO, using RO template.
assign SCIOV_SUPP_PGSZ.SUPP_PGSZ = 1'h1;



// ----------------------------------------------------------------------
// SCIOV_SUPP_PGSZ.RESERVED x8 RO, using RO template.
assign SCIOV_SUPP_PGSZ.RESERVED = 31'h0;



//---------------------------------------------------------------------
// SCIOV_SYS_PGSZ Address Decode
logic  addr_decode_SCIOV_SYS_PGSZ;
logic  write_req_SCIOV_SYS_PGSZ;
always_comb begin
   addr_decode_SCIOV_SYS_PGSZ = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == SCIOV_SYS_PGSZ_DECODE_ADDR) && req.valid ;
   write_req_SCIOV_SYS_PGSZ = IsCFGWr && addr_decode_SCIOV_SYS_PGSZ;
end

// ----------------------------------------------------------------------
// SCIOV_SYS_PGSZ.SYS_PGSZ x1 RW, using RW template.
logic [0:0] up_SCIOV_SYS_PGSZ_SYS_PGSZ;
always_comb begin
 up_SCIOV_SYS_PGSZ_SYS_PGSZ =
    ({1{write_req_SCIOV_SYS_PGSZ }} &
    be[0:0]);
end

logic [0:0] nxt_SCIOV_SYS_PGSZ_SYS_PGSZ;
always_comb begin
 nxt_SCIOV_SYS_PGSZ_SYS_PGSZ = write_data[0:0];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h1, up_SCIOV_SYS_PGSZ_SYS_PGSZ[0], nxt_SCIOV_SYS_PGSZ_SYS_PGSZ[0:0], SCIOV_SYS_PGSZ.SYS_PGSZ[0:0])

// ----------------------------------------------------------------------
// SCIOV_SYS_PGSZ.RESERVED x8 RO, using RO template.
assign SCIOV_SYS_PGSZ.RESERVED = 31'h0;



//---------------------------------------------------------------------
// SCIOV_IMS Address Decode

// ----------------------------------------------------------------------
// SCIOV_IMS.IMS_SUPP x1 RO, using RO template.
assign SCIOV_IMS.IMS_SUPP = 1'h1;



// ----------------------------------------------------------------------
// SCIOV_IMS.RESERVED x8 RO, using RO template.
assign SCIOV_IMS.RESERVED = 31'h0;



//---------------------------------------------------------------------
// AER_CAP_ID Address Decode

// ----------------------------------------------------------------------
// AER_CAP_ID.PCIEAERCID x8 RO, using RO template.
assign AER_CAP_ID.PCIEAERCID = 16'h1;



//---------------------------------------------------------------------
// AER_CAP_VERSION_NEXT_PTR Address Decode

// ----------------------------------------------------------------------
// AER_CAP_VERSION_NEXT_PTR.PCIEAERCVN x4 RO, using RO template.
assign AER_CAP_VERSION_NEXT_PTR.PCIEAERCVN = 4'h2;



// ----------------------------------------------------------------------
// AER_CAP_VERSION_NEXT_PTR.CAP_PTR x8 RO, using RO template.
assign AER_CAP_VERSION_NEXT_PTR.CAP_PTR = 12'h1B0;



//---------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS Address Decode
logic  addr_decode_AER_CAP_UNCORR_ERR_STATUS;
logic  write_req_AER_CAP_UNCORR_ERR_STATUS;
always_comb begin
   addr_decode_AER_CAP_UNCORR_ERR_STATUS = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_UNCORR_ERR_STATUS = IsCFGWr && addr_decode_AER_CAP_UNCORR_ERR_STATUS;
end

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.RESERVED2 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.RESERVED2 = 4'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.DLPE x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.DLPE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.SDES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.SDES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.RESERVED1 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.RESERVED1 = 6'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.PTLPR x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_PTLPR[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[1]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_PTLPR = write_data[12:12] & req_up_AER_CAP_UNCORR_ERR_STATUS_PTLPR;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_PTLPR = clr_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_PTLPR = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_PTLPR | {1{load_AER_CAP_UNCORR_ERR_STATUS.PTLPR}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.PTLPR ?
    new_AER_CAP_UNCORR_ERR_STATUS.PTLPR[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_PTLPR[0], nxt_AER_CAP_UNCORR_ERR_STATUS_PTLPR[0], AER_CAP_UNCORR_ERR_STATUS.PTLPR[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.FCPES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.FCPES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.CT x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_CT;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_CT[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[1]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_CT;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_CT = write_data[14:14] & req_up_AER_CAP_UNCORR_ERR_STATUS_CT;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_CT;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CT;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_CT = clr_AER_CAP_UNCORR_ERR_STATUS_CT;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CT = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_CT;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_CT;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_CT = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_CT | {1{load_AER_CAP_UNCORR_ERR_STATUS.CT}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_CT[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.CT ?
    new_AER_CAP_UNCORR_ERR_STATUS.CT[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CT[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_CT[0], nxt_AER_CAP_UNCORR_ERR_STATUS_CT[0], AER_CAP_UNCORR_ERR_STATUS.CT[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.CA x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_CA;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_CA[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[1]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_CA;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_CA = write_data[15:15] & req_up_AER_CAP_UNCORR_ERR_STATUS_CA;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_CA;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CA;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_CA = clr_AER_CAP_UNCORR_ERR_STATUS_CA;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CA = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_CA;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_CA;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_CA = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_CA | {1{load_AER_CAP_UNCORR_ERR_STATUS.CA}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_CA[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.CA ?
    new_AER_CAP_UNCORR_ERR_STATUS.CA[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_CA[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_CA[0], nxt_AER_CAP_UNCORR_ERR_STATUS_CA[0], AER_CAP_UNCORR_ERR_STATUS.CA[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.EC x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_EC;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_EC[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[2]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_EC;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_EC = write_data[16:16] & req_up_AER_CAP_UNCORR_ERR_STATUS_EC;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_EC;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_EC;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_EC = clr_AER_CAP_UNCORR_ERR_STATUS_EC;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_EC = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_EC;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_EC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_EC = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_EC | {1{load_AER_CAP_UNCORR_ERR_STATUS.EC}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_EC[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.EC ?
    new_AER_CAP_UNCORR_ERR_STATUS.EC[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_EC[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_EC[0], nxt_AER_CAP_UNCORR_ERR_STATUS_EC[0], AER_CAP_UNCORR_ERR_STATUS.EC[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.RO x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.RO = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.MTLP x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_MTLP;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_MTLP[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[2]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_MTLP;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_MTLP = write_data[18:18] & req_up_AER_CAP_UNCORR_ERR_STATUS_MTLP;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_MTLP;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_MTLP = clr_AER_CAP_UNCORR_ERR_STATUS_MTLP;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_MTLP;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_MTLP = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_MTLP | {1{load_AER_CAP_UNCORR_ERR_STATUS.MTLP}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.MTLP ?
    new_AER_CAP_UNCORR_ERR_STATUS.MTLP[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_MTLP[0], nxt_AER_CAP_UNCORR_ERR_STATUS_MTLP[0], AER_CAP_UNCORR_ERR_STATUS.MTLP[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.ECRCC x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_ECRCC[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[2]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_ECRCC = write_data[19:19] & req_up_AER_CAP_UNCORR_ERR_STATUS_ECRCC;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_ECRCC = clr_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_ECRCC = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_ECRCC | {1{load_AER_CAP_UNCORR_ERR_STATUS.ECRCC}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.ECRCC ?
    new_AER_CAP_UNCORR_ERR_STATUS.ECRCC[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_ECRCC[0], nxt_AER_CAP_UNCORR_ERR_STATUS_ECRCC[0], AER_CAP_UNCORR_ERR_STATUS.ECRCC[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.UR x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_UR;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_UR[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[2]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_UR;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_UR = write_data[20:20] & req_up_AER_CAP_UNCORR_ERR_STATUS_UR;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_UR;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_UR;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_UR = clr_AER_CAP_UNCORR_ERR_STATUS_UR;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_UR = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_UR;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_UR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_UR = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_UR | {1{load_AER_CAP_UNCORR_ERR_STATUS.UR}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_UR[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.UR ?
    new_AER_CAP_UNCORR_ERR_STATUS.UR[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_UR[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_UR[0], nxt_AER_CAP_UNCORR_ERR_STATUS_UR[0], AER_CAP_UNCORR_ERR_STATUS.UR[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.RESERVED3 x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.RESERVED3 = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.IEUNC x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
always_comb begin
 req_up_AER_CAP_UNCORR_ERR_STATUS_IEUNC[0:0] = 
   {1{write_req_AER_CAP_UNCORR_ERR_STATUS & be[2]}}
;
end

logic [0:0] clr_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
always_comb begin
 clr_AER_CAP_UNCORR_ERR_STATUS_IEUNC = write_data[22:22] & req_up_AER_CAP_UNCORR_ERR_STATUS_IEUNC;

end
logic [0:0] swwr_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
logic [0:0] sw_nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
always_comb begin
 swwr_AER_CAP_UNCORR_ERR_STATUS_IEUNC = clr_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
 sw_nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC = {1{1'b0}};

end
logic [0:0] up_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
logic [0:0] nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_STATUS_IEUNC = 
   swwr_AER_CAP_UNCORR_ERR_STATUS_IEUNC | {1{load_AER_CAP_UNCORR_ERR_STATUS.IEUNC}};
end
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC[0] = 
    load_AER_CAP_UNCORR_ERR_STATUS.IEUNC ?
    new_AER_CAP_UNCORR_ERR_STATUS.IEUNC[0] :
    sw_nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_STATUS_IEUNC[0], nxt_AER_CAP_UNCORR_ERR_STATUS_IEUNC[0], AER_CAP_UNCORR_ERR_STATUS.IEUNC[0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_STATUS.RESERVED0 x8 RO, using RO template.
assign AER_CAP_UNCORR_ERR_STATUS.RESERVED0 = 9'h0;



//---------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK Address Decode
logic  addr_decode_AER_CAP_UNCORR_ERR_MASK;
logic  write_req_AER_CAP_UNCORR_ERR_MASK;
always_comb begin
   addr_decode_AER_CAP_UNCORR_ERR_MASK = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_UNCORR_ERR_MASK = IsCFGWr && addr_decode_AER_CAP_UNCORR_ERR_MASK;
end

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.RESERVED2 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.RESERVED2 = 4'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.DLPE x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_DLPE;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_DLPE =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[0:0]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_DLPE;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_DLPE = write_data[4:4];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_DLPE[0], nxt_AER_CAP_UNCORR_ERR_MASK_DLPE[0:0], AER_CAP_UNCORR_ERR_MASK.DLPE[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.SDES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.SDES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.RESERVED1 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.RESERVED1 = 6'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.PTLPR x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_PTLPR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_PTLPR =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_PTLPR;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_PTLPR = write_data[12:12];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_PTLPR[0], nxt_AER_CAP_UNCORR_ERR_MASK_PTLPR[0:0], AER_CAP_UNCORR_ERR_MASK.PTLPR[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.FCPES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.FCPES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.CT x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_CT;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_CT =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_CT;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_CT = write_data[14:14];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_CT[0], nxt_AER_CAP_UNCORR_ERR_MASK_CT[0:0], AER_CAP_UNCORR_ERR_MASK.CT[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.CA x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_CA;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_CA =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_CA;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_CA = write_data[15:15];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_CA[0], nxt_AER_CAP_UNCORR_ERR_MASK_CA[0:0], AER_CAP_UNCORR_ERR_MASK.CA[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.EC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_EC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_EC =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_EC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_EC = write_data[16:16];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_EC[0], nxt_AER_CAP_UNCORR_ERR_MASK_EC[0:0], AER_CAP_UNCORR_ERR_MASK.EC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.RO x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.RO = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.MTLP x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_MTLP;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_MTLP =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_MTLP;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_MTLP = write_data[18:18];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_MTLP[0], nxt_AER_CAP_UNCORR_ERR_MASK_MTLP[0:0], AER_CAP_UNCORR_ERR_MASK.MTLP[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.ECRCC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_ECRCC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_ECRCC =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_ECRCC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_ECRCC = write_data[19:19];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_ECRCC[0], nxt_AER_CAP_UNCORR_ERR_MASK_ECRCC[0:0], AER_CAP_UNCORR_ERR_MASK.ECRCC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.UR x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_UR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_UR =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_UR;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_UR = write_data[20:20];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_MASK_UR[0], nxt_AER_CAP_UNCORR_ERR_MASK_UR[0:0], AER_CAP_UNCORR_ERR_MASK.UR[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.RESERVED3 x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.RESERVED3 = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.IEUNC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_MASK_IEUNC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_MASK_IEUNC =
    ({1{write_req_AER_CAP_UNCORR_ERR_MASK }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_MASK_IEUNC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_MASK_IEUNC = write_data[22:22];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h1, up_AER_CAP_UNCORR_ERR_MASK_IEUNC[0], nxt_AER_CAP_UNCORR_ERR_MASK_IEUNC[0:0], AER_CAP_UNCORR_ERR_MASK.IEUNC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_MASK.RESERVED0 x8 RO, using RO template.
assign AER_CAP_UNCORR_ERR_MASK.RESERVED0 = 9'h0;



//---------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV Address Decode
logic  addr_decode_AER_CAP_UNCORR_ERR_SEV;
logic  write_req_AER_CAP_UNCORR_ERR_SEV;
always_comb begin
   addr_decode_AER_CAP_UNCORR_ERR_SEV = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_UNCORR_ERR_SEV = IsCFGWr && addr_decode_AER_CAP_UNCORR_ERR_SEV;
end

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.RESERVED2 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.RESERVED2 = 4'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.DLPE x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_DLPE;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_DLPE =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[0:0]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_DLPE;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_DLPE = write_data[4:4];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_DLPE[0], nxt_AER_CAP_UNCORR_ERR_SEV_DLPE[0:0], AER_CAP_UNCORR_ERR_SEV.DLPE[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.SDES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.SDES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.RESERVED1 x4 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.RESERVED1 = 6'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.PTLPR x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_PTLPR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_PTLPR =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_PTLPR;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_PTLPR = write_data[12:12];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_PTLPR[0], nxt_AER_CAP_UNCORR_ERR_SEV_PTLPR[0:0], AER_CAP_UNCORR_ERR_SEV.PTLPR[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.FCPES x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.FCPES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.CT x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_CT;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_CT =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_CT;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_CT = write_data[14:14];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_CT[0], nxt_AER_CAP_UNCORR_ERR_SEV_CT[0:0], AER_CAP_UNCORR_ERR_SEV.CT[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.CA x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_CA;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_CA =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_CA;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_CA = write_data[15:15];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_CA[0], nxt_AER_CAP_UNCORR_ERR_SEV_CA[0:0], AER_CAP_UNCORR_ERR_SEV.CA[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.EC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_EC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_EC =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_EC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_EC = write_data[16:16];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_EC[0], nxt_AER_CAP_UNCORR_ERR_SEV_EC[0:0], AER_CAP_UNCORR_ERR_SEV.EC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.RO x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_RO;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_RO =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_RO;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_RO = write_data[17:17];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_RO[0], nxt_AER_CAP_UNCORR_ERR_SEV_RO[0:0], AER_CAP_UNCORR_ERR_SEV.RO[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.MTLP x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_MTLP;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_MTLP =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_MTLP;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_MTLP = write_data[18:18];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h1, up_AER_CAP_UNCORR_ERR_SEV_MTLP[0], nxt_AER_CAP_UNCORR_ERR_SEV_MTLP[0:0], AER_CAP_UNCORR_ERR_SEV.MTLP[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.ECRCC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_ECRCC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_ECRCC =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_ECRCC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_ECRCC = write_data[19:19];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_ECRCC[0], nxt_AER_CAP_UNCORR_ERR_SEV_ECRCC[0:0], AER_CAP_UNCORR_ERR_SEV.ECRCC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.UR x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_UR;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_UR =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_UR;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_UR = write_data[20:20];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_UNCORR_ERR_SEV_UR[0], nxt_AER_CAP_UNCORR_ERR_SEV_UR[0:0], AER_CAP_UNCORR_ERR_SEV.UR[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.RESERVED3 x1 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.RESERVED3 = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.IEUNC x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_UNCORR_ERR_SEV_IEUNC;
always_comb begin
 up_AER_CAP_UNCORR_ERR_SEV_IEUNC =
    ({1{write_req_AER_CAP_UNCORR_ERR_SEV }} &
    be[2:2]);
end

logic [0:0] nxt_AER_CAP_UNCORR_ERR_SEV_IEUNC;
always_comb begin
 nxt_AER_CAP_UNCORR_ERR_SEV_IEUNC = write_data[22:22];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h1, up_AER_CAP_UNCORR_ERR_SEV_IEUNC[0], nxt_AER_CAP_UNCORR_ERR_SEV_IEUNC[0:0], AER_CAP_UNCORR_ERR_SEV.IEUNC[0:0])

// ----------------------------------------------------------------------
// AER_CAP_UNCORR_ERR_SEV.RESERVED0 x8 RO, using RO template.
assign AER_CAP_UNCORR_ERR_SEV.RESERVED0 = 9'h0;



//---------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS Address Decode
logic  addr_decode_AER_CAP_CORR_ERR_STATUS;
logic  write_req_AER_CAP_CORR_ERR_STATUS;
always_comb begin
   addr_decode_AER_CAP_CORR_ERR_STATUS = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_CORR_ERR_STATUS_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_CORR_ERR_STATUS = IsCFGWr && addr_decode_AER_CAP_CORR_ERR_STATUS;
end

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RES x1 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RESERVED2 x5 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RESERVED2 = 5'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.DLPE x1 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.DLPE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.BDLLPS x1 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.BDLLPS = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RNRS x1 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RNRS = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RESERVED1 x3 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RESERVED1 = 3'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RTTS x1 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RTTS = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.ANFES x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_CORR_ERR_STATUS_ANFES;
always_comb begin
 req_up_AER_CAP_CORR_ERR_STATUS_ANFES[0:0] = 
   {1{write_req_AER_CAP_CORR_ERR_STATUS & be[1]}}
;
end

logic [0:0] clr_AER_CAP_CORR_ERR_STATUS_ANFES;
always_comb begin
 clr_AER_CAP_CORR_ERR_STATUS_ANFES = write_data[13:13] & req_up_AER_CAP_CORR_ERR_STATUS_ANFES;

end
logic [0:0] swwr_AER_CAP_CORR_ERR_STATUS_ANFES;
logic [0:0] sw_nxt_AER_CAP_CORR_ERR_STATUS_ANFES;
always_comb begin
 swwr_AER_CAP_CORR_ERR_STATUS_ANFES = clr_AER_CAP_CORR_ERR_STATUS_ANFES;
 sw_nxt_AER_CAP_CORR_ERR_STATUS_ANFES = {1{1'b0}};

end
logic [0:0] up_AER_CAP_CORR_ERR_STATUS_ANFES;
logic [0:0] nxt_AER_CAP_CORR_ERR_STATUS_ANFES;
always_comb begin
 up_AER_CAP_CORR_ERR_STATUS_ANFES = 
   swwr_AER_CAP_CORR_ERR_STATUS_ANFES | {1{load_AER_CAP_CORR_ERR_STATUS.ANFES}};
end
always_comb begin
 nxt_AER_CAP_CORR_ERR_STATUS_ANFES[0] = 
    load_AER_CAP_CORR_ERR_STATUS.ANFES ?
    new_AER_CAP_CORR_ERR_STATUS.ANFES[0] :
    sw_nxt_AER_CAP_CORR_ERR_STATUS_ANFES[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CORR_ERR_STATUS_ANFES[0], nxt_AER_CAP_CORR_ERR_STATUS_ANFES[0], AER_CAP_CORR_ERR_STATUS.ANFES[0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.IECOR x1 RW/1C/V/P, using RW/1C/V/P template.
// clear the each bit when writing a 1
logic [0:0] req_up_AER_CAP_CORR_ERR_STATUS_IECOR;
always_comb begin
 req_up_AER_CAP_CORR_ERR_STATUS_IECOR[0:0] = 
   {1{write_req_AER_CAP_CORR_ERR_STATUS & be[1]}}
;
end

logic [0:0] clr_AER_CAP_CORR_ERR_STATUS_IECOR;
always_comb begin
 clr_AER_CAP_CORR_ERR_STATUS_IECOR = write_data[14:14] & req_up_AER_CAP_CORR_ERR_STATUS_IECOR;

end
logic [0:0] swwr_AER_CAP_CORR_ERR_STATUS_IECOR;
logic [0:0] sw_nxt_AER_CAP_CORR_ERR_STATUS_IECOR;
always_comb begin
 swwr_AER_CAP_CORR_ERR_STATUS_IECOR = clr_AER_CAP_CORR_ERR_STATUS_IECOR;
 sw_nxt_AER_CAP_CORR_ERR_STATUS_IECOR = {1{1'b0}};

end
logic [0:0] up_AER_CAP_CORR_ERR_STATUS_IECOR;
logic [0:0] nxt_AER_CAP_CORR_ERR_STATUS_IECOR;
always_comb begin
 up_AER_CAP_CORR_ERR_STATUS_IECOR = 
   swwr_AER_CAP_CORR_ERR_STATUS_IECOR | {1{load_AER_CAP_CORR_ERR_STATUS.IECOR}};
end
always_comb begin
 nxt_AER_CAP_CORR_ERR_STATUS_IECOR[0] = 
    load_AER_CAP_CORR_ERR_STATUS.IECOR ?
    new_AER_CAP_CORR_ERR_STATUS.IECOR[0] :
    sw_nxt_AER_CAP_CORR_ERR_STATUS_IECOR[0];
end



`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CORR_ERR_STATUS_IECOR[0], nxt_AER_CAP_CORR_ERR_STATUS_IECOR[0], AER_CAP_CORR_ERR_STATUS.IECOR[0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_STATUS.RESERVED0 x8 RO, using RO template.
assign AER_CAP_CORR_ERR_STATUS.RESERVED0 = 17'h0;



//---------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK Address Decode
logic  addr_decode_AER_CAP_CORR_ERR_MASK;
logic  write_req_AER_CAP_CORR_ERR_MASK;
always_comb begin
   addr_decode_AER_CAP_CORR_ERR_MASK = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_CORR_ERR_MASK_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_CORR_ERR_MASK = IsCFGWr && addr_decode_AER_CAP_CORR_ERR_MASK;
end

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RES x1 RO, using RO template.
assign AER_CAP_CORR_ERR_MASK.RES = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RESERVED2 x5 RO, using RO template.
assign AER_CAP_CORR_ERR_MASK.RESERVED2 = 5'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.DLPE x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_CORR_ERR_MASK_DLPE;
always_comb begin
 up_AER_CAP_CORR_ERR_MASK_DLPE =
    ({1{write_req_AER_CAP_CORR_ERR_MASK }} &
    be[0:0]);
end

logic [0:0] nxt_AER_CAP_CORR_ERR_MASK_DLPE;
always_comb begin
 nxt_AER_CAP_CORR_ERR_MASK_DLPE = write_data[6:6];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CORR_ERR_MASK_DLPE[0], nxt_AER_CAP_CORR_ERR_MASK_DLPE[0:0], AER_CAP_CORR_ERR_MASK.DLPE[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.BDLLPS x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_CORR_ERR_MASK_BDLLPS;
always_comb begin
 up_AER_CAP_CORR_ERR_MASK_BDLLPS =
    ({1{write_req_AER_CAP_CORR_ERR_MASK }} &
    be[0:0]);
end

logic [0:0] nxt_AER_CAP_CORR_ERR_MASK_BDLLPS;
always_comb begin
 nxt_AER_CAP_CORR_ERR_MASK_BDLLPS = write_data[7:7];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CORR_ERR_MASK_BDLLPS[0], nxt_AER_CAP_CORR_ERR_MASK_BDLLPS[0:0], AER_CAP_CORR_ERR_MASK.BDLLPS[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RNRS x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_CORR_ERR_MASK_RNRS;
always_comb begin
 up_AER_CAP_CORR_ERR_MASK_RNRS =
    ({1{write_req_AER_CAP_CORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_CORR_ERR_MASK_RNRS;
always_comb begin
 nxt_AER_CAP_CORR_ERR_MASK_RNRS = write_data[8:8];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CORR_ERR_MASK_RNRS[0], nxt_AER_CAP_CORR_ERR_MASK_RNRS[0:0], AER_CAP_CORR_ERR_MASK.RNRS[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RESERVED1 x3 RO, using RO template.
assign AER_CAP_CORR_ERR_MASK.RESERVED1 = 3'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RTTS x1 RO, using RO template.
assign AER_CAP_CORR_ERR_MASK.RTTS = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.ANFES x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_CORR_ERR_MASK_ANFES;
always_comb begin
 up_AER_CAP_CORR_ERR_MASK_ANFES =
    ({1{write_req_AER_CAP_CORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_CORR_ERR_MASK_ANFES;
always_comb begin
 nxt_AER_CAP_CORR_ERR_MASK_ANFES = write_data[13:13];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h1, up_AER_CAP_CORR_ERR_MASK_ANFES[0], nxt_AER_CAP_CORR_ERR_MASK_ANFES[0:0], AER_CAP_CORR_ERR_MASK.ANFES[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.IECOR x1 RW/P, using RW/P template.
logic [0:0] up_AER_CAP_CORR_ERR_MASK_IECOR;
always_comb begin
 up_AER_CAP_CORR_ERR_MASK_IECOR =
    ({1{write_req_AER_CAP_CORR_ERR_MASK }} &
    be[1:1]);
end

logic [0:0] nxt_AER_CAP_CORR_ERR_MASK_IECOR;
always_comb begin
 nxt_AER_CAP_CORR_ERR_MASK_IECOR = write_data[14:14];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_pwr_rst_n, 1'h1, up_AER_CAP_CORR_ERR_MASK_IECOR[0], nxt_AER_CAP_CORR_ERR_MASK_IECOR[0:0], AER_CAP_CORR_ERR_MASK.IECOR[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CORR_ERR_MASK.RESERVED0 x8 RO, using RO template.
assign AER_CAP_CORR_ERR_MASK.RESERVED0 = 17'h0;



//---------------------------------------------------------------------
// AER_CAP_CONTROL Address Decode
logic  addr_decode_AER_CAP_CONTROL;
logic  write_req_AER_CAP_CONTROL;
always_comb begin
   addr_decode_AER_CAP_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_CONTROL = IsCFGWr && addr_decode_AER_CAP_CONTROL;
end

// ----------------------------------------------------------------------
// AER_CAP_CONTROL.TFEP x5 RO/V/P, using RO/V/P template.
logic [0:0] req_up_AER_CAP_CONTROL_TFEP;
always_comb begin
 req_up_AER_CAP_CONTROL_TFEP[0] = 
   {write_req_AER_CAP_CONTROL & be[0]}
;
end

logic [4:0] nxt_AER_CAP_CONTROL_TFEP;
logic [0:0] up_AER_CAP_CONTROL_TFEP;
always_comb begin
 up_AER_CAP_CONTROL_TFEP = 
   {1{load_AER_CAP_CONTROL.TFEP}};

end
always_comb begin
 nxt_AER_CAP_CONTROL_TFEP[4:0] = 
   new_AER_CAP_CONTROL.TFEP[4:0];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 5'h0, up_AER_CAP_CONTROL_TFEP[0], nxt_AER_CAP_CONTROL_TFEP[4:0], AER_CAP_CONTROL.TFEP[4:0])

// ----------------------------------------------------------------------
// AER_CAP_CONTROL.ECRCGC x1 RO, using RO template.
assign AER_CAP_CONTROL.ECRCGC = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.ECRCGE x1 RO, using RO template.
assign AER_CAP_CONTROL.ECRCGE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.ECRCCC x1 RO, using RO template.
assign AER_CAP_CONTROL.ECRCCC = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.ECRCCE x1 RO, using RO template.
assign AER_CAP_CONTROL.ECRCCE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.Multhdrrc x1 RO, using RO template.
assign AER_CAP_CONTROL.Multhdrrc = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.RESERVED x1 RO, using RO template.
assign AER_CAP_CONTROL.RESERVED = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_CONTROL.TLPPFLOGP x1 RO/V/P, using RO/V/P template.
logic [0:0] req_up_AER_CAP_CONTROL_TLPPFLOGP;
always_comb begin
 req_up_AER_CAP_CONTROL_TLPPFLOGP[0] = 
   {write_req_AER_CAP_CONTROL & be[1]}
;
end

logic [0:0] nxt_AER_CAP_CONTROL_TLPPFLOGP;
logic [0:0] up_AER_CAP_CONTROL_TLPPFLOGP;
always_comb begin
 up_AER_CAP_CONTROL_TLPPFLOGP = 
   {1{load_AER_CAP_CONTROL.TLPPFLOGP}};

end
always_comb begin
 nxt_AER_CAP_CONTROL_TLPPFLOGP[0:0] = 
   new_AER_CAP_CONTROL.TLPPFLOGP[0:0];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 1'h0, up_AER_CAP_CONTROL_TLPPFLOGP[0], nxt_AER_CAP_CONTROL_TLPPFLOGP[0:0], AER_CAP_CONTROL.TLPPFLOGP[0:0])

// ----------------------------------------------------------------------
// AER_CAP_CONTROL.RESERVED1 x8 RO, using RO template.
assign AER_CAP_CONTROL.RESERVED1 = 20'h0;



//---------------------------------------------------------------------
// AER_CAP_HEADER_LOG_0 Address Decode
logic  addr_decode_AER_CAP_HEADER_LOG_0;
logic  write_req_AER_CAP_HEADER_LOG_0;
always_comb begin
   addr_decode_AER_CAP_HEADER_LOG_0 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_HEADER_LOG_0_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_HEADER_LOG_0 = IsCFGWr && addr_decode_AER_CAP_HEADER_LOG_0;
end

// ----------------------------------------------------------------------
// AER_CAP_HEADER_LOG_0.HDRLOGDW0 x8 RO/V/P, using RO/V/P template.
logic [3:0] req_up_AER_CAP_HEADER_LOG_0_HDRLOGDW0;
always_comb begin
 req_up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[0] = 
   {write_req_AER_CAP_HEADER_LOG_0 & be[0]}
;
 req_up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[1] = 
   {write_req_AER_CAP_HEADER_LOG_0 & be[1]}
;
 req_up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[2] = 
   {write_req_AER_CAP_HEADER_LOG_0 & be[2]}
;
 req_up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[3] = 
   {write_req_AER_CAP_HEADER_LOG_0 & be[3]}
;
end

logic [31:0] nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0;
logic [3:0] up_AER_CAP_HEADER_LOG_0_HDRLOGDW0;
always_comb begin
 up_AER_CAP_HEADER_LOG_0_HDRLOGDW0 = 
   {4{load_AER_CAP_HEADER_LOG_0.HDRLOGDW0}};

end
always_comb begin
 nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[7:0] = 
   new_AER_CAP_HEADER_LOG_0.HDRLOGDW0[7:0];
 nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[15:8] = 
   new_AER_CAP_HEADER_LOG_0.HDRLOGDW0[15:8];
 nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[23:16] = 
   new_AER_CAP_HEADER_LOG_0.HDRLOGDW0[23:16];
 nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[31:24] = 
   new_AER_CAP_HEADER_LOG_0.HDRLOGDW0[31:24];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[0], nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[7:0], AER_CAP_HEADER_LOG_0.HDRLOGDW0[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[1], nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[15:8], AER_CAP_HEADER_LOG_0.HDRLOGDW0[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[2], nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[23:16], AER_CAP_HEADER_LOG_0.HDRLOGDW0[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_0_HDRLOGDW0[3], nxt_AER_CAP_HEADER_LOG_0_HDRLOGDW0[31:24], AER_CAP_HEADER_LOG_0.HDRLOGDW0[31:24])

//---------------------------------------------------------------------
// AER_CAP_HEADER_LOG_1 Address Decode
logic  addr_decode_AER_CAP_HEADER_LOG_1;
logic  write_req_AER_CAP_HEADER_LOG_1;
always_comb begin
   addr_decode_AER_CAP_HEADER_LOG_1 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_HEADER_LOG_1_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_HEADER_LOG_1 = IsCFGWr && addr_decode_AER_CAP_HEADER_LOG_1;
end

// ----------------------------------------------------------------------
// AER_CAP_HEADER_LOG_1.HDRLOGDW1 x8 RO/V/P, using RO/V/P template.
logic [3:0] req_up_AER_CAP_HEADER_LOG_1_HDRLOGDW1;
always_comb begin
 req_up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[0] = 
   {write_req_AER_CAP_HEADER_LOG_1 & be[0]}
;
 req_up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[1] = 
   {write_req_AER_CAP_HEADER_LOG_1 & be[1]}
;
 req_up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[2] = 
   {write_req_AER_CAP_HEADER_LOG_1 & be[2]}
;
 req_up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[3] = 
   {write_req_AER_CAP_HEADER_LOG_1 & be[3]}
;
end

logic [31:0] nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1;
logic [3:0] up_AER_CAP_HEADER_LOG_1_HDRLOGDW1;
always_comb begin
 up_AER_CAP_HEADER_LOG_1_HDRLOGDW1 = 
   {4{load_AER_CAP_HEADER_LOG_1.HDRLOGDW1}};

end
always_comb begin
 nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[7:0] = 
   new_AER_CAP_HEADER_LOG_1.HDRLOGDW1[7:0];
 nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[15:8] = 
   new_AER_CAP_HEADER_LOG_1.HDRLOGDW1[15:8];
 nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[23:16] = 
   new_AER_CAP_HEADER_LOG_1.HDRLOGDW1[23:16];
 nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[31:24] = 
   new_AER_CAP_HEADER_LOG_1.HDRLOGDW1[31:24];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[0], nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[7:0], AER_CAP_HEADER_LOG_1.HDRLOGDW1[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[1], nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[15:8], AER_CAP_HEADER_LOG_1.HDRLOGDW1[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[2], nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[23:16], AER_CAP_HEADER_LOG_1.HDRLOGDW1[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_1_HDRLOGDW1[3], nxt_AER_CAP_HEADER_LOG_1_HDRLOGDW1[31:24], AER_CAP_HEADER_LOG_1.HDRLOGDW1[31:24])

//---------------------------------------------------------------------
// AER_CAP_HEADER_LOG_2 Address Decode
logic  addr_decode_AER_CAP_HEADER_LOG_2;
logic  write_req_AER_CAP_HEADER_LOG_2;
always_comb begin
   addr_decode_AER_CAP_HEADER_LOG_2 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_HEADER_LOG_2_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_HEADER_LOG_2 = IsCFGWr && addr_decode_AER_CAP_HEADER_LOG_2;
end

// ----------------------------------------------------------------------
// AER_CAP_HEADER_LOG_2.HDRLOGDW2 x8 RO/V/P, using RO/V/P template.
logic [3:0] req_up_AER_CAP_HEADER_LOG_2_HDRLOGDW2;
always_comb begin
 req_up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[0] = 
   {write_req_AER_CAP_HEADER_LOG_2 & be[0]}
;
 req_up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[1] = 
   {write_req_AER_CAP_HEADER_LOG_2 & be[1]}
;
 req_up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[2] = 
   {write_req_AER_CAP_HEADER_LOG_2 & be[2]}
;
 req_up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[3] = 
   {write_req_AER_CAP_HEADER_LOG_2 & be[3]}
;
end

logic [31:0] nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2;
logic [3:0] up_AER_CAP_HEADER_LOG_2_HDRLOGDW2;
always_comb begin
 up_AER_CAP_HEADER_LOG_2_HDRLOGDW2 = 
   {4{load_AER_CAP_HEADER_LOG_2.HDRLOGDW2}};

end
always_comb begin
 nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[7:0] = 
   new_AER_CAP_HEADER_LOG_2.HDRLOGDW2[7:0];
 nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[15:8] = 
   new_AER_CAP_HEADER_LOG_2.HDRLOGDW2[15:8];
 nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[23:16] = 
   new_AER_CAP_HEADER_LOG_2.HDRLOGDW2[23:16];
 nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[31:24] = 
   new_AER_CAP_HEADER_LOG_2.HDRLOGDW2[31:24];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[0], nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[7:0], AER_CAP_HEADER_LOG_2.HDRLOGDW2[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[1], nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[15:8], AER_CAP_HEADER_LOG_2.HDRLOGDW2[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[2], nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[23:16], AER_CAP_HEADER_LOG_2.HDRLOGDW2[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_2_HDRLOGDW2[3], nxt_AER_CAP_HEADER_LOG_2_HDRLOGDW2[31:24], AER_CAP_HEADER_LOG_2.HDRLOGDW2[31:24])

//---------------------------------------------------------------------
// AER_CAP_HEADER_LOG_3 Address Decode
logic  addr_decode_AER_CAP_HEADER_LOG_3;
logic  write_req_AER_CAP_HEADER_LOG_3;
always_comb begin
   addr_decode_AER_CAP_HEADER_LOG_3 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_HEADER_LOG_3_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_HEADER_LOG_3 = IsCFGWr && addr_decode_AER_CAP_HEADER_LOG_3;
end

// ----------------------------------------------------------------------
// AER_CAP_HEADER_LOG_3.HDRLOGDW3 x8 RO/V/P, using RO/V/P template.
logic [3:0] req_up_AER_CAP_HEADER_LOG_3_HDRLOGDW3;
always_comb begin
 req_up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[0] = 
   {write_req_AER_CAP_HEADER_LOG_3 & be[0]}
;
 req_up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[1] = 
   {write_req_AER_CAP_HEADER_LOG_3 & be[1]}
;
 req_up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[2] = 
   {write_req_AER_CAP_HEADER_LOG_3 & be[2]}
;
 req_up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[3] = 
   {write_req_AER_CAP_HEADER_LOG_3 & be[3]}
;
end

logic [31:0] nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3;
logic [3:0] up_AER_CAP_HEADER_LOG_3_HDRLOGDW3;
always_comb begin
 up_AER_CAP_HEADER_LOG_3_HDRLOGDW3 = 
   {4{load_AER_CAP_HEADER_LOG_3.HDRLOGDW3}};

end
always_comb begin
 nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[7:0] = 
   new_AER_CAP_HEADER_LOG_3.HDRLOGDW3[7:0];
 nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[15:8] = 
   new_AER_CAP_HEADER_LOG_3.HDRLOGDW3[15:8];
 nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[23:16] = 
   new_AER_CAP_HEADER_LOG_3.HDRLOGDW3[23:16];
 nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[31:24] = 
   new_AER_CAP_HEADER_LOG_3.HDRLOGDW3[31:24];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[0], nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[7:0], AER_CAP_HEADER_LOG_3.HDRLOGDW3[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[1], nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[15:8], AER_CAP_HEADER_LOG_3.HDRLOGDW3[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[2], nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[23:16], AER_CAP_HEADER_LOG_3.HDRLOGDW3[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_HEADER_LOG_3_HDRLOGDW3[3], nxt_AER_CAP_HEADER_LOG_3_HDRLOGDW3[31:24], AER_CAP_HEADER_LOG_3.HDRLOGDW3[31:24])

//---------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_COMMAND Address Decode

// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_COMMAND.CERE x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_COMMAND.CERE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_COMMAND.NERE x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_COMMAND.NERE = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_COMMAND.FERE x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_COMMAND.FERE = 1'h0;



//---------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS Address Decode

// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.CER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.CER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.MCER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.MCER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.FNER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.FNER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.MFNER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.MFNER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.FUF x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.FUF = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.NER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.NER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.FER x1 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.FER = 1'h0;



// ----------------------------------------------------------------------
// AER_CAP_ROOT_ERROR_STATUS.AEIMN x5 RO, using RO template.
assign AER_CAP_ROOT_ERROR_STATUS.AEIMN = 5'h0;



//---------------------------------------------------------------------
// AER_CAP_ERROR_SOURCE_IDENT Address Decode

// ----------------------------------------------------------------------
// AER_CAP_ERROR_SOURCE_IDENT.CSID x8 RO, using RO template.
assign AER_CAP_ERROR_SOURCE_IDENT.CSID = 16'h0;



// ----------------------------------------------------------------------
// AER_CAP_ERROR_SOURCE_IDENT.FNSID x8 RO, using RO template.
assign AER_CAP_ERROR_SOURCE_IDENT.FNSID = 16'h0;



//---------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_0 Address Decode
logic  addr_decode_AER_CAP_TLP_PREFIX_LOG_0;
logic  write_req_AER_CAP_TLP_PREFIX_LOG_0;
always_comb begin
   addr_decode_AER_CAP_TLP_PREFIX_LOG_0 = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR) && req.valid ;
   write_req_AER_CAP_TLP_PREFIX_LOG_0 = IsCFGWr && addr_decode_AER_CAP_TLP_PREFIX_LOG_0;
end

// ----------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0 x8 RO/V/P, using RO/V/P template.
logic [3:0] req_up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0;
always_comb begin
 req_up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[0] = 
   {write_req_AER_CAP_TLP_PREFIX_LOG_0 & be[0]}
;
 req_up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[1] = 
   {write_req_AER_CAP_TLP_PREFIX_LOG_0 & be[1]}
;
 req_up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[2] = 
   {write_req_AER_CAP_TLP_PREFIX_LOG_0 & be[2]}
;
 req_up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[3] = 
   {write_req_AER_CAP_TLP_PREFIX_LOG_0 & be[3]}
;
end

logic [31:0] nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0;
logic [3:0] up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0;
always_comb begin
 up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0 = 
   {4{load_AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0}};

end
always_comb begin
 nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[7:0] = 
   new_AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[7:0];
 nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[15:8] = 
   new_AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[15:8];
 nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[23:16] = 
   new_AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[23:16];
 nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[31:24] = 
   new_AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[31:24];
end


`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[0], nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[7:0], AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[7:0])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[1], nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[15:8], AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[15:8])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[2], nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[23:16], AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[23:16])
`RTLGEN_HQM_PF_CFG_EN_FF(rtl_clk, hqm_csr_pf0_pwr_rst_n, 8'h0, up_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[3], nxt_AER_CAP_TLP_PREFIX_LOG_0_TLPPFLOG0[31:24], AER_CAP_TLP_PREFIX_LOG_0.TLPPFLOG0[31:24])

//---------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_1 Address Decode

// ----------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_1.TLPPFLOG1 x8 RO, using RO template.
assign AER_CAP_TLP_PREFIX_LOG_1.TLPPFLOG1 = 32'h0;



//---------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_2 Address Decode

// ----------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_2.TLPPFLOG2 x8 RO, using RO template.
assign AER_CAP_TLP_PREFIX_LOG_2.TLPPFLOG2 = 32'h0;



//---------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_3 Address Decode

// ----------------------------------------------------------------------
// AER_CAP_TLP_PREFIX_LOG_3.TLPPFLOG3 x8 RO, using RO template.
assign AER_CAP_TLP_PREFIX_LOG_3.TLPPFLOG3 = 32'h0;



//---------------------------------------------------------------------
// ATS_CAP_ID Address Decode

// ----------------------------------------------------------------------
// ATS_CAP_ID.ATSCID x8 RO, using RO template.
assign ATS_CAP_ID.ATSCID = 16'hF;



//---------------------------------------------------------------------
// ATS_CAP_VERSION_NEXT_PTR Address Decode

// ----------------------------------------------------------------------
// ATS_CAP_VERSION_NEXT_PTR.ATSCV x4 RO, using RO template.
assign ATS_CAP_VERSION_NEXT_PTR.ATSCV = 4'h1;



// ----------------------------------------------------------------------
// ATS_CAP_VERSION_NEXT_PTR.CAP_PTR x8 RO, using RO template.
assign ATS_CAP_VERSION_NEXT_PTR.CAP_PTR = 12'h0;



//---------------------------------------------------------------------
// ATS_CAP Address Decode

// ----------------------------------------------------------------------
// ATS_CAP.ATSIQD x5 RO, using RO template.
assign ATS_CAP.ATSIQD = 5'h0;



// ----------------------------------------------------------------------
// ATS_CAP.ATSPAR x1 RO, using RO template.
assign ATS_CAP.ATSPAR = 1'h1;



// ----------------------------------------------------------------------
// ATS_CAP.ATSGIS x1 RO, using RO template.
assign ATS_CAP.ATSGIS = 1'h1;



//---------------------------------------------------------------------
// ATS_CAP_CONTROL Address Decode
logic  addr_decode_ATS_CAP_CONTROL;
logic  write_req_ATS_CAP_CONTROL;
always_comb begin
   addr_decode_ATS_CAP_CONTROL = (req_addr[HQM_PF_CFG_CFG_ADDR_MSB:ADDR_LSB_BUS_ALIGN] == ATS_CAP_CONTROL_DECODE_ADDR) && req.valid ;
   write_req_ATS_CAP_CONTROL = IsCFGWr && addr_decode_ATS_CAP_CONTROL;
end

// ----------------------------------------------------------------------
// ATS_CAP_CONTROL.ATSSTU x5 RW, using RW template.
logic [0:0] up_ATS_CAP_CONTROL_ATSSTU;
always_comb begin
 up_ATS_CAP_CONTROL_ATSSTU =
    ({1{write_req_ATS_CAP_CONTROL }} &
    be[2:2]);
end

logic [4:0] nxt_ATS_CAP_CONTROL_ATSSTU;
always_comb begin
 nxt_ATS_CAP_CONTROL_ATSSTU = write_data[20:16];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 5'h0, up_ATS_CAP_CONTROL_ATSSTU[0], nxt_ATS_CAP_CONTROL_ATSSTU[4:0], ATS_CAP_CONTROL.ATSSTU[4:0])

// ----------------------------------------------------------------------
// ATS_CAP_CONTROL.ATSE x1 RW, using RW template.
logic [0:0] up_ATS_CAP_CONTROL_ATSE;
always_comb begin
 up_ATS_CAP_CONTROL_ATSE =
    ({1{write_req_ATS_CAP_CONTROL }} &
    be[3:3]);
end

logic [0:0] nxt_ATS_CAP_CONTROL_ATSE;
always_comb begin
 nxt_ATS_CAP_CONTROL_ATSE = write_data[31:31];

end


`RTLGEN_HQM_PF_CFG_EN_FF(gated_clk, hqm_csr_pf0_rst_n, 1'h0, up_ATS_CAP_CONTROL_ATSE[0], nxt_ATS_CAP_CONTROL_ATSE[0:0], ATS_CAP_CONTROL.ATSE[0:0])
// Shared registers assignments


// end register logic section }

always_comb begin : MISS_VALID_BLOCK

   unique casez (req_opcode) 
      CFGRD: begin
         ack.read_valid = req_valid;
         ack.write_valid  = 1'b0; 
         ack.write_miss = ack.write_valid; 
         unique casez (case_req_addr_HQM_PF_CFG_CFG) 
           VENDOR_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           DEVICE_COMMAND_DECODE_ADDR: ack.read_miss = 1'b0;
           REVISION_ID_CLASS_CODE_DECODE_ADDR: ack.read_miss = 1'b0;
           CACHE_LINE_SIZE_DECODE_ADDR: ack.read_miss = 1'b0;
           FUNC_BAR_L_DECODE_ADDR: ack.read_miss = 1'b0;
           FUNC_BAR_U_DECODE_ADDR: ack.read_miss = 1'b0;
           CSR_BAR_L_DECODE_ADDR: ack.read_miss = 1'b0;
           CSR_BAR_U_DECODE_ADDR: ack.read_miss = 1'b0;
           SUBSYSTEM_VENDOR_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           CAP_PTR_DECODE_ADDR: ack.read_miss = 1'b0;
           INT_LINE_DECODE_ADDR: ack.read_miss = 1'b0;
           MSIX_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR: ack.read_miss = 1'b0;
           MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_DEVICE_CAP_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_LINK_CAP_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_LINK_CONTROL_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR: ack.read_miss = 1'b0;
           PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR: ack.read_miss = 1'b0;
           PM_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           PM_CAP_CONTROL_STATUS_DECODE_ADDR: ack.read_miss = 1'b0;
           ACS_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           ACS_CAP_DECODE_ADDR: ack.read_miss = 1'b0;
           PASID_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           PASID_CAP_DECODE_ADDR: ack.read_miss = 1'b0;
           DVSEC_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           DVSEC_HDR1_DECODE_ADDR: ack.read_miss = 1'b0;
           DVSEC_HDR2_DECODE_ADDR: ack.read_miss = 1'b0;
           SCIOV_SUPP_PGSZ_DECODE_ADDR: ack.read_miss = 1'b0;
           SCIOV_SYS_PGSZ_DECODE_ADDR: ack.read_miss = 1'b0;
           SCIOV_IMS_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_CORR_ERR_STATUS_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_CORR_ERR_MASK_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_CONTROL_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_HEADER_LOG_0_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_HEADER_LOG_1_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_HEADER_LOG_2_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_HEADER_LOG_3_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR: ack.read_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR: ack.read_miss = 1'b0;
           ATS_CAP_ID_DECODE_ADDR: ack.read_miss = 1'b0;
           ATS_CAP_DECODE_ADDR: ack.read_miss = 1'b0;
            default: ack.read_miss  = ack.read_valid; 
         endcase
      end    
      CFGWR: begin
         ack.write_valid = req_valid;
         ack.read_valid  = 1'b0; 
         ack.read_miss = ack.read_valid;
         unique casez (case_req_addr_HQM_PF_CFG_CFG) 
           VENDOR_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           DEVICE_COMMAND_DECODE_ADDR: ack.write_miss = 1'b0;
           REVISION_ID_CLASS_CODE_DECODE_ADDR: ack.write_miss = 1'b0;
           CACHE_LINE_SIZE_DECODE_ADDR: ack.write_miss = 1'b0;
           FUNC_BAR_L_DECODE_ADDR: ack.write_miss = 1'b0;
           FUNC_BAR_U_DECODE_ADDR: ack.write_miss = 1'b0;
           CSR_BAR_L_DECODE_ADDR: ack.write_miss = 1'b0;
           CSR_BAR_U_DECODE_ADDR: ack.write_miss = 1'b0;
           SUBSYSTEM_VENDOR_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           CAP_PTR_DECODE_ADDR: ack.write_miss = 1'b0;
           INT_LINE_DECODE_ADDR: ack.write_miss = 1'b0;
           MSIX_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR: ack.write_miss = 1'b0;
           MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_DEVICE_CAP_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_LINK_CAP_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_LINK_CONTROL_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR: ack.write_miss = 1'b0;
           PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR: ack.write_miss = 1'b0;
           PM_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           PM_CAP_CONTROL_STATUS_DECODE_ADDR: ack.write_miss = 1'b0;
           ACS_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           ACS_CAP_DECODE_ADDR: ack.write_miss = 1'b0;
           PASID_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           PASID_CAP_DECODE_ADDR: ack.write_miss = 1'b0;
           DVSEC_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           DVSEC_HDR1_DECODE_ADDR: ack.write_miss = 1'b0;
           DVSEC_HDR2_DECODE_ADDR: ack.write_miss = 1'b0;
           SCIOV_SUPP_PGSZ_DECODE_ADDR: ack.write_miss = 1'b0;
           SCIOV_SYS_PGSZ_DECODE_ADDR: ack.write_miss = 1'b0;
           SCIOV_IMS_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_CORR_ERR_STATUS_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_CORR_ERR_MASK_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_CONTROL_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_HEADER_LOG_0_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_HEADER_LOG_1_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_HEADER_LOG_2_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_HEADER_LOG_3_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR: ack.write_miss = 1'b0;
           AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR: ack.write_miss = 1'b0;
           ATS_CAP_ID_DECODE_ADDR: ack.write_miss = 1'b0;
           ATS_CAP_DECODE_ADDR: ack.write_miss = 1'b0;
            default: ack.write_miss = ack.write_valid;
         endcase 
      end  
      default: begin
         ack.write_valid  = req_valid & IsWrOpcode;
         ack.read_valid  = req_valid & IsRdOpcode;
         ack.read_miss  = ack.read_valid;
         ack.write_miss = ack.write_valid;
      end 
   endcase 
end

always_comb begin : SAI_BLOCK

   unique casez (req_opcode) 
      CFGRD: 
         unique casez (case_req_addr_HQM_PF_CFG_CFG) 
           VENDOR_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DEVICE_COMMAND_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           REVISION_ID_CLASS_CODE_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CACHE_LINE_SIZE_DECODE_ADDR: sai_successfull_per_byte = {{1{1'b1}},{1{1'b1}},{1{1'b1}},{1{1'b1}}};
           FUNC_BAR_L_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           FUNC_BAR_U_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CSR_BAR_L_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CSR_BAR_U_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SUBSYSTEM_VENDOR_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           CAP_PTR_DECODE_ADDR: sai_successfull_per_byte = {{3{1'b1}},{1{1'b1}}};
           INT_LINE_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           MSIX_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           PCIE_CAP_DEVICE_CAP_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PCIE_CAP_LINK_CAP_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_LINK_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PM_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           PM_CAP_CONTROL_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           ACS_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           ACS_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PASID_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PASID_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DVSEC_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DVSEC_HDR1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           DVSEC_HDR2_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           SCIOV_SUPP_PGSZ_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SCIOV_SYS_PGSZ_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SCIOV_IMS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CORR_ERR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CORR_ERR_MASK_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_0_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_3_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           ATS_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           ATS_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
            default: sai_successfull_per_byte = {4{1'b1}};
         endcase 
      CFGWR: 
         unique casez (case_req_addr_HQM_PF_CFG_CFG) 
           VENDOR_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DEVICE_COMMAND_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           REVISION_ID_CLASS_CODE_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CACHE_LINE_SIZE_DECODE_ADDR: sai_successfull_per_byte = {{1{1'b1}},{1{1'b1}},{1{1'b1}},{1{1'b1}}};
           FUNC_BAR_L_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           FUNC_BAR_U_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CSR_BAR_L_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           CSR_BAR_U_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SUBSYSTEM_VENDOR_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           CAP_PTR_DECODE_ADDR: sai_successfull_per_byte = {{3{1'b1}},{1{1'b1}}};
           INT_LINE_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           MSIX_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           PCIE_CAP_DEVICE_CAP_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PCIE_CAP_LINK_CAP_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_LINK_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PM_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{1{1'b1}},{1{1'b1}}};
           PM_CAP_CONTROL_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           ACS_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           ACS_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PASID_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           PASID_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DVSEC_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           DVSEC_HDR1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           DVSEC_HDR2_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           SCIOV_SUPP_PGSZ_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SCIOV_SYS_PGSZ_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           SCIOV_IMS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CORR_ERR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CORR_ERR_MASK_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_CONTROL_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_0_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_HEADER_LOG_3_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR: sai_successfull_per_byte = {{4{1'b1}}};
           ATS_CAP_ID_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
           ATS_CAP_DECODE_ADDR: sai_successfull_per_byte = {{2{1'b1}},{2{1'b1}}};
            default: sai_successfull_per_byte = {4{1'b1}};
         endcase 
      default: sai_successfull_per_byte = {4{1'b1}};
   endcase 
end


always_comb ack.sai_successfull = &(sai_successfull_per_byte | ~be);


// end decode and addr logic section }

// ======================================================================
// begin rdata section {

always_comb begin : READ_DATA_BLOCK

   unique casez (req_opcode) 
      CFGRD:
         unique casez (case_req_addr_HQM_PF_CFG_CFG) 
           VENDOR_ID_DECODE_ADDR: read_data = {DEVICE_ID,VENDOR_ID};
           DEVICE_COMMAND_DECODE_ADDR: read_data = {DEVICE_STATUS,DEVICE_COMMAND};
           REVISION_ID_CLASS_CODE_DECODE_ADDR: read_data = {REVISION_ID_CLASS_CODE};
           CACHE_LINE_SIZE_DECODE_ADDR: read_data = {8'h0,HEADER_TYPE,8'h0,CACHE_LINE_SIZE};
           FUNC_BAR_L_DECODE_ADDR: read_data = {FUNC_BAR_L};
           FUNC_BAR_U_DECODE_ADDR: read_data = {FUNC_BAR_U};
           CSR_BAR_L_DECODE_ADDR: read_data = {CSR_BAR_L};
           CSR_BAR_U_DECODE_ADDR: read_data = {CSR_BAR_U};
           SUBSYSTEM_VENDOR_ID_DECODE_ADDR: read_data = {SUBSYSTEM_ID,SUBSYSTEM_VENDOR_ID};
           CAP_PTR_DECODE_ADDR: read_data = {24'h0,CAP_PTR};
           INT_LINE_DECODE_ADDR: read_data = {16'h0,INT_PIN,INT_LINE};
           MSIX_CAP_ID_DECODE_ADDR: read_data = {MSIX_CAP_CONTROL,MSIX_CAP_NEXT_CAP_PTR,MSIX_CAP_ID};
           MSIX_CAP_TABLE_OFFSET_BIR_DECODE_ADDR: read_data = {MSIX_CAP_TABLE_OFFSET_BIR};
           MSIX_CAP_PBA_OFFSET_BIR_DECODE_ADDR: read_data = {MSIX_CAP_PBA_OFFSET_BIR};
           PCIE_CAP_ID_DECODE_ADDR: read_data = {PCIE_CAP,PCIE_CAP_NEXT_CAP_PTR,PCIE_CAP_ID};
           PCIE_CAP_DEVICE_CAP_DECODE_ADDR: read_data = {PCIE_CAP_DEVICE_CAP};
           PCIE_CAP_DEVICE_CONTROL_DECODE_ADDR: read_data = {PCIE_CAP_DEVICE_STATUS,PCIE_CAP_DEVICE_CONTROL};
           PCIE_CAP_LINK_CAP_DECODE_ADDR: read_data = {PCIE_CAP_LINK_CAP};
           PCIE_CAP_LINK_CONTROL_DECODE_ADDR: read_data = {PCIE_CAP_LINK_STATUS,PCIE_CAP_LINK_CONTROL};
           PCIE_CAP_DEVICE_CAP_2_DECODE_ADDR: read_data = {PCIE_CAP_DEVICE_CAP_2};
           PCIE_CAP_DEVICE_CONTROL_2_DECODE_ADDR: read_data = {16'h0,PCIE_CAP_DEVICE_CONTROL_2};
           PM_CAP_ID_DECODE_ADDR: read_data = {PM_CAP,PM_CAP_NEXT_CAP_PTR,PM_CAP_ID};
           PM_CAP_CONTROL_STATUS_DECODE_ADDR: read_data = {PM_CAP_CONTROL_STATUS};
           ACS_CAP_ID_DECODE_ADDR: read_data = {ACS_CAP_VERSION_NEXT_PTR,ACS_CAP_ID};
           ACS_CAP_DECODE_ADDR: read_data = {ACS_CAP_CONTROL,ACS_CAP};
           PASID_CAP_ID_DECODE_ADDR: read_data = {PASID_CAP_VERSION_NEXT_PTR,PASID_CAP_ID};
           PASID_CAP_DECODE_ADDR: read_data = {PASID_CONTROL,PASID_CAP};
           DVSEC_CAP_ID_DECODE_ADDR: read_data = {DVSEC_CAP_VERSION_NEXT_PTR,DVSEC_CAP_ID};
           DVSEC_HDR1_DECODE_ADDR: read_data = {DVSEC_HDR1};
           DVSEC_HDR2_DECODE_ADDR: read_data = {SCIOV_CAP,DVSEC_HDR2};
           SCIOV_SUPP_PGSZ_DECODE_ADDR: read_data = {SCIOV_SUPP_PGSZ};
           SCIOV_SYS_PGSZ_DECODE_ADDR: read_data = {SCIOV_SYS_PGSZ};
           SCIOV_IMS_DECODE_ADDR: read_data = {SCIOV_IMS};
           AER_CAP_ID_DECODE_ADDR: read_data = {AER_CAP_VERSION_NEXT_PTR,AER_CAP_ID};
           AER_CAP_UNCORR_ERR_STATUS_DECODE_ADDR: read_data = {AER_CAP_UNCORR_ERR_STATUS};
           AER_CAP_UNCORR_ERR_MASK_DECODE_ADDR: read_data = {AER_CAP_UNCORR_ERR_MASK};
           AER_CAP_UNCORR_ERR_SEV_DECODE_ADDR: read_data = {AER_CAP_UNCORR_ERR_SEV};
           AER_CAP_CORR_ERR_STATUS_DECODE_ADDR: read_data = {AER_CAP_CORR_ERR_STATUS};
           AER_CAP_CORR_ERR_MASK_DECODE_ADDR: read_data = {AER_CAP_CORR_ERR_MASK};
           AER_CAP_CONTROL_DECODE_ADDR: read_data = {AER_CAP_CONTROL};
           AER_CAP_HEADER_LOG_0_DECODE_ADDR: read_data = {AER_CAP_HEADER_LOG_0};
           AER_CAP_HEADER_LOG_1_DECODE_ADDR: read_data = {AER_CAP_HEADER_LOG_1};
           AER_CAP_HEADER_LOG_2_DECODE_ADDR: read_data = {AER_CAP_HEADER_LOG_2};
           AER_CAP_HEADER_LOG_3_DECODE_ADDR: read_data = {AER_CAP_HEADER_LOG_3};
           AER_CAP_ROOT_ERROR_COMMAND_DECODE_ADDR: read_data = {AER_CAP_ROOT_ERROR_COMMAND};
           AER_CAP_ROOT_ERROR_STATUS_DECODE_ADDR: read_data = {AER_CAP_ROOT_ERROR_STATUS};
           AER_CAP_ERROR_SOURCE_IDENT_DECODE_ADDR: read_data = {AER_CAP_ERROR_SOURCE_IDENT};
           AER_CAP_TLP_PREFIX_LOG_0_DECODE_ADDR: read_data = {AER_CAP_TLP_PREFIX_LOG_0};
           AER_CAP_TLP_PREFIX_LOG_1_DECODE_ADDR: read_data = {AER_CAP_TLP_PREFIX_LOG_1};
           AER_CAP_TLP_PREFIX_LOG_2_DECODE_ADDR: read_data = {AER_CAP_TLP_PREFIX_LOG_2};
           AER_CAP_TLP_PREFIX_LOG_3_DECODE_ADDR: read_data = {AER_CAP_TLP_PREFIX_LOG_3};
           ATS_CAP_ID_DECODE_ADDR: read_data = {ATS_CAP_VERSION_NEXT_PTR,ATS_CAP_ID};
           ATS_CAP_DECODE_ADDR: read_data = {ATS_CAP_CONTROL,ATS_CAP};
         default : read_data = '0; 
      endcase
      default : read_data = '0;  
   endcase
end

always_comb ack.data = read_data & { {8{be[3] & sai_successfull_per_byte[3]}}, {8{be[2] & sai_successfull_per_byte[2]}}, {8{be[1] & sai_successfull_per_byte[1]}}, {8{be[0] & sai_successfull_per_byte[0]}} };

always_comb write_data = req.data;


// end rdata section }

// ======================================================================
// begin register RSVD init section {
always_comb begin
    AER_CAP_ROOT_ERROR_COMMAND.reserved0 = '0;
    AER_CAP_ROOT_ERROR_STATUS.reserved0 = '0;
    ATS_CAP.reserved0 = '0;
    ATS_CAP_CONTROL.reserved0 = '0;
end

// end register RSVD init section }


// ======================================================================
// begin unit parity section {


// end unit parity section }


endmodule
//lintra pop
//lintra pop
