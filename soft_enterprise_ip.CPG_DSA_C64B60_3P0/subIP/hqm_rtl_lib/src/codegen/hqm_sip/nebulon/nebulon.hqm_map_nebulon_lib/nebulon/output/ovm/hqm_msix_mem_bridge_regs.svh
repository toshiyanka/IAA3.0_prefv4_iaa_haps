//                                                                             
// File:            hqm_msix_mem_bridge_regs.svh                               
// Nebulon version: d22ww21.1                                                  
// Description:                                                                
//                                                                             
// No Description Provided                                                     
//                                                                             
// Copyright (C) 2022 Intel Corp. All rights reserved                          
// THIS FILE IS AUTOMATICALLY GENERATED BY INTEL RDL GENERATOR, DO NOT EDIT    
//                                                                             


//RAL code compatible with Saola versions: 16.2.06 and newer 

`ifndef RAL_HQM_MSIX_MEM_BRIDGE_FILE
`define RAL_HQM_MSIX_MEM_BRIDGE_FILE

class hqm_msix_mem_bridge_MSG_ADDR_L_reg extends sla_ral_reg;

  // --------------------------
  sla_ral_field RSVD;
  sla_ral_field MSG_ADDR_L;

  // --------------------------
  `ovm_object_utils(hqm_msix_mem_bridge_MSG_ADDR_L_reg)

  // --------------------------
  function new(
                string         name = "",
                `ifdef SLA_RAL_COVERAGE
                sla_ral_coverage_t cov_t = COVERAGE_OFF,
                `endif
                int            bus_num=0,
                int            dev_num=0,
                int            func_num=0,
                int            offset=0,
                int            size=0,
                sla_ral_data_t reset_val=0,
                boolean_t      mon_enabled = SLA_FALSE
             );
      super.new();
      set_space_addr("CFG",undef);
      set_space_addr("MEM",undef);
      set_space_addr("IO",undef);
      set_space_addr("MSG",undef);
      set_space_addr("CREG",undef); 
      set_space_addr("LT_MEM",undef);    
 build();

      `ifdef SLA_RAL_COVERAGE
      `CONFIG_RAL_COVERAGE(regname, COVERAGE_ON, FD_RW_SAMPLE)
      if(_coverage_type != COVERAGE_OFF) begin
        if(_sample_type inside {FD_RO_SAMPLE, RO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_WRITE)
        else if(_sample_type inside {FD_WO_SAMPLE, WO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_READ)
        else
        `CREATE_OP_SAMPLE_COV(RAL_NONE)
        `CREATE_DESIRED_COV
        `CREATE_ACTUAL_COV
      end
      `endif

  endfunction

  `ifdef SLA_RAL_COVERAGE
  `CREATE_RAL_OP_COVERGROUP
  covergroup desired_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(RSVD, RSVD.desired)
     `RAL_FIELD_CP_2(RSVD, RSVD.desired, 0,1)
     `RAL_FIELD_CP(MSG_ADDR_L, MSG_ADDR_L.desired)
     `RAL_FIELD_CP_16(MSG_ADDR_L, MSG_ADDR_L.desired, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_14(MSG_ADDR_L, MSG_ADDR_L.desired, 16,17,18,19,20,21,22,23,24,25,26,27,28,29)
  endgroup
  covergroup actual_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(RSVD, RSVD.actual)
     `RAL_FIELD_CP_2(RSVD, RSVD.actual, 0,1)
     `RAL_FIELD_CP(MSG_ADDR_L, MSG_ADDR_L.actual)
     `RAL_FIELD_CP_16(MSG_ADDR_L, MSG_ADDR_L.actual, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_14(MSG_ADDR_L, MSG_ADDR_L.actual, 16,17,18,19,20,21,22,23,24,25,26,27,28,29)
  endgroup
  `endif

  // --------------------------
  // add constraint based on database legal values
  // --------------------------
  function void build();
    RSVD = new("RSVD", "RW", 2, 0, {""});
    RSVD.set_powerwell("vcccfn_gated");
    RSVD.set_rand_mode(0);
   RSVD.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( RSVD ));

    MSG_ADDR_L = new("MSG_ADDR_L", "RW", 30, 2, {""});
    MSG_ADDR_L.set_powerwell("vcccfn_gated");
    MSG_ADDR_L.set_rand_mode(0);
   MSG_ADDR_L.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( MSG_ADDR_L ));

  endfunction


`DEFINE_NONE_SCOPE_REG_API(hqm_msix_mem_bridge_MSG_ADDR_L_reg) 
endclass : hqm_msix_mem_bridge_MSG_ADDR_L_reg

// ================================================

class hqm_msix_mem_bridge_MSG_ADDR_U_reg extends sla_ral_reg;

  // --------------------------
  sla_ral_field MSG_ADDR_U;

  // --------------------------
  `ovm_object_utils(hqm_msix_mem_bridge_MSG_ADDR_U_reg)

  // --------------------------
  function new(
                string         name = "",
                `ifdef SLA_RAL_COVERAGE
                sla_ral_coverage_t cov_t = COVERAGE_OFF,
                `endif
                int            bus_num=0,
                int            dev_num=0,
                int            func_num=0,
                int            offset=0,
                int            size=0,
                sla_ral_data_t reset_val=0,
                boolean_t      mon_enabled = SLA_FALSE
             );
      super.new();
      set_space_addr("CFG",undef);
      set_space_addr("MEM",undef);
      set_space_addr("IO",undef);
      set_space_addr("MSG",undef);
      set_space_addr("CREG",undef); 
      set_space_addr("LT_MEM",undef);    
 build();

      `ifdef SLA_RAL_COVERAGE
      `CONFIG_RAL_COVERAGE(regname, COVERAGE_ON, FD_RW_SAMPLE)
      if(_coverage_type != COVERAGE_OFF) begin
        if(_sample_type inside {FD_RO_SAMPLE, RO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_WRITE)
        else if(_sample_type inside {FD_WO_SAMPLE, WO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_READ)
        else
        `CREATE_OP_SAMPLE_COV(RAL_NONE)
        `CREATE_DESIRED_COV
        `CREATE_ACTUAL_COV
      end
      `endif

  endfunction

  `ifdef SLA_RAL_COVERAGE
  `CREATE_RAL_OP_COVERGROUP
  covergroup desired_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(MSG_ADDR_U, MSG_ADDR_U.desired)
     `RAL_FIELD_CP_16(MSG_ADDR_U, MSG_ADDR_U.desired, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(MSG_ADDR_U, MSG_ADDR_U.desired, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  covergroup actual_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(MSG_ADDR_U, MSG_ADDR_U.actual)
     `RAL_FIELD_CP_16(MSG_ADDR_U, MSG_ADDR_U.actual, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(MSG_ADDR_U, MSG_ADDR_U.actual, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  `endif

  // --------------------------
  // add constraint based on database legal values
  // --------------------------
  function void build();
    MSG_ADDR_U = new("MSG_ADDR_U", "RW", 32, 0, {""});
    MSG_ADDR_U.set_powerwell("vcccfn_gated");
    MSG_ADDR_U.set_rand_mode(0);
   MSG_ADDR_U.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( MSG_ADDR_U ));

  endfunction


`DEFINE_NONE_SCOPE_REG_API(hqm_msix_mem_bridge_MSG_ADDR_U_reg) 
endclass : hqm_msix_mem_bridge_MSG_ADDR_U_reg

// ================================================

class hqm_msix_mem_bridge_MSG_DATA_reg extends sla_ral_reg;

  // --------------------------
  sla_ral_field MSG_DATA;

  // --------------------------
  `ovm_object_utils(hqm_msix_mem_bridge_MSG_DATA_reg)

  // --------------------------
  function new(
                string         name = "",
                `ifdef SLA_RAL_COVERAGE
                sla_ral_coverage_t cov_t = COVERAGE_OFF,
                `endif
                int            bus_num=0,
                int            dev_num=0,
                int            func_num=0,
                int            offset=0,
                int            size=0,
                sla_ral_data_t reset_val=0,
                boolean_t      mon_enabled = SLA_FALSE
             );
      super.new();
      set_space_addr("CFG",undef);
      set_space_addr("MEM",undef);
      set_space_addr("IO",undef);
      set_space_addr("MSG",undef);
      set_space_addr("CREG",undef); 
      set_space_addr("LT_MEM",undef);    
 build();

      `ifdef SLA_RAL_COVERAGE
      `CONFIG_RAL_COVERAGE(regname, COVERAGE_ON, FD_RW_SAMPLE)
      if(_coverage_type != COVERAGE_OFF) begin
        if(_sample_type inside {FD_RO_SAMPLE, RO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_WRITE)
        else if(_sample_type inside {FD_WO_SAMPLE, WO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_READ)
        else
        `CREATE_OP_SAMPLE_COV(RAL_NONE)
        `CREATE_DESIRED_COV
        `CREATE_ACTUAL_COV
      end
      `endif

  endfunction

  `ifdef SLA_RAL_COVERAGE
  `CREATE_RAL_OP_COVERGROUP
  covergroup desired_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(MSG_DATA, MSG_DATA.desired)
     `RAL_FIELD_CP_16(MSG_DATA, MSG_DATA.desired, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(MSG_DATA, MSG_DATA.desired, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  covergroup actual_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(MSG_DATA, MSG_DATA.actual)
     `RAL_FIELD_CP_16(MSG_DATA, MSG_DATA.actual, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(MSG_DATA, MSG_DATA.actual, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  `endif

  // --------------------------
  // add constraint based on database legal values
  // --------------------------
  function void build();
    MSG_DATA = new("MSG_DATA", "RW", 32, 0, {""});
    MSG_DATA.set_powerwell("vcccfn_gated");
    MSG_DATA.set_rand_mode(0);
   MSG_DATA.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( MSG_DATA ));

  endfunction


`DEFINE_NONE_SCOPE_REG_API(hqm_msix_mem_bridge_MSG_DATA_reg) 
endclass : hqm_msix_mem_bridge_MSG_DATA_reg

// ================================================

class hqm_msix_mem_bridge_VECTOR_CTRL_reg extends sla_ral_reg;

  // --------------------------
  sla_ral_field VEC_MASK;

  // --------------------------
  `ovm_object_utils(hqm_msix_mem_bridge_VECTOR_CTRL_reg)

  // --------------------------
  function new(
                string         name = "",
                `ifdef SLA_RAL_COVERAGE
                sla_ral_coverage_t cov_t = COVERAGE_OFF,
                `endif
                int            bus_num=0,
                int            dev_num=0,
                int            func_num=0,
                int            offset=0,
                int            size=0,
                sla_ral_data_t reset_val=0,
                boolean_t      mon_enabled = SLA_FALSE
             );
      super.new();
      set_space_addr("CFG",undef);
      set_space_addr("MEM",undef);
      set_space_addr("IO",undef);
      set_space_addr("MSG",undef);
      set_space_addr("CREG",undef); 
      set_space_addr("LT_MEM",undef);    
 build();

      `ifdef SLA_RAL_COVERAGE
      `CONFIG_RAL_COVERAGE(regname, COVERAGE_ON, FD_RW_SAMPLE)
      if(_coverage_type != COVERAGE_OFF) begin
        if(_sample_type inside {FD_RO_SAMPLE, RO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_WRITE)
        else if(_sample_type inside {FD_WO_SAMPLE, WO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_READ)
        else
        `CREATE_OP_SAMPLE_COV(RAL_NONE)
        `CREATE_DESIRED_COV
        `CREATE_ACTUAL_COV
      end
      `endif

  endfunction

  `ifdef SLA_RAL_COVERAGE
  `CREATE_RAL_OP_COVERGROUP
  covergroup desired_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(VEC_MASK, VEC_MASK.desired)
     `RAL_FIELD_CP_1(VEC_MASK, VEC_MASK.desired, 0)
  endgroup
  covergroup actual_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(VEC_MASK, VEC_MASK.actual)
     `RAL_FIELD_CP_1(VEC_MASK, VEC_MASK.actual, 0)
  endgroup
  `endif

  // --------------------------
  // add constraint based on database legal values
  // --------------------------
  function void build();
    VEC_MASK = new("VEC_MASK", "RW", 1, 0, {""});
    VEC_MASK.set_powerwell("vcccfn_gated");
    VEC_MASK.set_rand_mode(0);
   VEC_MASK.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( VEC_MASK ));

  endfunction


`DEFINE_NONE_SCOPE_REG_API(hqm_msix_mem_bridge_VECTOR_CTRL_reg) 
endclass : hqm_msix_mem_bridge_VECTOR_CTRL_reg

// ================================================

class hqm_msix_mem_bridge_HQM_MSIX_PBA_reg extends sla_ral_reg;

  // --------------------------
  sla_ral_field PENDING;

  // --------------------------
  `ovm_object_utils(hqm_msix_mem_bridge_HQM_MSIX_PBA_reg)

  // --------------------------
  function new(
                string         name = "",
                `ifdef SLA_RAL_COVERAGE
                sla_ral_coverage_t cov_t = COVERAGE_OFF,
                `endif
                int            bus_num=0,
                int            dev_num=0,
                int            func_num=0,
                int            offset=0,
                int            size=0,
                sla_ral_data_t reset_val=0,
                boolean_t      mon_enabled = SLA_FALSE
             );
      super.new();
      set_space_addr("CFG",undef);
      set_space_addr("MEM",undef);
      set_space_addr("IO",undef);
      set_space_addr("MSG",undef);
      set_space_addr("CREG",undef); 
      set_space_addr("LT_MEM",undef);    
 build();

      `ifdef SLA_RAL_COVERAGE
      `CONFIG_RAL_COVERAGE(regname, COVERAGE_ON, FD_RW_SAMPLE)
      if(_coverage_type != COVERAGE_OFF) begin
        if(_sample_type inside {FD_RO_SAMPLE, RO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_WRITE)
        else if(_sample_type inside {FD_WO_SAMPLE, WO_SAMPLE})
        `CREATE_OP_SAMPLE_COV(RAL_READ)
        else
        `CREATE_OP_SAMPLE_COV(RAL_NONE)
        `CREATE_DESIRED_COV
        `CREATE_ACTUAL_COV
      end
      `endif

  endfunction

  `ifdef SLA_RAL_COVERAGE
  `CREATE_RAL_OP_COVERGROUP
  covergroup desired_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(PENDING, PENDING.desired)
     `RAL_FIELD_CP_16(PENDING, PENDING.desired, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(PENDING, PENDING.desired, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  covergroup actual_cg @(cov_ev);
     option.per_instance = 1;
     option.name = {sla_ral_file::regfilename,".",regname};
     `RAL_FIELD_CP(PENDING, PENDING.actual)
     `RAL_FIELD_CP_16(PENDING, PENDING.actual, 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
     `RAL_FIELD_CP_16(PENDING, PENDING.actual, 16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)
  endgroup
  `endif

  // --------------------------
  // add constraint based on database legal values
  // --------------------------
  function void build();
    PENDING = new("PENDING", "RO/V", 32, 0, {""});
    PENDING.set_powerwell("vcccfn_gated");
    PENDING.set_rand_mode(0);
   PENDING.set_reset_signame("hqm_inp_gated_rst_n");
    void'(add_field( PENDING ));

  endfunction


`DEFINE_NONE_SCOPE_REG_API(hqm_msix_mem_bridge_HQM_MSIX_PBA_reg) 
endclass : hqm_msix_mem_bridge_HQM_MSIX_PBA_reg

// ================================================

class hqm_msix_mem_bridge_file extends sla_ral_file;

  rand hqm_msix_mem_bridge_MSG_ADDR_L_reg MSG_ADDR_L[65];
  rand hqm_msix_mem_bridge_MSG_ADDR_U_reg MSG_ADDR_U[65];
  rand hqm_msix_mem_bridge_MSG_DATA_reg MSG_DATA[65];
  rand hqm_msix_mem_bridge_VECTOR_CTRL_reg VECTOR_CTRL[65];
  rand hqm_msix_mem_bridge_HQM_MSIX_PBA_reg HQM_MSIX_PBA[3];

  `ovm_component_utils(hqm_msix_mem_bridge_file)

  function new(string n, ovm_component p);
    super.new(n,p);
  endfunction

  // --------------------------
  function void build();
    regfilename = this.get_name();

for (int i=0, int cnt=0; i<65; i++) begin
    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = $psprintf("MSG_ADDR_L[%0d]",i);
    `endif
    MSG_ADDR_L[i] = hqm_msix_mem_bridge_MSG_ADDR_L_reg::type_id::create($psprintf("MSG_ADDR_L[%0d]",i), this);
    MSG_ADDR_L[i].set_cfg(16'h0, 16'h0, 16'h0, (4'h0 + (i *16)), 32, 32'b00000000000000000000000000000000);
    MSG_ADDR_L[i].set_space_addr("MSG",  (4'h0 + (i*16)) );
    MSG_ADDR_L[i].set_space_addr("msg_bus_port", 'h21);
    MSG_ADDR_L[i].set_space_addr("MEM-SB", (4'h0 + (i*16)) );
    MSG_ADDR_L[i].set_space_addr("MEM",  (4'h0 + (i*16)) );
      MSG_ADDR_L[i].set_space("MEM");
      MSG_ADDR_L[i].set_msg_opcode("MEM-SB");
      MSG_ADDR_L[i].set_fid(4'h0, "MEM-SB");
  	MSG_ADDR_L[i].set_bar(4'h0, "MEM-SB");
      MSG_ADDR_L[i].set_user_attribute("diag_reg", "0");
      MSG_ADDR_L[i].set_user_attribute("HqmIsFeatureReg", "0");
      MSG_ADDR_L[i].set_user_attribute("SubnetPortID", "8'h00");
    if ( $test$plusargs($psprintf("MSG_ADDR_L[%0d]:dont_test",i)) ) MSG_ADDR_L[i].set_test_reg(1'b0);
      if (!add_reg( MSG_ADDR_L[i] )) begin
        `sla_error(get_name(), ($psprintf("Could not add register MSG_ADDR_L[%0d]",i)));
      end
   cnt++;
end

for (int i=0, int cnt=0; i<65; i++) begin
    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = $psprintf("MSG_ADDR_U[%0d]",i);
    `endif
    MSG_ADDR_U[i] = hqm_msix_mem_bridge_MSG_ADDR_U_reg::type_id::create($psprintf("MSG_ADDR_U[%0d]",i), this);
    MSG_ADDR_U[i].set_cfg(16'h0, 16'h0, 16'h0, (4'h4 + (i *16)), 32, 32'b00000000000000000000000000000000);
    MSG_ADDR_U[i].set_space_addr("MSG",  (4'h4 + (i*16)) );
    MSG_ADDR_U[i].set_space_addr("msg_bus_port", 'h21);
    MSG_ADDR_U[i].set_space_addr("MEM-SB", (4'h4 + (i*16)) );
    MSG_ADDR_U[i].set_space_addr("MEM",  (4'h4 + (i*16)) );
      MSG_ADDR_U[i].set_space("MEM");
      MSG_ADDR_U[i].set_msg_opcode("MEM-SB");
      MSG_ADDR_U[i].set_fid(4'h0, "MEM-SB");
  	MSG_ADDR_U[i].set_bar(4'h0, "MEM-SB");
      MSG_ADDR_U[i].set_user_attribute("diag_reg", "0");
      MSG_ADDR_U[i].set_user_attribute("HqmIsFeatureReg", "0");
      MSG_ADDR_U[i].set_user_attribute("SubnetPortID", "8'h00");
    if ( $test$plusargs($psprintf("MSG_ADDR_U[%0d]:dont_test",i)) ) MSG_ADDR_U[i].set_test_reg(1'b0);
      if (!add_reg( MSG_ADDR_U[i] )) begin
        `sla_error(get_name(), ($psprintf("Could not add register MSG_ADDR_U[%0d]",i)));
      end
   cnt++;
end

for (int i=0, int cnt=0; i<65; i++) begin
    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = $psprintf("MSG_DATA[%0d]",i);
    `endif
    MSG_DATA[i] = hqm_msix_mem_bridge_MSG_DATA_reg::type_id::create($psprintf("MSG_DATA[%0d]",i), this);
    MSG_DATA[i].set_cfg(16'h0, 16'h0, 16'h0, (4'h8 + (i *16)), 32, 32'b00000000000000000000000000000000);
    MSG_DATA[i].set_space_addr("MSG",  (4'h8 + (i*16)) );
    MSG_DATA[i].set_space_addr("msg_bus_port", 'h21);
    MSG_DATA[i].set_space_addr("MEM-SB", (4'h8 + (i*16)) );
    MSG_DATA[i].set_space_addr("MEM",  (4'h8 + (i*16)) );
      MSG_DATA[i].set_space("MEM");
      MSG_DATA[i].set_msg_opcode("MEM-SB");
      MSG_DATA[i].set_fid(4'h0, "MEM-SB");
  	MSG_DATA[i].set_bar(4'h0, "MEM-SB");
      MSG_DATA[i].set_user_attribute("diag_reg", "0");
      MSG_DATA[i].set_user_attribute("HqmIsFeatureReg", "0");
      MSG_DATA[i].set_user_attribute("SubnetPortID", "8'h00");
    if ( $test$plusargs($psprintf("MSG_DATA[%0d]:dont_test",i)) ) MSG_DATA[i].set_test_reg(1'b0);
      if (!add_reg( MSG_DATA[i] )) begin
        `sla_error(get_name(), ($psprintf("Could not add register MSG_DATA[%0d]",i)));
      end
   cnt++;
end

for (int i=0, int cnt=0; i<65; i++) begin
    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = $psprintf("VECTOR_CTRL[%0d]",i);
    `endif
    VECTOR_CTRL[i] = hqm_msix_mem_bridge_VECTOR_CTRL_reg::type_id::create($psprintf("VECTOR_CTRL[%0d]",i), this);
    VECTOR_CTRL[i].set_cfg(16'h0, 16'h0, 16'h0, (8'h0C + (i *16)), 32, 32'b00000000000000000000000000000001);
    VECTOR_CTRL[i].set_space_addr("MSG",  (8'h0C + (i*16)) );
    VECTOR_CTRL[i].set_space_addr("msg_bus_port", 'h21);
    VECTOR_CTRL[i].set_space_addr("MEM-SB", (4'hC + (i*16)) );
    VECTOR_CTRL[i].set_space_addr("MEM",  (8'h0C + (i*16)) );
      VECTOR_CTRL[i].set_space("MEM");
      VECTOR_CTRL[i].set_msg_opcode("MEM-SB");
      VECTOR_CTRL[i].set_fid(4'h0, "MEM-SB");
  	VECTOR_CTRL[i].set_bar(4'h0, "MEM-SB");
      VECTOR_CTRL[i].set_user_attribute("diag_reg", "0");
      VECTOR_CTRL[i].set_user_attribute("HqmIsFeatureReg", "0");
      VECTOR_CTRL[i].set_user_attribute("SubnetPortID", "8'h00");
    if ( $test$plusargs($psprintf("VECTOR_CTRL[%0d]:dont_test",i)) ) VECTOR_CTRL[i].set_test_reg(1'b0);
      if (!add_reg( VECTOR_CTRL[i] )) begin
        `sla_error(get_name(), ($psprintf("Could not add register VECTOR_CTRL[%0d]",i)));
      end
   cnt++;
end

    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = "HQM_MSIX_PBA[0]";
    `endif
    HQM_MSIX_PBA[0] = hqm_msix_mem_bridge_HQM_MSIX_PBA_reg::type_id::create("HQM_MSIX_PBA[0]", this);
    HQM_MSIX_PBA[0].set_reset_signame("hqm_inp_gated_rst_n powergood_rst_b"); 
    HQM_MSIX_PBA[0].set_cfg(16'h0, 16'h0, 16'h0, 16'h1000, 32, 32'b00000000000000000000000000000000);
    HQM_MSIX_PBA[0].set_space_addr("MSG", 16'h1000);
    HQM_MSIX_PBA[0].set_space_addr("msg_bus_port", 'h21);
    HQM_MSIX_PBA[0].set_space_addr("MEM-SB",16'h1000);
    HQM_MSIX_PBA[0].set_space_addr("MEM", 16'h1000);
      HQM_MSIX_PBA[0].set_space("MEM");
      HQM_MSIX_PBA[0].set_msg_opcode("MEM-SB");
      HQM_MSIX_PBA[0].set_fid(4'h0, "MEM-SB");
  	HQM_MSIX_PBA[0].set_bar(4'h0, "MEM-SB");
      HQM_MSIX_PBA[0].set_user_attribute("diag_reg", "0");
      HQM_MSIX_PBA[0].set_user_attribute("HqmIsFeatureReg", "0");
      HQM_MSIX_PBA[0].set_user_attribute("SubnetPortID", "8'h00");
      if ( $test$plusargs("HQM_MSIX_PBA[0]:dont_test") ) HQM_MSIX_PBA[0].set_test_reg(1'b0);
      if (!add_reg( HQM_MSIX_PBA[0] )) begin
        `sla_error(get_name(), ("Could not add register HQM_MSIX_PBA[0]"));
      end

    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = "HQM_MSIX_PBA[1]";
    `endif
    HQM_MSIX_PBA[1] = hqm_msix_mem_bridge_HQM_MSIX_PBA_reg::type_id::create("HQM_MSIX_PBA[1]", this);
    HQM_MSIX_PBA[1].set_reset_signame("hqm_inp_gated_rst_n powergood_rst_b"); 
    HQM_MSIX_PBA[1].set_cfg(16'h0, 16'h0, 16'h0, 16'h1004, 32, 32'b00000000000000000000000000000000);
    HQM_MSIX_PBA[1].set_space_addr("MSG", 16'h1004);
    HQM_MSIX_PBA[1].set_space_addr("msg_bus_port", 'h21);
    HQM_MSIX_PBA[1].set_space_addr("MEM-SB",16'h1004);
    HQM_MSIX_PBA[1].set_space_addr("MEM", 16'h1004);
      HQM_MSIX_PBA[1].set_space("MEM");
      HQM_MSIX_PBA[1].set_msg_opcode("MEM-SB");
      HQM_MSIX_PBA[1].set_fid(4'h0, "MEM-SB");
  	HQM_MSIX_PBA[1].set_bar(4'h0, "MEM-SB");
      HQM_MSIX_PBA[1].set_user_attribute("diag_reg", "0");
      HQM_MSIX_PBA[1].set_user_attribute("HqmIsFeatureReg", "0");
      HQM_MSIX_PBA[1].set_user_attribute("SubnetPortID", "8'h00");
      if ( $test$plusargs("HQM_MSIX_PBA[1]:dont_test") ) HQM_MSIX_PBA[1].set_test_reg(1'b0);
      if (!add_reg( HQM_MSIX_PBA[1] )) begin
        `sla_error(get_name(), ("Could not add register HQM_MSIX_PBA[1]"));
      end

    `ifdef SLA_RAL_COVERAGE
    sla_ral_reg::regname = "HQM_MSIX_PBA[2]";
    `endif
    HQM_MSIX_PBA[2] = hqm_msix_mem_bridge_HQM_MSIX_PBA_reg::type_id::create("HQM_MSIX_PBA[2]", this);
    HQM_MSIX_PBA[2].set_reset_signame("hqm_inp_gated_rst_n powergood_rst_b"); 
    HQM_MSIX_PBA[2].set_cfg(16'h0, 16'h0, 16'h0, 16'h1008, 32, 32'b00000000000000000000000000000000);
    HQM_MSIX_PBA[2].set_space_addr("MSG", 16'h1008);
    HQM_MSIX_PBA[2].set_space_addr("msg_bus_port", 'h21);
    HQM_MSIX_PBA[2].set_space_addr("MEM-SB",16'h1008);
    HQM_MSIX_PBA[2].set_space_addr("MEM", 16'h1008);
      HQM_MSIX_PBA[2].set_space("MEM");
      HQM_MSIX_PBA[2].set_msg_opcode("MEM-SB");
      HQM_MSIX_PBA[2].set_fid(4'h0, "MEM-SB");
  	HQM_MSIX_PBA[2].set_bar(4'h0, "MEM-SB");
      HQM_MSIX_PBA[2].set_user_attribute("diag_reg", "0");
      HQM_MSIX_PBA[2].set_user_attribute("HqmIsFeatureReg", "0");
      HQM_MSIX_PBA[2].set_user_attribute("SubnetPortID", "8'h00");
      if ( $test$plusargs("HQM_MSIX_PBA[2]:dont_test") ) HQM_MSIX_PBA[2].set_test_reg(1'b0);
      if (!add_reg( HQM_MSIX_PBA[2] )) begin
        `sla_error(get_name(), ("Could not add register HQM_MSIX_PBA[2]"));
      end

  endfunction

 virtual function void print_sv_ral_file();  
    $display("RAL File Type [%s], RAL File Instance [%s], SV File ---> %s", get_type_name(), get_name(), `__FILE__); 
 endfunction 
endclass : hqm_msix_mem_bridge_file

// ================================================


`endif
