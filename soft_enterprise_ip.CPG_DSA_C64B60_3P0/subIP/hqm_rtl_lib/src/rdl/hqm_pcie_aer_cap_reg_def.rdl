regfile hqm_pcie_aer_cap_rf {
	reg aer_cap_id_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Id";
		desc = "PCI Express AER Capability ID Register";
		regwidth = 16;
		shared;
                IntelRsvd = false;

		field {
			name = "Pcieaercid";
			desc = "Advanced Error Capability ID: PCI Express Extended Capability ID indicating Advanced Error Reporting Capability.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} PCIEAERCID [15:00] = 16'h0001;

	}; // end register ppcieaercapid

	reg aer_cap_version_next_ptr_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Version Next Ptr";
		desc = "PCI Express AER Capability ID Register";
		regwidth = 16;
		shared;
                IntelRsvd = false;

		field {
			name = "Cap Ptr";
			desc = "Next Capability Pointer";
			 PowerWell="vcccfn"; AccessType = "RO";
		} CAP_PTR [15:4] = 12'h000;

		field {
			name = "Pcieaercvn";
			desc = "Advanced Error Capability Version Number: PCI Express Advanced Error Reporting Extended Capability Version Number.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} PCIEAERCVN [3:0] = 4'h2;
	}; // end register ppcieaercapid

	reg aer_cap_uncorr_err_status_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Uncorr Err Status";
		desc = "PCI Express AER Uncorrectable Error Status Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved0";
			desc = "Reserved0:";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED0 [31:23] = 9'b0;

		field {
			name = "Ieunc";
			desc = "Uncorrectable Internal Error Status:";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} IEUNC [22:22] = 1'b0;

		field {
			name = "Reserved3";
			desc = "Reserved3";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED3 [21:21] = 1'b0;

		field {
			name = "Ur";
			desc = "Unsupported Request Error Status:  As a receiver, Set whenever an unsupported request is detected. The Header is logged.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} UR [20:20] = 1'b0;

		field {
			name = "Ecrcc";
			desc = "ECRC Check:  As a receiver, set when ECRC check fails. The Header is logged.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} ECRCC [19:19] = 1'b0;

		field {
			name = "Mtlp";
			desc = "Malformed TLP: As a receiver, set whenever a malformed TLP is detected. The Header is logged.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} MTLP [18:18] = 1'b0;

		field {
			name = "Ro";
			desc = "Receiver Overflow:  Set if PCI Express receive buffers overflow.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RO [17:17] = 1'b0;

		field {
			name = "Ec";
			desc = "Unexpected Completion:  As a receiver, set whenever a completion is received that does not match the requestor ID or outstanding Tag. The Header is logged.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} EC [16:16] = 1'b0;

		field {
			name = "Ca";
			desc = "Completer Abort:  As a completer, set whenever an internal agent signals a data abort. The header is logged.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} CA [15:15] = 1'b0;

		field {
			name = "Ct";
			desc = "Completion Timeout : As a requester, set whenever an outbound Non Posted Request does not receive a completion within 16-32ms.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} CT [14:14] = 1'b0;

		field {
			name = "Fcpes";
			desc = "Flow Control Protocol Error Status:  Set whenever a flow control protocol error is detected.Not supported.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} FCPES [13:13] = 1'b0;

		field {
			name = "Ptlpr";
			desc = "Poisoned TLP Received:  As a receiver, set whenever a poisoned TLP is received from PCI Express. The header is logged. Note that internal queue errors are not covered by this bit, they are logged by the Configuration target of the transaction.";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} PTLPR [12:12] = 1'b0;

		field {
			name = "Reserved1";
			desc = "Reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [11:6] = 6'b000000;

		field {
			name = "Sdes";
			desc = "Surprise Down Error:Not supported.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} SDES [5:5] = 1'b0;

		field {
			name = "Dlpe";
			desc = "Data Link Protocol Error:  Set whenever a data link protocol error is detected.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} DLPE [4:4] = 1'b0;

		field {
			name = "Reserved2";
			desc = "Reserved";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED2 [03:00] = 4'h0;

	}; // end register ppaerucs

	reg aer_cap_uncorr_err_mask_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Uncorr Err Mask";
		desc = "PCI Express AER Uncorrectable Error Mask Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved0";
			desc = "Reserved0";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED0 [31:23] = 9'h0;

		field {
			name = "Ieunc";
			desc = "Uncorrectable Internal Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} IEUNC [22:22] = 1'b1;

		field {
			name = "Reserved3";
			desc = "Reserved3";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED3 [21:21] = 1'b0;

		field {
			name = "Ur";
			desc = "Unsupported Request Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} UR [20:20] = 1'b0;

		field {
			name = "Ecrcc";
			desc = "ECRC Check Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} ECRCC [19:19] = 1'b0;

		field {
			name = "Mtlp";
			desc = "Malformed TLP Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} MTLP [18:18] = 1'b0;

		field {
			name = "Ro";
			desc = "Receiver Overflow Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RO [17:17] = 1'b0;

		field {
			name = "Ec";
			desc = "Unexpected Completion Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} EC [16:16] = 1'b0;

		field {
			name = "Ca";
			desc = "Completer Abort Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} CA [15:15] = 1'b0;

		field {
			name = "Ct";
			desc = "Completion Time Out Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} CT [14:14] = 1'b0;

		field {
			name = "Fcpes";
			desc = "Flow Control Protocol Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.Not supported.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} FCPES [13:13] = 1'b0;

		field {
			name = "Ptlpr";
			desc = "Poisoned TLP Received Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} PTLPR [12:12] = 1'h0;

		field {
			name = "Reserved1";
			desc = "Reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [11:6] = 6'h0;

		field {
			name = "Sdes";
			desc = "Surprise Down Error:Not supported.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} SDES [5:5] = 1'b0;

		field {
			name = "Dlpe";
			desc = "Data Link Protocol Error Mask : When ÃƒÂ¢Ã¢â€šÂ¬Ã‹Å“1ÃƒÂ¢Ã¢â€šÂ¬Ã¢â€žÂ¢ error reporting is masked.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} DLPE [4:4] = 1'b0;

		field {
			name = "Reserved2";
			desc = "Reserved2";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED2 [03:00] = 4'h0;

	}; // end register ppaerucm

	reg aer_cap_uncorr_err_sev_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Uncorr Err Sev";
		desc = "PCI Express AER Uncorrectable Error Severity Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved0";
			desc = "reserved0";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED0 [31:23] = 9'h0;

		field {
			name = "Ieunc";
			desc = "Uncorrectable Internal Error status sevirity";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} IEUNC [22:22] = 1'b1;

		field {
			name = "Reserved3";
			desc = "Reserved3";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED3 [21:21] = 1'b0;

		field {
			name = "Ur";
			desc = "unsupported request error status severity(uress):";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} UR [20:20] = 1'b0;

		field {
			name = "Ecrcc";
			desc = "ecrc check severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} ECRCC [19:19] = 1'b0;

		field {
			name = "Mtlp";
			desc = "malformed tlp severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} MTLP [18:18] = 1'b1;

		field {
			name = "Ro";
			desc = "receiver overflow severity:Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} RO [17:17] = 1'b0;

		field {
			name = "Ec";
			desc = "unexpected completion severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} EC [16:16] = 1'b0;

		field {
			name = "Ca";
			desc = "completer abort severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} CA [15:15] = 1'b0;

		field {
			name = "Ct";
			desc = "completion time out severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} CT [14:14] = 1'b0;

		field {
			name = "Fcpes";
			desc = "flow control protocol error severity:not supported.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} FCPES [13:13] = 1'b0;

		field {
			name = "Ptlpr";
			desc = "poisoned tlp received severity:";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} PTLPR [12:12] = 1'h0;

		field {
			name = "Reserved1";
			desc = "reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [11:6] = 6'h0;

		field {
			name = "Sdes";
			desc = "surprise down error severity:not supported.Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} SDES [5:5] = 1'h0;

		field {
			name = "Dlpe";
			desc = "data link protocol error severity:Not applicable for IOSF.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} DLPE [4:4] = 1'h0;

		field {
			name = "Reserved2";
			desc = "reserved2";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED2 [03:00] = 4'h0;

	}; // end register ppaerucsev

	reg aer_cap_corr_err_status_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Corr Status Err";
		desc = "PCI Express AER Correctable Error Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved0";
			desc = "Reserved0";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED0 [31:15] = 17'h0;

		field {
			name = "Iecor";
			desc = "Corrected Internal Error Status";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} IECOR [14:14] = 1'b0;

		field {
			name = "Anfes";
			desc = "Advisory Non Fatal Error status";
			 PowerWell="vcccfn"; AccessType = "RW/1C/V/P";
		} ANFES [13:13] = 1'b0;

		field {
			name = "Rtts";
			desc = "Replay Timer Timeout Status : Set whenever a replay timer timeout occurs.Not supported since HQM is an IOSF device.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RTTS [12:12] = 1'b0;

		field {
			name = "Reserved1";
			desc = "Reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [11:09] = 3'b0;

		field {
			name = "Rnrs";
			desc = "REPLAY NUM Rollover Status : Set whenever the replay number rolls over from 11 to 00.Not supported since HQM is an IOSF device.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RNRS [8:8] = 1'h0;

		field {
			name = "Bdllps";
			desc = "Bad DLLP Status : Sets this bit on CRC errors on DLLP.Not supported since HQM is an IOSF device.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} BDLLPS [7:7] = 1'b0;

		field {
			name = "Dlpe";
			desc = "Bad TLP Status : Sets this bit on CRC errors or sequence number out of range on TLP.Not supported since HQM is an IOSF device.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} DLPE [6:6] = 1'b0;

		field {
			name = "Reserved2";
			desc = "Reserved2";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED2 [05:01] = 5'h0;

		field {
			name = "Res";
			desc = "Receiver Error Status : Set whenever the physical layer detects a receiver error.Not supported since HQM is an IOSF device.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RES [00:00] = 1'b0;

	}; // end register ppaercs

	reg aer_cap_corr_err_mask_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Corr Err Mask";
		desc = "PCI Express AER Correctable Error Mask Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved0";
			desc = "Reserved0";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED0 [31:15] = 17'h0;

		field {
			name = "Iecor";
			desc = "Corrected Internal Error Status";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} IECOR [14:14] = 1'b1;

		field {
			name = "Anfes";
			desc = "Advisory Non-Fatal Error Mask : this bit is set by default to enable compatibility with software that does not comprehend Role-Based Error Reporting.";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} ANFES [13:13] = 1'b1;

		field {
			name = "Rtts";
			desc = "Replay Timer Timeout MaskNot supported since HQM is an IOSF device";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RTTS [12:12] = 1'b0;

		field {
			name = "Reserved1";
			desc = "Reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [11:09] = 3'h0;

		field {
			name = "Rnrs";
			desc = "REPLAY NUM Rollover Mask:Not supported since HQM is an IOSF device";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} RNRS [8:8] = 1'b0;

		field {
			name = "Bdllps";
			desc = "Bad DLLP Mask:Not supported since HQM is an IOSF device";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} BDLLPS [7:7] = 1'b0;

		field {
			name = "Dlpe";
			desc = "Bad TLP Mask:Not supported since HQM is an IOSF device";
			 PowerWell="vcccfn"; AccessType = "RW/P";
		} DLPE [6:6] = 1'b0;

		field {
			name = "Reserved2";
			desc = "Reserved2";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED2 [05:01] = 5'h0;

		field {
			name = "Res";
			desc = "Receiver Error Mask:Not supported since HQM is an IOSF device";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RES [00:00] = 1'b0;

	}; // end register ppaercm

	reg aer_cap_control_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Control";
		desc = "PCI Express AER Control and Capability Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Reserved1";
			desc = "Reserved1";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED1 [31:12] = 20'h0;

		field {
			name = "Tlppflogp";
			RTLUseStar="FLOP";
			desc = "TLP Prefix Log Present:  If set, indicates the presence of a valid TLP Prefix Log entry.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} TLPPFLOGP [11:11] = 1'b0;

		field {
			name = "Reserved";
			desc = "Reserved0";
			 PowerWell="vcccfn"; AccessType = "RO";
		} RESERVED [10:10] = 1'b0;

		field {
			name = "Multhdrrc";
			desc = "Multiple Header Recording Capable : We do not support recording multiple error headers, so this bit is hard-wired to 0.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} Multhdrrc [9:9] = 1'b0;

		field {
			name = "Ecrcce";
			desc = "ECRC Check Enable : We do not support ECRC checking, so this bit is hard-wired to 0.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} ECRCCE [8:8] = 1'b0;

		field {
			name = "Ecrccc";
			desc = "ECRC Check Capable : Indicates EP is not capable of checking ECRC.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} ECRCCC [7:7] = 1'b0;

		field {
			name = "Ecrcge";
			desc = "ECRC Generation Enable : We do not support ECRC generation, so this bit is hard-wired to 0.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} ECRCGE [6:6] = 1'b0;

		field {
			name = "Ecrcgc";
			desc = "ECRC Generation Capable : Indicates the EP is not capable of generating ECRC.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} ECRCGC [5:5] = 1'b0;

		field {
			name = "Tfep";
			RTLUseStar="FLOP";
			desc = "The First Error Pointer:  Identifies the bit position of the first error reported in theThis register will not update until all bits in the ERRUNC STS register are cleared.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} TFEP [04:00] = 5'b00000;

	}; // end register ppaerctlcap

	reg aer_cap_header_log_0_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Header Log_0";
		desc = "PCI Express AER Header Log 0 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Hdrlogdw0";
			RTLUseStar="FLOP";
			desc = "1st DWord of the Header for the PCI Express packet in error (HDRLOGDW0): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} HDRLOGDW0 [31:00] = 32'h0;

	}; // end register ppaerhdrlog0

	reg aer_cap_header_log_1_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Header Log_1";
		desc = "PCI Express AER Header Log 1 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Hdrlogdw1";
			RTLUseStar="FLOP";
			desc = "2nd DWord of the Header for the PCI Express packet in error (HDRLOGDW1): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} HDRLOGDW1 [31:00] = 32'h0;

	}; // end register ppaerhdrlog1

	reg aer_cap_header_log_2_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Header Log_2";
		desc = "PCI Express AER Header Log 2 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Hdrlogdw2";
			RTLUseStar="FLOP";
			desc = "3rd DWord of the Header for the PCI Express packet in error (HDRLOGDW2): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} HDRLOGDW2 [31:00] = 32'h0;

	}; // end register ppaerhdrlog2

	reg aer_cap_header_log_3_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Header Log_3";
		desc = "PCI Express AER Header Log 3 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Hdrlogdw3";
			RTLUseStar="FLOP";
			desc = "4th DWord of the Header for the PCI Express packet in error (HDRLOGDW3): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} HDRLOGDW3 [31:00] = 32'h0;

	}; // end register ppaerhdrlog3

    reg aer_cap_root_error_command_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Root Error Command";
		desc = "PCI Express AER Root Error Command Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;
		field {
			name = "FERE";
			desc = "Fatal Error Reporting Enable - When Set, this bit enables the generation of an interrupt when a fatal error is reported by any of the Functions in the Hierarchy Domain associated with this Root Port.";
            PowerWell="vcccfn"; AccessType = "RO";
		} FERE [2:2] = 1'h0;
		field {
			name = "NERE";
			desc = "Non-Fatal Error Reporting Enable - When Set, this bit enables the generation of an interrupt when a non-fatal error is reported by any of the Functions in the Hierarchy Domain associated with this Root Port.";
            PowerWell="vcccfn"; AccessType = "RO";
		} NERE [1:1] = 1'h0;
		field {
			name = "CERE";
			desc = "Correctable Error Reporting Enable - When Set, this bit enables the generation of an interrupt when a correctable error is reported by any of the Functions in the Hierarchy Domain associated with this Root Port.";
            PowerWell="vcccfn"; AccessType = "RO";
		} CERE [0:0] = 1'h0;

	}; // end register aer_cap_root_error_command

    reg aer_cap_root_error_status_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Root Error Status";
		desc = "PCI Express AER Root Error Status Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "AEIMN";
			desc = "Advanced Error Interrupt Message Number - This register indicates which MSI/MSI-X vector is used for the interrupt message generated in association with any of the status bits of this capability";

            PowerWell="vcccfn"; AccessType = "RO";
		} AEIMN [31:27] = 5'h00;
		field {
			name = "FER";
			desc = "Fatal Error Received - Set when a ERR_FATAL error message is received";
            PowerWell="vcccfn"; AccessType = "RO";
		} FER [6:6] = 1'h0;
		field {
			name = "NER";
			desc = "Non-Fatal Error Received - Set when a ERR_NONFATAL error message is received";
            PowerWell="vcccfn"; AccessType = "RO";
		} NER [5:5] = 1'h0;
		field {
			name = "FUF";
			desc = "Set when the first uncorrectable error message received is for a fatal error";
            PowerWell="vcccfn"; AccessType = "RO";
		} FUF [4:4] = 1'h0;
		field {
			name = "MFNER";
			desc = "Multiple Fatal or Non-Fatal Errors Received - Set when a ERR_FATAL or ERR_NONFATAL error message is received and FNER is already set";
            PowerWell="vcccfn"; AccessType = "RO";
		} MFNER [3:3] = 1'h0;
		field {
			name = "FNER";
			desc = "Fatal or Non-Fatal Error Received - Set when a ERR_FATAL or ERR_NONFATAL error message is received";
            PowerWell="vcccfn"; AccessType = "RO";
		} FNER [2:2] = 1'h0;
		field {
			name = "MCER";
			desc = "Multiple Correctable Errors Received - Set when a ERR_COR error message is received and CER is already set";
            PowerWell="vcccfn"; AccessType = "RO";
		} MCER [1:1] = 1'h0;
		field {
			name = "CER";
			desc = "Correctable Error Received - Set when a ERR_COR error message is received";
            PowerWell="vcccfn"; AccessType = "RO";
		} CER [0:0] = 1'h0;

	}; // end register aer_cap_root_error_status

    reg aer_cap_error_source_ident_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Error Source Identification";
		desc = "PCI Express AER Error Source Identification Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "FNSID";
			desc = "ERR_FATAL/NONFATAL Source Identification - Loaded with the Requester ID indicated in the received ERR_FATAL or ERR_NONFATAL Message when the ERR_FATAL/NONFATAL Received bit is not already set";
            PowerWell="vcccfn"; AccessType = "RO";
		} FNSID [31:16] = 16'h0000;
		field {
			name = "CSID";
			desc = "ERR_COR Source Identification - Loaded with the Requester ID indicated in the received ERR_COR Message when the ERR_COR Received bit is not already set";
            PowerWell="vcccfn"; AccessType = "RO";
		} CSID [15:0] = 16'h0000;

	}; // end register aer_cap_error_source_ident

	reg aer_cap_tlp_prefix_log_0_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Tlp Prefix Log_0";
		desc = "PCI Express AER TLP Prefix Log 0 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Tlppflog0";
			RTLUseStar="FLOP";
			desc = "1st TLP Prefix for the PCI Express packet in error (TLPPFLOG0): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO/V/P";
		} TLPPFLOG0 [31:00] = 32'h0;

	}; // end register ppaertlppflog0

	reg aer_cap_tlp_prefix_log_1_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Tlp Prefix Log_1";
		desc = "PCI Express AER TLP Prefix Log 1 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Tlppflog1";
			desc = "2nd TLP Prefix for the PCI Express packet in error (TLPPFLOG1): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} TLPPFLOG1 [31:00] = 32'h0;

	}; // end register ppaertlppflog1

	reg aer_cap_tlp_prefix_log_2_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Tlp Prefix Log_2";
		desc = "PCI Express AER TLP Prefix Log 2 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Tlppflog2";
			desc = "3rd TLP Prefix for the PCI Express packet in error (TLPPFLOG2): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} TLPPFLOG2 [31:00] = 32'h0;

	}; // end register ppaertlppflog2

	reg aer_cap_tlp_prefix_log_3_r {
  HqmClassification="PCI_CFG_REG_NA_1";

		name = "Aer Cap Tlp Prefix Log_3";
		desc = "PCI Express AER TLP Prefix Log 3 Register";
		regwidth = 32;
		shared;
                IntelRsvd = false;

		field {
			name = "Tlppflog3";
			desc = "4th TLP Prefix for the PCI Express packet in error (TLPPFLOG3): Once an error is logged in this register, it remains locked for further error logging until the time the software clears the status bit that cause the header log i.e. the error pointer is rearmed to log again.";
			 PowerWell="vcccfn"; AccessType = "RO";
		} TLPPFLOG3 [31:00] = 32'h0;

	}; // end register ppaertlppflog1

	// Instance PF Registers

	aer_cap_id_r                    AER_CAP_ID @0x0;

	aer_cap_version_next_ptr_r      AER_CAP_VERSION_NEXT_PTR        @0x2;

	aer_cap_uncorr_err_status_r     AER_CAP_UNCORR_ERR_STATUS       @0x4;

	aer_cap_uncorr_err_mask_r       AER_CAP_UNCORR_ERR_MASK         @0x8;

	aer_cap_uncorr_err_sev_r        AER_CAP_UNCORR_ERR_SEV          @0xc;

	aer_cap_corr_err_status_r       AER_CAP_CORR_ERR_STATUS         @0x10;

	aer_cap_corr_err_mask_r         AER_CAP_CORR_ERR_MASK           @0x14;

	aer_cap_control_r               AER_CAP_CONTROL                 @0x18;

	aer_cap_header_log_0_r          AER_CAP_HEADER_LOG_0            @0x1c;

	aer_cap_header_log_1_r          AER_CAP_HEADER_LOG_1            @0x20;

	aer_cap_header_log_2_r          AER_CAP_HEADER_LOG_2            @0x24;

	aer_cap_header_log_3_r          AER_CAP_HEADER_LOG_3            @0x28;

    aer_cap_root_error_command_r    AER_CAP_ROOT_ERROR_COMMAND      @0x2c;

    aer_cap_root_error_status_r     AER_CAP_ROOT_ERROR_STATUS       @0x30;

    aer_cap_error_source_ident_r    AER_CAP_ERROR_SOURCE_IDENT      @0x34;

	aer_cap_tlp_prefix_log_0_r      AER_CAP_TLP_PREFIX_LOG_0        @0x38;

	aer_cap_tlp_prefix_log_1_r      AER_CAP_TLP_PREFIX_LOG_1        @0x3c;

	aer_cap_tlp_prefix_log_2_r      AER_CAP_TLP_PREFIX_LOG_2        @0x40;

	aer_cap_tlp_prefix_log_3_r      AER_CAP_TLP_PREFIX_LOG_3        @0x44;

};

