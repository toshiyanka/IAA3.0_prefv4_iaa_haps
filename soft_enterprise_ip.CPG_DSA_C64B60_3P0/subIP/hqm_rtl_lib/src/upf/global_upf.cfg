##################################################################################################
## This global UPF config must be present in every UPF repo
## The user controlled variable space should be used as it applies to the design and process tech
## Variables are defined as constants which prevents values from changing once set
##################################################################################################

if {[llength [info procs ::__global_config_trace_proc_must_not_be_redefined]] < 1} {
    ##################################################################################################
    ## DO NOT EDIT ANY CODE IN THIS SECTION
    ##################################################################################################
    proc ::__global_config_trace_proc_must_not_be_redefined {val name1 name2 ops} {
        upvar #0 $name1 var
        if {$ops eq {w}} {
            puts "global_upf.cfg: global variable $name1=$val is read-only"
        }
        set var $val
    }
     proc ::__constant {varName value} {
        uplevel #0 [list trace variable $varName rw [list ::__global_config_trace_proc_must_not_be_redefined $value]]
        puts "global_upf.cfg: setting global variable $varName=[set $varName] to read-only"
    }
    proc ::constant {varName value} {
        ::__constant ::$varName $value
        lappend ::__global_config_constants_user_controlled $varName
    }
}

if { !([info exists ::GLOBAL_CONFIG_LOADED] && $::GLOBAL_CONFIG_LOADED) } {

    ##################################################################################################
    ## The user controlled constant variable space below must be used and defined accordingly
    ##################################################################################################

    if {[info exists ::env(ONECFG_cust)] && ($::env(ONECFG_cust) eq {GRR76})} {
      ::constant  PS_CELL             "g1mpsw002tc1q03x5"
    } else {
      ::constant  PS_CELL             "ec0psbf20nc1q04x5"
    }
    ::constant  PS_CELL_UNGATED_IN  "vcc_in"
    ::constant  PS_CELL_GATED_OUT   "gtdout"
    ::constant  PS_CELL_ENABLE      "a"
    ::constant  PS_CELL_ENABLE2     "b"
    ::constant  PS_CELL_ACK         "bout"

    ::constant  RETENTION_CELL_MAP             "<list>"
    ::constant  DOUBLESYNC_RETENTION_CELL_MAP  "<list>"

    ::constant  VCC_SUPPLY_HV    0.85
    ::constant  VCC_SUPPLY_LV    0.65
    ::constant  VCC_SUPPLY_VRET  0.30
    ::constant  VCC_BIAS         0.65
    ::constant  VSS_GROUND       0.0
    ::constant  SOC_GROUND_NOM   $::VSS_GROUND

    ##################################################################################################################################
    ## The tool variables should be used in the  UPF as it applies to the design and in accordance with the guidance in the templates
    ## DO NOT EDIT ANY CODE BELOW
    ## DO NOT DIRECTLY CONTROL, MODIFY, or OVERRIDE TOOL VARIABLES BELOW
    ## DO NOT CREATE IP SPECIFIC or SoC SPECIFIC VARIABLES THAT FUNCTION LIKE THE SET BELOW
    ##################################################################################################################################

    ::__constant ::__global_config_variables_protected [list \
        IP_ENABLE_ALL                                        \
       CSN_ENABLE_ALL                                        \
    ]

    foreach v $::__global_config_variables_protected { if {![info exists ::$v]} {set ::$v 1} elseif {![set ::$v]} {unset ::$v} }

    ### Set global configs for tool/flow identification
    ### Default condition would be set to SYN
    ::__constant ::__global_config_constants_protected [list \
        __SIM                                                \
        __ERC                                                \
        __FEV                                                \
        __PV                                                 \
        __SYN                                                \
        __EMU                                                \
        __FPGA                                               \
        __UPF_EXTENSION                                      \
        __WELL_BIAS                                          \
    ]

    # initialize __<var> to 0
    foreach c $::__global_config_constants_protected {set $c 0}
    set ::program_name ""
    if { [info exists ::synopsys_program_name] } {
	set ::program_name $::synopsys_program_name;
	if { $::program_name eq "vcs" } {
            set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::program_name=$::program_name"
	} elseif { $::program_name eq "vcst" } {
	    set __ERC 1
            puts "global_upf.cfg: setting ::__ERC=$__ERC, since ::program_name=$::program_name"
	} elseif { $::program_name eq "fm_shell" } {
	    set __FEV 1
            puts "global_upf.cfg: setting ::__FEV=$__FEV, since ::program_name=$::program_name"
        } elseif { $::program_name eq   "pt_shell" } {
	    set __PV 1
            puts "global_upf.cfg: setting ::__PV=$__PV, since ::program_name=$::program_name"
	} elseif { ($::program_name eq   "dc_shell") \
		       || ($::program_name eq   "de_shell") \
		       || ($::program_name eq  "icc_shell") \
		       || ($::program_name eq "icc2_shell") \
		       || ($::program_name eq  "rtl_shell") \
		       || ($::program_name eq   "fc_shell") } {
	    set __SYN 1
            puts "global_upf.cfg: setting ::__SYN=$__SYN, since ::program_name=$::program_name"
        } else {
            puts "global_upf.cfg: ::synopsys_program_name=$::program_name is not recognized"
        }
    } elseif { [info exists ::upf_tool] } {
	set ::program_name $::upf_tool
	if { $::program_name eq "QUESTA"} {
	    set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::program_name=$::program_name"
	}
    } elseif { [array exists ::lec_cmd_array] && [array exists ::ntcl_ccd_cmd_array] } {
	set ::program_name "conformal"
	set __FEV 1
        puts "global_upf.cfg: setting ::__FEV=$__FEV, since ::program_name=$::program_name"
    } elseif { [info commands get_db] ne "" } {
	set ::program_name [get_db program_short_name]
	if { ($::program_name == "genus") \
		 || ($::program_name == "innovus") } {
	    set __SYN 1
	    puts "global_upf.cfg: setting ::__SYN=$__SYN, since ::program_name=$::program_name"
	} elseif { $::program_name == "tempus" } {
	    set __PV 1
	    puts "global_upf.cfg: setting ::__PV=$__PV, since ::program_name=$::program_name"
	}
   } else {
	if { [info nameofexecutable] == "xmelab"} {
	    set ::program_name "xcelium"
	    set __SIM 1
	    puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::program_name=$::program_name"
	}
    }

    if { [info exists ::env(INTEL_EMULATION)] } {
        set __EMU $::env(INTEL_EMULATION)
        puts "global_upf.cfg: setting ::__EMU=$__EMU, since ::env(INTEL_EMULATION)=$::env(INTEL_EMULATION)"
        if { $::env(INTEL_EMULATION) } {
            set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::env(INTEL_EMULATION)=$::env(INTEL_EMULATION)"
        }
    }

    if { [info exists ::env(EMULATION_UPF)] } {
        set __EMU $::env(EMULATION_UPF)
        puts "global_upf.cfg: setting ::__EMU=$__EMU, since ::env(EMULATION_UPF)=$::env(EMULATION_UPF)"
        if { $::env(EMULATION_UPF) } {
            set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::env(EMULATION_UPF)=$::env(EMULATION_UPF)"
        }
    }

    if { [info exists ::env(INTEL_FPGA)] } {
        set __FPGA $::env(INTEL_FPGA)
        puts "global_upf.cfg: setting ::__FPGA=$__FPGA, since ::env(INTEL_FPGA)=$::env(INTEL_FPGA)"
        if { $::env(INTEL_FPGA) } {
            set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::env(INTEL_FPGA)=$::env(INTEL_FPGA)"
        }
    }

    if { [info exists ::env(FPGA_UPF)] } {
        set __FPGA $::env(FPGA_UPF)
        puts "global_upf.cfg: setting ::__FPGA=$__FPGA, since ::env(FPGA_UPF)=$::env(FPGA_UPF)"
        if { $::env(FPGA_UPF) } {
            set __SIM 1
            puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::env(FPGA_UPF)=$::env(FPGA_UPF)"
        }
    }

    if { [info exists ::env(SIM_UPF)] } {
        set __SIM $::env(SIM_UPF)
        puts "global_upf.cfg: setting ::__SIM=$__SIM, since ::env(SIM_UPF)=$::env(SIM_UPF)"
    }

    if { [info exists ::env(ERC_UPF)] } {
        set __ERC $::env(ERC_UPF)
        puts "global_upf.cfg: setting ::__ERC=$__ERC, since ::env(ERC_UPF)=$::env(ERC_UPF)"
    }

    if { [info exists ::env(FEV_UPF)] } {
        set __FEV $::env(FEV_UPF)
        puts "global_upf.cfg: setting ::__FEV=$__FEV, since ::env(FEV_UPF)=$::env(FEV_UPF)"
    }

    if { [info exists ::env(PV_UPF)] } {
        set __PV $::env(PV_UPF)
        puts "global_upf.cfg: setting ::__PV=$__PV, since ::env(PV_UPF)=$::env(PV_UPF)"
    }

    if { [info exists ::env(SYN_UPF)] } {
        set __SYN $::env(SYN_UPF)
        puts "global_upf.cfg: setting ::__SYN=$__SYN, since ::env(SYN_UPF)=$::env(SYN_UPF)"
    }

    if { [info exists ::env(WELL_BIAS_UPF)] } {
        set __WELL_BIAS $::env(WELL_BIAS_UPF)
        puts "global_upf.cfg: setting ::__WELL_BIAS=$__WELL_BIAS, since ::env(WELL_BIAS_UPF)=$::env(WELL_BIAS_UPF)"
    }

    if { [info exists ::upf_extension] && $::upf_extension } {
        set __UPF_EXTENSION 1
        puts "global_upf.cfg: setting ::__UPF_EXTENSION=$__UPF_EXTENSION, since ::upf_extension=$::upf_extension"
    }

    # define __<var> as ::__<var> constant
    foreach c $::__global_config_constants_protected {::__constant ::$c [set $c]}

    set ::GLOBAL_CONFIG_LOADED 1

}

if { !([info exists GLOBAL_CONFIG_LOADED] && $GLOBAL_CONFIG_LOADED) } {
    # set __<var> to $::__<var>, if __<var> does not already exist, so ::__<var> and __<var> is available for use
    foreach v $::__global_config_variables_protected { if {[info exists ::$v]} {set $v [set ::$v]} elseif {[info exists $v]} {unset $v} }
    foreach c [concat $::__global_config_constants_user_controlled $::__global_config_constants_protected] {::__constant $c [set ::$c]}
    set GLOBAL_CONFIG_LOADED 1
}
