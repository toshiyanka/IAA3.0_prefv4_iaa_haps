#!/usr/intel/bin/perl -w

use strict;
use warnings;
use Getopt::Long;
use SIP::SBN::API;
use Pod::Usage;

$main::date = "Dec 19, 2011";
$main::toolname = "xml2tcl";
$main::version = "1.0";

$main::agents = 0;

parseCmdLine();

$main::API = new SIP::SBN::API($main::xmlfile);

#$main::API->readParams();
$main::API->validate();

# hash of routers
%main::rtrs = ();

%main::eps = ();

%main::parms = (
   'NPorts'    => {
                 'xml' => 'Number of Nodes',
                 'tcl' => 'NUMPORT_F'
                  },
   'LBQ'       => {
                 'xml' => 'Latch Based Queues',
                 'tcl' => 'LatchBasedQ',
                 'def' => '0'
                  },
   'IntBWdth'  => {
                 'xml' => 'Internal Byte Width',
                 'tcl' => 'INTERNALWIDTH',
                 'def' => '8',
                 'mult' => '8'
                  },
   'ExtBWdth'  => {
                 'xml' => 'External Byte Width',
                 'tcl' => 'EXTERNALWIDTH',
                 'def' => '8',
                 'mult' => '8'
                  },
   'PipeArb'   => {
                 'xml' => 'Pipelined Arbiter?',
                 'tcl' => 'PipeArb',
                 'def' => '0'
                  },
   'FastArb'   => {
                 'xml' => 'Fast Pend2IP Arbiter?',
                 'tcl' => 'FastP2IPArb',
                 'def' => '0'
                  },
   'NOA'       => {
                 'xml' => 'NOA Dest Prefix',
                 'tcl' => 'NOADestPref',
                 'def' => 'visa'
                  },
   'REG'       => {
                 'xml' => 'REG Src Prefix',
                 'tcl' => 'RegSrcPref',
                 'def' => 'cfg'
                  },
   'PLByteW'   => {
                 'xml' => 'Payload Byte Width',
                 'tcl' => 'PAYLOADBYTEWIDTH',
                 'def' => '1',
                 'mult' => '8'
                  },
   'NPCRED'   => {
                 'xml' => 'NP Credit Buffer',
                 'tcl' => 'NPCREDITBUFFER',
                 'def' => '2'
                  },
   'PCCRED'   => {
                 'xml' => 'PC Credit Buffer',
                 'tcl' => 'PCCREDITBUFFER',
                 'def' => '2'
                  },
   'IngQDpth'  => {
                 'xml' => 'Ingress Queue Depth',
                 'tcl' => 'INGRESSQDEPTH',
                 'def' => '2'
                  }
);

my $tclfile = "test.tcl";
my $design = "TestDesign";
if( $main::xmlfile =~ /(\w+)\.xml/ ) {
   $tclfile = $1 . ".tcl";
   $design = $1;
}
print "INFO: Generating $tclfile\n";
my $date = `date`;
open $main::outf, ">$tclfile";
my $file = __FILE__;

printf $main::outf "##########################\n";
printf $main::outf "#\n";
printf $main::outf "# FILENAME : $tclfile\n";
printf $main::outf "# DATE : $date";
printf $main::outf "# Generated by $file\n";
printf $main::outf "#\n";
printf $main::outf "##########################\n";
if( ! $main::nogui ) {
   printf $main::outf "gui_stop\n";
}
printf $main::outf "set_design_attribute SpiritName $design\n";
printf $main::outf "set_design_attribute SpiritVersion 1.4\n\n";
printf $main::outf "# global activity parameters\n\n";
# write global clocks
writeClocks();
writeClkGate();
printf $main::outf "autocomplete_activity GClocks\n";
writeMultiCast();
printf $main::outf "autocomplete_activity GMultiCast\n";
printf $main::outf "set_current_component\n\n";

#populating ep and rtr hashes
foreach my $cmp ($main::API->listComponents) {
   my $nma = $cmp->componentRef();
   my $type = $nma->name();
   my $nm = $cmp->instanceName();
   if( $type eq "rtr_rtl" ) { 
      $main::rtrs{$nm}{name} = $nm;
      $main::rtrs{$nm}{ref} = \$cmp;
#      print "Putting $nm in router hash\n";
   } elsif( $type eq "ep_tlm" ) {
      $main::eps{$nm}{name} = $nm;
      $main::eps{$nm}{ref} = \$cmp;
   }
}


# Write rtr component instances
foreach my $key ( keys %main::rtrs ) {
   my $cmp_ref= $main::rtrs{$key}{ref};
   my $cmp = $$cmp_ref;
   my $nma = $cmp->componentRef();
   my $nm = $cmp->instanceName();
   $main::rtrs{$nm}{name} = $nm;
   $main::rtrs{$nm}{ref} = \$cmp;
   printf $main::outf "\nset c \"$nm\"\n";
   printf $main::outf "instantiate_component {Intel IosfSbc IOSFSideband 1.0} -name \${c} -noauto\n";
   stdWriteCfgParm($cmp, "NPorts");
   stdWriteCfgParm($cmp, "LBQ");
   stdWriteCfgParm($cmp, "IngQDpth");
   stdWriteCfgParm($cmp, "IntBWdth");
   stdWriteCfgParm($cmp, "ExtBWdth");
   stdWriteCfgParm($cmp, "PipeArb");
   stdWriteCfgParm($cmp, "FastArb");
   stdWriteCfgParm($cmp, "NOA");
   stdWriteCfgParm($cmp, "REG");
   writeR2R($cmp);
   writePidRange($cmp);
   writeAsyncPort($cmp);
   writeClock($cmp);
   # Handle ep specific parameters
   my @lst = getConfigurableElementValueList($cmp, "N");
   foreach my $portname (@lst) {
      if( $portname =~ /N(\d{1,2})/ ) {
         my $portnum = $1;
         my $agtname = getConfigurableElementValue($cmp, $portname);
         my $parm = "P" . $portnum . "_NAME";
         writeSetConfigParm($parm, $agtname);
         if( exists $main::eps{$agtname} ) {
            my $agt_ref = $main::eps{$agtname}{ref};
            my $agt = $$agt_ref;
            my $nm = $agt->instanceName();
            portWriteCfgParm($agt, "PLByteW", $portnum);
            writePortIds($agt, $portnum);
            portWriteCfgParm($agt, "NPCRED", $portnum);
            portWriteCfgParm($agt, "PCCRED", $portnum);
            writeClock($agt, $portnum);
         }
      }
   }
}

if( $main::agents ) {
   # write endpoint component instances
   printf $main::outf "\n# agents\n";
   foreach my $cmp ($main::API->listComponents) {
      my $nma = $cmp->componentRef();
      my $nm = $nma->name();
      if( $nm eq "ep_tlm" ) {
         my $nm = $cmp->instanceName();
         printf $main::outf "instantiate_component {Intel IosfSbc sbr_agent 1.0} -name $nm -noauto\n";
      }
   }
}

# Write interconnections
foreach my $cmp ($main::API->listComponents) {
   my $nma = $cmp->componentRef();
   my $nm = $nma->name();
   if( $nm eq "rtr_rtl" ) { 
      my $nm = $cmp->instanceName();
      printf $main::outf "\n#$nm connections\n";
      printf $main::outf "set c \"$nm\"\n";
      my @lst = getConfigurableElementValueList($cmp, "N");
      # loop through the ports
      foreach my $portnm (@lst) {
         if( $portnm =~ /N(\d{1,2})/ ) {
            my $pnum = $1;
            my $agent = getConfigurableElementValue($cmp, $portnm);
            if( exists $main::rtrs{$nm}{intfnids}{$pnum} ) {
               my $pname = getRtrPNum($nm, $agent);
               printf $main::outf "connect_interface -from_component \${c} -from_interface agent_port_$pnum -to_component $agent -to_interface $pname\n";
            } else {
              if( ! exists $main::rtrs{$agent} && $main::agents ) {
                 printf $main::outf "connect_interface -from_component \${c} -from_interface port_$pnum -to_component $agent -to_interface sbr_ip\n";
              }
            }
         }
      }
      if( $main::agents ) {
         printf $main::outf "set_unused_interface -component \${c} -interface scan_sbr\n";
         printf $main::outf "set_unused_interface -component \${c} -interface visa_sbr_0\n";
         printf $main::outf "set_unused_interface -component \${c} -interface visa_sbr_1\n";
      }
   }
}
printf $main::outf "#autocomplete_activity SpecifySubsystem\n";

if( ! $main::nogui ) {
   printf $main::outf "\ngui_start\n";
}

if( $main::network ) {
   printf $main::outf "\ncreate_psf_network\n";
}

if( $main::quit ) {
   printf $main::outf "\nquit\n";
}

close $main::outf;
################subs ################
sub getConfigurableElementValue {
   my $cmp = shift;
   my $id = shift;
   
   foreach my $cv ($cmp->configurableElementValues->configurableElementValue()) {
      if( $cv->referenceId() eq $id ) {
         return $cv->content();
      }
   }
   return "";
}

sub getVEConfigurableElementValue {
   my $cmp = shift;
   my $id = shift;
   
   foreach my $cv ($cmp->configurableElementValue()) {
      if( $cv->referenceId() eq $id ) {
         return $cv->content();
      }
   }
   return "";
}

sub getConfigurableElementValueList {
   my $cmp = shift;
   my $id = shift;
   my @outlist;
   foreach my $cv ($cmp->configurableElementValues->configurableElementValue()) {
      if( $cv->referenceId() =~ /\Q$id\E/ ) {
         push(@outlist, $cv->referenceId());
      }
   }
   return @outlist;
}

sub writeSetActParm {
   my $activity = shift;
   my $parm = shift;
   my $val = shift;
   printf $main::outf "set_activity_parameter $activity $parm $val\n";
}

sub writeSetConfigParm {
   my $parm = shift;
   my $val = shift;
   my $def = shift;
   if( $val ne "" ) {
      printf $main::outf "set_configuration_parameter -component \${c} $parm $val\n";      
   } else {
      die "Value for parameter $parm required" 
         unless defined $def;
      printf $main::outf "set_configuration_parameter -component \${c} $parm $def\n";
   }
}

sub stdWriteCfgParm {
   my $cmp = shift;
   my $parmh = shift;
   
   my $nn = getConfigurableElementValue($cmp, $main::parms{$parmh}{xml});
   if( defined $main::parms{$parmh}{mult} ) {
      $nn = $nn * $main::parms{$parmh}{mult};
   }
   if( defined $main::parms{$parmh}{def} ) {
      writeSetConfigParm($main::parms{$parmh}{tcl}, $nn, $main::parms{$parmh}{def});
   } else {
      writeSetConfigParm($main::parms{$parmh}{tcl}, $nn);
   }
}

sub portWriteCfgParm {
   my $cmp = shift;
   my $parmh = shift;
   my $portnum = shift;
   my $nn = getConfigurableElementValue($cmp, $main::parms{$parmh}{xml});
   $nn = (defined $main::parms{$parmh}{mult})?$nn*$main::parms{$parmh}{mult}:$nn;
   my $parmnm = "P" . $portnum . $main::parms{$parmh}{tcl};
   if( defined $main::parms{$parmh}{def} ) {
      writeSetConfigParm($parmnm, $nn, $main::parms{$parmh}{def});
   } else {
      writeSetConfigParm($parmnm, $nn);
   }
}

sub writeR2R {
   my $cmp = shift;
   my $nids = getConfigurableElementValue($cmp, "ip_intf_nids");
   my @lst = split(",", $nids);
   foreach my $ls (@lst) {
      my $parm = "P" . $ls .  "ROUTER2ROUTER";
      writeSetConfigParm($parm, "1");
      $main::rtrs{$cmp->instanceName()}{intfnids}{$ls} = 1;
   }
}

sub writePortIds {
   my $cmp = shift;
   my $portnum = shift;
   my $pids = getConfigurableElementValue($cmp, "Port IDs");
   my $parm = "P" . $portnum . "PortIDList";
   my $val = "\"$pids\"";
   writeSetConfigParm($parm, $val);
}

sub writePidRange {
   my $cmp = shift;
   my @pids = getConfigurableElementValueList($cmp, "pid_range_");
   foreach my $pidnm (@pids) {
      if( $pidnm =~ /pid_range_(\d*)/ ) {
         my $num = $1;
         my $pid = getConfigurableElementValue($cmp, $pidnm);
         my @lst = split(",", $pid);
         my $parm = "PIDRANGE" . $num .  "START";
         writeSetConfigParm($parm, $lst[0]);
         $parm = "PIDRANGE" . $num .  "STOP";
         writeSetConfigParm($parm, $lst[1]);
         $parm = "PIDRANGE" . $num . "ENABLE";
         writeSetConfigParm($parm, 1);
      }
   }
}

sub writeAsyncPort {
   my $cmp = shift;
   my $nm = $cmp->instanceName();
   foreach my $ap ($main::API->listAsyncPorts) {
      my $nid = getVEConfigurableElementValue($ap, "Router:NID");
      if( $nid =~ /($nm):(\d{1,2})/ ) {
         if( $nm eq $1 ) {
            my $parm = "P" . $2 . "ASYNC";
            writeSetConfigParm($parm, 1);
            my $ing = getVEConfigurableElementValue($ap, "Ingress aFIFO Depth");
            $parm = "P" . $2 . "INGRESSAFIFODEPTH";
            writeSetConfigParm($parm, $ing);
            my $eg = getVEConfigurableElementValue($ap, "Egress aFIFO Depth");
            $parm = "P" . $2 . "EGRESSAFIFODEPTH";
            writeSetConfigParm($parm, $eg);
         }
      }
   }
}

sub writeClocks {
   my $clknum = 0;
   foreach my $clk ($main::API->listClockResets) {
      my $rstclknm = getVEConfigurableElementValue($clk, "Clock Name");
      printf $main::outf "# Clock $rstclknm\n";
      my $clkn = "CLKNAME" . $clknum;
      writeSetActParm("GClocks", $clkn, $rstclknm);
      my $clkr = "CLKRSTSIG" . $clknum;
      my $rstnm = getVEConfigurableElementValue($clk, "Reset Name");
      writeSetActParm("GClocks", $clkr, $rstnm);
      my $clkf = "CLKFREQ" . $clknum;
      my $per = getVEConfigurableElementValue($clk, "Testbench Half Period");
      if( $per =~ /([\d\.]+).*ns/ ) {
         my $freq = 500 / $1;
         $freq = sprintf("%d", $freq);
         writeSetActParm("GClocks", $clkf, $freq);
      } else {
         die "Error reading period $per\n";
      }
      $clknum++;
   }
   writeSetActParm("GClocks", "NumClocks", $clknum);
}

sub writeMultiCast {
   my $gpnum = 0;
   foreach my $gp ($main::API->listMultiCasts) {
      my $gpid = getVEConfigurableElementValue($gp, "Group Port ID");
      printf $main::outf "# Group ID $gpid\n";
      my $grpn = "GPORTID" . $gpnum;
      writeSetActParm("GMultiCast", $grpn, $gpid);
      my $grplt = "GListType" . $gpnum;
      writeSetActParm("GMultiCast", $grplt, "0");
      my $grplst = "GList" . $gpnum;
      my $glist = getVEConfigurableElementValue($gp, "Port IDs");
      $glist = "\"" . $glist . "\"";
      writeSetActParm("GMultiCast", $grplst, $glist);
      $gpnum++;
   }
   writeSetActParm("GMultiCast", "NumGroups", $gpnum);
}

sub writeClkGate {
   foreach my $clkgate ($main::API->getClockGating) {
      if( defined $clkgate ) {
         my $cgnum = getVEConfigurableElementValue($clkgate, "Enable Clock Gating");
         if( $cgnum == 1 ) {
            printf $main::outf "# Clock Gating Enabled\n";
            writeSetActParm("GClocks", "ClkGating", "1");
         }
      }
   }
}

sub writeClock {
   my $cmp = shift;
   my $portnum = shift; # only present during agent clocks
   my $clknm = getConfigurableElementValue($cmp, "Clock Name");
   my $parm = (defined $portnum)?"P".$portnum."SBRCLKNAME":"SBRCLKNAME";
   writeSetConfigParm($parm, $clknm);
}

sub getRtrPNum {
   my $cmpname = shift;
   my $rtrname = shift;
   
   my $rtr_ref = $main::rtrs{$rtrname}{ref};
   my $rtr = $$rtr_ref;

   my @lst = getConfigurableElementValueList($rtr, "N");
   # loop through the ports
   foreach my $portnm (@lst) {
      if( $portnm =~ /N(\d{1,2})/ ) {
         my $pnum = $1;
         my $agent = getConfigurableElementValue($rtr, $portnm);
         if( $cmpname eq $agent ) {
            return "port_$pnum";
         }
      }
   }
   die "Instance $cmpname not found on router $rtrname";
   return "";
}

sub parseCmdLine {

   my $prnt_version;
   
   if( scalar @ARGV == 0 ) {
      exit;
   }
   GetOptions( 'help|?' => \$main::help,
               'debug' => \$main::debug,
               'agents' => \$main::nostub,
               'nogui' => \$main::nogui,
               'network' => \$main::network,
               'quit' => \$main::quit,
               'version' => \$prnt_version
             ) or pod2usage({-verbose => 2, -exitval => 0});;

   # print the version
   if( $prnt_version ) {
      print "$main::toolname  $main::version  $main::date\n";
      exit;
   }
   # print the -help usage message	     
   pod2usage({-verbose => 2,
              -exitval => 0} ) if $main::help;
   # print the usage message if the input xml file is missing
   pod2usage({-verbose => 2,
              -exitval => 0} ) if $#ARGV == -1;  

   $main::xmlfile = shift @ARGV;
}

__END__

=head1 NAME

xml2tcl.pl - Generate SBR coretools TCL batch file

=head1 SYNOPSIS

xml2tcl.pl [options] [XML File ...]

 Options:
   -help         help message
   -?            help message
   -agents       generate with the agent stubs
   -quit         append a quit command as the last entry
   -nogui        do not add the gui_stop/gui_start
   -network      add the create_sbr_network command at the end (before a quit)
   
=head1 OPTIONS

=over 8

=item B<-help|-?>

Print a brief help message and exit

=item B<-quit>

Prints a quit command at the end of the output file

=item B<-agents>

add the agent stubs

=item B<-nogui>

do not add the gui_stop/gui_start command pairs (batch mode)

=item B<-network>

add the create_sbr_network command to the end of the file but before the quit

=back

=head1 DESCRIPTION

B<xml2tcl> will parse the given XML file and generate a TCL batch file to 
generate the same SideBand subsystem in coreAssembler

=cut
