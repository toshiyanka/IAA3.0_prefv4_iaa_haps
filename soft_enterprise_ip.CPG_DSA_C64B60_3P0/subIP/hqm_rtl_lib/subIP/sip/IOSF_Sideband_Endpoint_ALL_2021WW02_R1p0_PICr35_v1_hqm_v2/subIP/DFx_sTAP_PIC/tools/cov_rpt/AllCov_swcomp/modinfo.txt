===============================================================================
Module : SIP_SHARED_LIB.DfxSecurePlugin_TestIsland
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 23.53 --     --     --     --     --      23.53 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/subIP/DfxSecurePlugin/verif/tb/DfxSecurePlugin_TestIsland.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                  
--     --     --     --     --     --     --     top.i_TapTestIsland.pri_DfxSecurePlugin_TestIsland(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \SIP_SHARED_LIB.DfxSecurePlugin_TestIsland 

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL            86        0        0

85                         begin
86         excluded           vif_container = new ();
87         excluded           vif_container.set_v_if (`DFX_SECURE_PLUGIN_PIF);
88         excluded           set_config_object (DFXSECUREPLUGINVIF, "V_DFXSECPLUGIN_VIF", vif_container, 0);

-------------------------------------------------------------------------------
Assert Coverage for Module : \SIP_SHARED_LIB.DfxSecurePlugin_TestIsland 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       17    17        100.00  4                 23.53   
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            17    17        100.00  4                 23.53   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                             Attempts Real Successes Failures Incomplete 
SECURE_POLICY_CHECK_BEFORE_EARLYBOOTEXIT                                         189305   9              0        0          
genblk2.policy_checker_use0[0].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   4996           0        0          
genblk2.policy_checker_use0[10].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[11].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[12].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[13].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[14].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[15].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0 189305   0              0        0          
genblk2.policy_checker_use0[1].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[2].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   177536         0        0          
genblk2.policy_checker_use0[3].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[4].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[5].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   4936           0        0          
genblk2.policy_checker_use0[6].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[7].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[8].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          
genblk2.policy_checker_use0[9].SECURE_POLICY_CHECK_AFTER_EARLYBOOTEXIT_USE_SB_0  189305   0              0        0          


===============================================================================
Module : STAP_RTL_LIB.stap_swcomp_rtdr
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 26.98 --     --      26.98 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_swcomp_rtdr.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                              
--     --     --     --     --     --     --     top.stap_top_inst.generate_stap_swcomp_rtdr.i_stap_swcomp_rtdr(X) 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_swcomp_rtdr 
                Total Covered Percent 
Totals          29    17      58.62   
Total Bits      126   34      26.98   
Total Bits 0->1 63    17      26.98   
Total Bits 1->0 63    17      26.98   

                            
Ports          14 14 100.00 
Port Bits      28 28 100.00 
Port Bits 0->1 14 14 100.00 
Port Bits 1->0 14 14 100.00 

                             
Signals          15 3 20.00  
Signal Bits      98 6 6.12   
Signal Bits 0->1 49 3 6.12   
Signal Bits 1->0 49 3 6.12   

Port Details
                     Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_fsm_tlrs        Yes    Yes         Yes         INPUT     
ftap_tck             Yes    Yes         Yes         INPUT     
ftap_tdi             Yes    Yes         Yes         INPUT     
fdfx_powergood       Yes    Yes         Yes         INPUT     
powergood_rst_trst_b Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr  Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr    Yes    Yes         Yes         INPUT     
stap_fsm_update_dr   Yes    Yes         Yes         INPUT     
stap_fsm_e2dr        Yes    Yes         Yes         INPUT     
stap_swcomp_pre_tdo  Yes    Yes         Yes         INPUT     
tap_swcomp_active    Yes    Yes         Yes         INPUT     
swcomp_stap_post_tdo Yes    Yes         Yes         OUTPUT    
swcompctrl_tdo       Yes    Yes         Yes         OUTPUT    
swcompstat_tdo       Yes    Yes         Yes         OUTPUT    

Signal Details
                       Toggle Toggle 1->0 Toggle 0->1 
cmplim_hi[9:0]         No     No          No          
cmplim_lo[9:0]         No     No          No          
cmplim_mask[9:0]       No     No          No          
cmp_mirror_sel         Yes    Yes         Yes         
cmp_tdo_sel            No     No          No          
cmp_tdo_forcelo        No     No          No          
cmpen_main             Yes    Yes         Yes         
cmpsel_signed          No     No          No          
cmpsel_sgnmag          No     No          No          
cmpen_le_limhi         Yes    Yes         Yes         
cmpen_ge_limlo         No     No          No          
cmpen_blk_multi_fail   No     No          No          
cmp_firstfail_cnt[7:0] No     No          No          
cmp_sticky_fail_hi     No     No          No          
cmp_sticky_fail_lo     No     No          No          


===============================================================================
Module : STAP_RTL_LIB.stap_ctech_lib_clk_gate_te
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 75.00 --     --      75.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/ctech_lib/stap_ctech_map.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                          
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse(x) 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_ctech_lib_clk_gate_te 
                Total Covered Percent 
Totals          4     3       75.00   
Total Bits      8     6       75.00   
Total Bits 0->1 4     3       75.00   
Total Bits 1->0 4     3       75.00   

                          
Ports          4 3 75.00  
Port Bits      8 6 75.00  
Port Bits 0->1 4 3 75.00  
Port Bits 1->0 4 3 75.00  

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
en     Yes    Yes         Yes         INPUT     
te     No     No          No          INPUT     
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                    
 75.00 --     --      75.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_gate_te 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
100.00 100.00 --     100.00 --     100.00 --     i_ctech_lib_clk_gate_te(x) 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse(x)
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
       Toggle   Toggle 1->0 Toggle 0->1 Direction 
en     Yes      Yes         Yes         INPUT     
te     Excluded Excluded    Excluded    INPUT     
clk    Yes      Yes         Yes         INPUT     
clkout Yes      Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_RTL_LIB.stap_tapswcomp
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 81.79  97.67  83.33  54.50 --      91.67 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_tapswcomp.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                               
--     --     --     --     --     --     --     top.stap_top_inst.generate_stap_swcomp_rtdr.i_stap_swcomp_rtdr.i_stap_tapswcomp(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_tapswcomp 

             Line No.   Total   Covered  Percent
TOTAL                       43       42    97.67
ALWAYS            222        4        4   100.00
ALWAYS            233        3        3   100.00
ALWAYS            248        3        3   100.00
ALWAYS            275        4        4   100.00
ALWAYS            304        6        6   100.00
ALWAYS            342        6        6   100.00
ALWAYS            369        2        2   100.00
ALWAYS            379        4        4   100.00
ALWAYS            401        5        5   100.00
ALWAYS            421        6        5    83.33

221                        always_comb begin: serialdata_next_muxes
222        1/1                unique case({shift_en,capture_en})
223        1/1                  2'b00 : serialdata_next = serial_windowreg;
224        1/1                  2'b01 : serialdata_next = SERIAL_CAPTURE_VALUE;
225        1/1                  2'b10 : serialdata_next = {tdi,serial_windowreg[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1:1]}; // shifting serial data from TDI / prev. flop
226                             //VCS coverage off
227        unreachable          default : serialdata_next = {(STAP_SWCOMP_NUM_OF_COMPARE_BITS){1'bx}};
228                             //VCS coverage on
229                           endcase
230                        end
231                        
232                        always_ff @(posedge jtclk or negedge jtrst_b) begin : serial_windowreg_flops
233        1/1               if (jtrst_b == 1'b0) begin
234        1/1                  serial_windowreg <=1'b0; end
235                             else begin 
236        1/1                serial_windowreg <= serialdata_next;
237                        end
238                        end
239                     
240                        
241                        // ------------------------------------
242                        // Mirroring-muxes and unsigned masking
243                        // ------------------------------------
244                        // Muxes to determine whether result data to be compared is mirrored or not e.g. 
245                        // whether LSB to comparator comes from LSB or MSB of serial window register,
246                        // For unsigned comparison, generate rslt_data_qualified with all masked bits set low.
247                        always_comb begin: rsltdata_combo
248        1/1                for( int j = 0; j < STAP_SWCOMP_NUM_OF_COMPARE_BITS; j++) begin
249        1/1                   rslt_data[j] = cmp_mirror_sel ? serial_windowreg[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1-j] : serial_windowreg[j];
250        1/1                   rslt_data_qualified[j] = (!cmplim_mask[j]) & rslt_data[j]; 
251                           end
252                        end
253                     
254                     
255                        // ----------------------------------------
256                        // Sign-bit position and check for negative
257                        // ----------------------------------------
258                        // For signed comparisions, the sign bit position is pulled off of lower 4 bits of
259                        // cmplim_mask input and identifies the bit position of the sign-bit for signed
260                        // comparison.  Sharing these bits avoids need for additional TDR bits (bit masking is
261                        // not expected to be required during signed comparison)
262                        assign cmpsel_sign_bit[3:0] = cmplim_mask[3:0];
263                     
264                        // determine if Sign bit is one
265                        assign sign_bit_is1         = ( (rslt_data>>cmpsel_sign_bit) & 1'b1) == 1'b1; 
266                         
267                     
268                        // ------------------------------------
269                        // Sign-extension of 2s complement data
270                        // ------------------------------------
271                        // This converts 2's complement sdata_2c to sign-extended 2's complement data sdata_2c_se.
272                        // Values must sign-extended to preserve sign prior to comparison (when comparator is wider than data)
273                        always_comb begin : se_2c
274                     
275        1/1                sdata_2c = $signed(rslt_data); // take data off mirror muxes and treat it as 2's complement
276                           //sign_bit_is1         = ( (sdata_2c>>cmpsel_sign_bit) & 1'b1) == 1'b1; 
277                     
278        1/1                case (sign_bit_is1)        
279                     
280                             // Positive numbers: (Sign bit is zero) 
281                             // Zero-out bits above Sign-bit
282        1/1                  1'b0:   sdata_2c_se = $signed(sdata_2c & ~({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
283                     
284                             // Negative numbers. (Sign bit is set)
285                             // sign-extend to MSB
286        1/1                  1'b1:   sdata_2c_se = $signed(sdata_2c |  ({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
287                     
288                             //VCS coverage off
289        unreachable          default: sdata_2c_se = $signed({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'bx}});
290                             //VCS coverage on
291                           endcase 
292                           
293                        end : se_2c
294                     
295                     
296                        // --------------------------------------------
297                        // Signed-magnitude to 2s complement conversion
298                        // --------------------------------------------   
299                        // convert sdata_sm (signed-magnitude) to sdata_smto2c_se (sign-extended 2's complement)
300                        // so that is can be successfully compared in the 2's complement comparator.
301                        // both data values are signed.
302                        always_comb begin : sm2c_conv
303                     
304        1/1                sdata_sm = $signed(rslt_data); // take data off mirror muxes and treat it as signed-magnitude
305                     
306                           //sm_sign_bit_is1 = ( (sdata_sm>>cmpsel_sign_bit) & 1'b1) == 1'b1;       // determine if Sign bit is one
307                     
308                           // Determine if magnitude is zero, to flag special case of -0. 
309                           // mask off bits above and including cmpsel_sign_bit position 
310        1/1                mag_is0 = ( ($unsigned(sdata_sm) & ~({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit) ) == {STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b0}} ) ;
311                     
312        1/1                casez ({mag_is0, sign_bit_is1})        
313                     
314                             // zero or negative-zero; special case to handle 'negative 0' which does not exist in 2s comp 
315        1/1                  2'b1?:   sdata_smto2c_se = 0;  // (-0 -> 0)
316                     
317                             // Positive numbers: (Sign bit is zero) 
318                             // Zero-out bits above Sign-bit
319        1/1                  2'b00:   sdata_smto2c_se = $signed(sdata_sm & ~({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
320                     
321                             // Negative numbers. (Sign bit is set)
322                             // for bits below Sign bit: flip all bits and add 1, 
323                             // and set sign bit & sign-extend to MSB
324        1/1                  2'b01:   sdata_smto2c_se = $signed((~sdata_sm+1'b1) |  ({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
325                     
326                             //VCS coverage off
327        unreachable          default: sdata_smto2c_se = $signed({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'bx}});
328                             //VCS coverage on
329                     
330                           endcase 
331                           
332                        end : sm2c_conv
333                     
334                     
335                        // --------------------------------------------
336                        // Set up limits and select data to be compared
337                        // --------------------------------------------
338                        always_comb begin : set_scomp_data
339                     
340                           // set signed limits to be compared
341                           // if unsigned, set MSB of comparator data/limit to be 0, otherwise, pull MSB (sign bit) from MSB of data/limit
342        1/1                scomp_limit_hi = $signed(cmpsel_signed ? {cmplim_hi[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],cmplim_hi} : {1'b0,cmplim_hi});
343        1/1                scomp_limit_lo = $signed(cmpsel_signed ? {cmplim_lo[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],cmplim_lo} : {1'b0,cmplim_lo});
344                           
345                           // setup signed data to be compared:
346        1/1                casez ({cmpsel_signed, cmpsel_sgnmag})        
347                             // If unsigned, pull from qualified data as-is, with sign bit zeroed
348        1/1                  2'b0?:   scomp_data_in = $signed({1'b0,rslt_data_qualified});  
349                     
350                             // If signed 2's complement, sign extend from sign_bit into the comparator's sign bit
351        1/1                  2'b10:   scomp_data_in = $signed({sdata_2c_se[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],sdata_2c_se});
352                     
353                             // if signed magnitude, use value converted to 2s complement and sign-extended
354        1/1                  2'b11:   scomp_data_in = $signed({sdata_smto2c_se[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],sdata_smto2c_se});
355                     
356                             //VCS coverage off
357        unreachable          default: scomp_data_in = $signed({(STAP_SWCOMP_NUM_OF_COMPARE_BITS+1){1'bx}});
358                             //VCS coverage on
359                           endcase 
360                           
361                        end : set_scomp_data
362                        
363                        
364                        // -------------------------------------------
365                        // Digital comparators (signed 2's complement)
366                        // -------------------------------------------
367                        // note that comparator width is one more than data width, to allow for sign bit.
368                        always_comb begin : dig_comps
369        1/1                rslt_ge_limlo = (scomp_data_in >= scomp_limit_lo) ? 1'b1 : 1'b0;
370        1/1                rslt_le_limhi = (scomp_data_in <= scomp_limit_hi) ? 1'b1 : 1'b0;
371                        end : dig_comps
372                     
373                     
374                        // -----------------------------------------
375                        // Comparator fail results and control logic
376                        // -----------------------------------------
377                        always_comb begin : misc_logic
378                           // generate fail results if enabled:
379        1/1                fail_limhi = cmpen_le_limhi & (!rslt_le_limhi);
380        1/1                fail_limlo = cmpen_ge_limlo & (!rslt_ge_limlo);
381                     
382                           // condition to reset sticky-fail flops (and counter)
383        1/1                cmp_reset = (tap_swcomp_active & exit2_dr) | test_logic_reset;
384                           
385                           // Enable to comparator sticky flops:
386                           // Always enable during cmp_reset condition. 
387                           // Enable when cmpen_main=1 during Exit2-DR state, but disable to block multiple
388                           // fails if cmpen_blk_multi_fail is set, when fail has already been detected.
389        1/1                cmp_enable = cmp_reset | 
390                                        ( 
391                                          (cmpen_main & exit2_dr) &
392                                          ( !cmpen_blk_multi_fail | !(cmp_sticky_fail_lo | cmp_sticky_fail_hi) )
393                                        );      
394                        end
395                        
396                     
397                        // -----------------
398                        // Sticky-fail flops
399                        // -----------------
400                        always_ff @(posedge jtclk or negedge jtrst_b) begin : sticky_fail_flops
401        1/1                if (jtrst_b == 1'b0) begin
402        1/1                   cmp_sticky_fail_hi <= 1'b0;
403        1/1                   cmp_sticky_fail_lo <= 1'b0;
404                           end
405                           else begin
406        1/1                   cmp_sticky_fail_hi <= cmp_enable ? ( (fail_limhi | cmp_sticky_fail_hi) & (!cmp_reset) ) : cmp_sticky_fail_hi; //Edited by badithya
407        1/1                   cmp_sticky_fail_lo <= cmp_enable ? ( (fail_limlo | cmp_sticky_fail_lo) & (!cmp_reset) ) : cmp_sticky_fail_lo; //Edited by badithya
408                           end
409                        end
410                      
411                     
412                        // -----------------
413                        // Counter
414                        // -----------------
415                        assign ctr_load0 = cmp_reset;
416                        // Stop counting if fail is currently detected or if sticky fail was set
417                        // so that counter records the first fail (count starting from 0)
418                        assign ctr_enable = (cmpen_main & exit2_dr) & !(fail_limlo | fail_limhi) & !(cmp_sticky_fail_lo | cmp_sticky_fail_hi);
419                        
420                        always_ff @(posedge jtclk or negedge jtrst_b) begin : fail_counter
421        1/1                if (jtrst_b == 1'b0) 
422        1/1                  cmp_firstfail_cnt <= {8{1'b0}};
423                           else begin
424        1/1                   casez ({ctr_load0, ctr_enable})
425        1/1                     2'b1?:   cmp_firstfail_cnt <= {8{1'b0}};
426        1/1                     2'b00:   cmp_firstfail_cnt <= cmp_firstfail_cnt;
427        0/1     ==>             2'b01:   cmp_firstfail_cnt <= cmp_firstfail_cnt + 1;
428                                //VCS coverage off
429        unreachable             default: cmp_firstfail_cnt <= {8{1'bx}};

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_tapswcomp 

               Total   Covered  Percent
Conditions          6        5    83.33
Logical             6        5    83.33
Non-Logical         0        0
Event               0        0

 LINE       406
 EXPRESSION (cmp_enable ? (((fail_limhi | cmp_sticky_fail_hi) & (!cmp_reset))) : cmp_sticky_fail_hi)
             -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       407
 EXPRESSION (cmp_enable ? (((fail_limlo | cmp_sticky_fail_lo) & (!cmp_reset))) : cmp_sticky_fail_lo)
             -----1----

-1- Status
 0  Covered
 1  Covered

 LINE       207
 EXPRESSION (((cmp_tdo_sel & (!tdi_tdo_direct))) ? serial_windowreg[0] : tdi)
             -----------------1-----------------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_tapswcomp 
                Total Covered Percent 
Totals          50    30      60.00   
Total Bits      378   206     54.50   
Total Bits 0->1 189   103     54.50   
Total Bits 1->0 189   103     54.50   

                             
Ports          24  12 50.00  
Port Bits      116 24 20.69  
Port Bits 0->1 58  12 20.69  
Port Bits 1->0 58  12 20.69  

                                
Signals          26  18  69.23  
Signal Bits      262 182 69.47  
Signal Bits 0->1 131 91  69.47  
Signal Bits 1->0 131 91  69.47  

Port Details
                       Toggle Toggle 1->0 Toggle 0->1 Direction 
jtclk                  Yes    Yes         Yes         INPUT     
jtrst_b                Yes    Yes         Yes         INPUT     
tdi                    Yes    Yes         Yes         INPUT     
test_logic_reset       Yes    Yes         Yes         INPUT     
capture_dr             Yes    Yes         Yes         INPUT     
shift_dr               Yes    Yes         Yes         INPUT     
exit2_dr               Yes    Yes         Yes         INPUT     
tap_swcomp_active      Yes    Yes         Yes         INPUT     
cmplim_hi[9:0]         No     No          No          INPUT     
cmplim_lo[9:0]         No     No          No          INPUT     
cmplim_mask[9:0]       No     No          No          INPUT     
cmp_mirror_sel         Yes    Yes         Yes         INPUT     
cmp_tdo_sel            No     No          No          INPUT     
cmp_tdo_forcelo        No     No          No          INPUT     
cmpen_main             Yes    Yes         Yes         INPUT     
cmpsel_signed          No     No          No          INPUT     
cmpsel_sgnmag          No     No          No          INPUT     
cmpen_le_limhi         Yes    Yes         Yes         INPUT     
cmpen_ge_limlo         No     No          No          INPUT     
cmpen_blk_multi_fail   No     No          No          INPUT     
cmp_firstfail_cnt[7:0] No     No          No          OUTPUT    
cmp_sticky_fail_hi     No     No          No          OUTPUT    
cmp_sticky_fail_lo     No     No          No          OUTPUT    
tdo                    Yes    Yes         Yes         OUTPUT    

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
tdi_tdo_direct           Yes    Yes         Yes         
tdo_pregate              Yes    Yes         Yes         
capture_en               Yes    Yes         Yes         
shift_en                 Yes    Yes         Yes         
serialdata_next[9:0]     Yes    Yes         Yes         
serial_windowreg[9:0]    Yes    Yes         Yes         
rslt_data[9:0]           Yes    Yes         Yes         
rslt_data_qualified[9:0] Yes    Yes         Yes         
rslt_le_limhi            Yes    Yes         Yes         
rslt_ge_limlo            No     No          No          
fail_limhi               Yes    Yes         Yes         
fail_limlo               No     No          No          
cmp_reset                Yes    Yes         Yes         
cmp_enable               Yes    Yes         Yes         
ctr_load0                Yes    Yes         Yes         
ctr_enable               Yes    Yes         Yes         
cmpsel_sign_bit[3:0]     No     No          No          
sign_bit_is1             Yes    Yes         Yes         
mag_is0                  No     No          No          
sdata_sm[9:0]            Yes    Yes         Yes         
sdata_smto2c_se[9:0]     No     No          No          
sdata_2c[9:0]            Yes    Yes         Yes         
sdata_2c_se[9:0]         Yes    Yes         Yes         
scomp_limit_hi[10:0]     No     No          No          
scomp_limit_lo[10:0]     No     No          No          
scomp_data_in[9:0]       Yes    Yes         Yes         
scomp_data_in[10]        No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_tapswcomp 
         Line No. Total Covered Percent 
Branches          24    22      91.67   
TERNARY  207      2     1       50.00   
CASE     222      3     3       100.00  
IF       233      2     2       100.00  
CASE     278      2     2       100.00  
CASE     312      3     3       100.00  
CASE     346      3     3       100.00  
IF       401      5     5       100.00  
IF       421      4     3       75.00   


207           assign tdo_pregate    = ( cmp_tdo_sel     & !tdi_tdo_direct ) ? serial_windowreg[0] : tdi;
                                                                            -1-  
                                                                            ==>  
                                                                            ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


222              unique case({shift_en,capture_en})
                        -1-  
223                2'b00 : serialdata_next = serial_windowreg;
                   ==>
224                2'b01 : serialdata_next = SERIAL_CAPTURE_VALUE;
                   ==>
225                2'b10 : serialdata_next = {tdi,serial_windowreg[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1:1]}; // shifting serial data from TDI / prev. flop
                   ==>

Branches:

-1-    Status  
2'b00  Covered 
2'b01  Covered 
2'b10  Covered 


233             if (jtrst_b == 1'b0) begin
                -1-  
234                serial_windowreg <=1'b0; end
                   ==>
235                else begin 
236              serial_windowreg <= serialdata_next;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


278              case (sign_bit_is1)        
                 -1-  
279        
280                // Positive numbers: (Sign bit is zero) 
281                // Zero-out bits above Sign-bit
282                1'b0:   sdata_2c_se = $signed(sdata_2c & ~({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
                   ==>
283        
284                // Negative numbers. (Sign bit is set)
285                // sign-extend to MSB
286                1'b1:   sdata_2c_se = $signed(sdata_2c |  ({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
                   ==>

Branches:

-1-   Status  
1'b0  Covered 
1'b1  Covered 


312              casez ({mag_is0, sign_bit_is1})        
                 -1-  
313        
314                // zero or negative-zero; special case to handle 'negative 0' which does not exist in 2s comp 
315                2'b1?:   sdata_smto2c_se = 0;  // (-0 -> 0)
                   ==>
316        
317                // Positive numbers: (Sign bit is zero) 
318                // Zero-out bits above Sign-bit
319                2'b00:   sdata_smto2c_se = $signed(sdata_sm & ~({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
                   ==>
320        
321                // Negative numbers. (Sign bit is set)
322                // for bits below Sign bit: flip all bits and add 1, 
323                // and set sign bit & sign-extend to MSB
324                2'b01:   sdata_smto2c_se = $signed((~sdata_sm+1'b1) |  ({STAP_SWCOMP_NUM_OF_COMPARE_BITS{1'b1}}<<cmpsel_sign_bit)); 
                   ==>

Branches:

-1-    Status  
2'b1z  Covered 
2'b00  Covered 
2'b01  Covered 


346              casez ({cmpsel_signed, cmpsel_sgnmag})        
                 -1-  
347                // If unsigned, pull from qualified data as-is, with sign bit zeroed
348                2'b0?:   scomp_data_in = $signed({1'b0,rslt_data_qualified});  
                   ==>
349        
350                // If signed 2's complement, sign extend from sign_bit into the comparator's sign bit
351                2'b10:   scomp_data_in = $signed({sdata_2c_se[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],sdata_2c_se});
                   ==>
352        
353                // if signed magnitude, use value converted to 2s complement and sign-extended
354                2'b11:   scomp_data_in = $signed({sdata_smto2c_se[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1],sdata_smto2c_se});
                   ==>

Branches:

-1-    Status  
2'b0z  Covered 
2'b10  Covered 
2'b11  Covered 


401              if (jtrst_b == 1'b0) begin
                 -1-  
402                 cmp_sticky_fail_hi <= 1'b0;
                    ==>
403                 cmp_sticky_fail_lo <= 1'b0;
404              end
405              else begin
406                 cmp_sticky_fail_hi <= cmp_enable ? ( (fail_limhi | cmp_sticky_fail_hi) & (!cmp_reset) ) : cmp_sticky_fail_hi; //Edited by badithya
                                                     -2-  
                                                     ==>  
                                                     ==>  
407                 cmp_sticky_fail_lo <= cmp_enable ? ( (fail_limlo | cmp_sticky_fail_lo) & (!cmp_reset) ) : cmp_sticky_fail_lo; //Edited by badithya
                                                     -3-  
                                                     ==>  
                                                     ==>  

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   -   Covered 
0   -   1   Covered 
0   -   0   Covered 


421              if (jtrst_b == 1'b0) 
                 -1-  
422                cmp_firstfail_cnt <= {8{1'b0}};
                   ==>
423              else begin
424                 casez ({ctr_load0, ctr_enable})
                    -2-  
425                   2'b1?:   cmp_firstfail_cnt <= {8{1'b0}};
                      ==>
426                   2'b00:   cmp_firstfail_cnt <= cmp_firstfail_cnt;
                      ==>
427                   2'b01:   cmp_firstfail_cnt <= cmp_firstfail_cnt + 1;
                      ==>

Branches:

-1- -2-    Status      
1   -      Covered     
0   2'b1z  Covered     
0   2'b00  Covered     
0   2'b01  Not Covered 


===============================================================================
Module : STAP_RTL_LIB.stap_top_assertions
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 82.64  84.29 --      76.60 --      77.88  91.80 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_top_assertions.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                       
--     --     --     --     --     --     --     top.stap_top_inst.i_stap_top_assertions(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_top_assertions 

             Line No.   Total   Covered  Percent
TOTAL                      140      118    84.29
ALWAYS            138        1        1   100.00
ALWAYS            147        1        1   100.00
ALWAYS            156        1        1   100.00
ALWAYS            165        1        1   100.00
ALWAYS            346        2        2   100.00
ALWAYS            366        7        7   100.00
ALWAYS            366        7        7   100.00
ALWAYS            366        7        7   100.00
ALWAYS            400        3        3   100.00
ALWAYS            400        3        3   100.00
ALWAYS            400        3        3   100.00
ALWAYS            490        7        5    71.43
ALWAYS            541        2        2   100.00
ALWAYS            541        2        2   100.00
ALWAYS            541        2        2   100.00
ALWAYS            541        2        2   100.00
ALWAYS            565        2        2   100.00
ALWAYS            565        2        2   100.00
ALWAYS            565        2        2   100.00
ALWAYS            565        2        2   100.00
INITIAL           623       40       40   100.00
INITIAL           843       41       21    51.22
INITIAL          1077        0        0

137                           cov_stap_assert_reset_during_posedge_clk:
138        1/1                cover property (ftap_trst_b_falling_edge_pulse === HIGH);
139                        end
140                     
141                        // =======================================================================
142                        // To cover the property of deasserting the ftap_trst_b at the posedge of ftap_tck
143                        // =======================================================================
144                        always @(posedge ftap_tck_delayed_by_1ps)
145                        begin
146                           cov_stap_deassert_reset_during_posedge_clk:
147        1/1                cover property (ftap_trst_b_raising_edge_pulse === HIGH);
148                        end
149                     
150                        // =======================================================================
151                        // To cover the property of asserting the ftap_trst_b at the negedge of ftap_tck
152                        // =======================================================================
153                        always @(negedge ftap_tck_delayed_by_1ps)
154                        begin
155                           cov_stap_assert_reset_during_negedge_clk:
156        1/1                cover property (ftap_trst_b_falling_edge_pulse === HIGH);
157                        end
158                     
159                        // =======================================================================
160                        // To cover the property of deasserting the ftap_trst_b at the negedge of ftap_tck
161                        // =======================================================================
162                        always @(negedge ftap_tck_delayed_by_1ps)
163                        begin
164                           cov_stap_deassert_reset_during_negedge_clk:
165        1/1                cover property (ftap_trst_b_raising_edge_pulse === HIGH);
166                        end
167                     
168                        // ====================================================================
169                        // COVER_POINT for soft reset
170                        // ====================================================================
171                        property prop_stap_soft_reset_01;
172                           @(posedge ftap_tck)
173                              ftap_tms ##1 (ftap_tms[*4]);
174                        endproperty: prop_stap_soft_reset_01
175                        cov_stap_soft_reset_01: cover property (prop_stap_soft_reset_01);
176                     
177                        // ====================================================================
178                        // COVER_POINT for glitch on TMS
179                        // ====================================================================
180                        property prop_stap_glitch_on_tms_01;
181                           @(posedge ftap_tck)
182                              ftap_tms ##1 (ftap_tms[*5]) ##1 (!ftap_tms) ##1 (ftap_tms[*3]);
183                        endproperty: prop_stap_glitch_on_tms_01
184                        cov_stap_glitch_on_tms_01: cover property (prop_stap_glitch_on_tms_01);
185                     
186                     
187                     `ifndef INTEL_SVA_OFF
188                        `ifdef DFX_ASSERTIONS
189                           // ====================================================================
190                           // Check TMS changes only on the negedge of clock
191                           // To cover the assertion TMS STABLE ON POSEDGE
192                           // ====================================================================
193                           property stap_assert_tms_during_posedge_clk;
194                               @(posedge ftap_tck_delayed_by_1ps)
195                               disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
196                               (fdfx_powergood === HIGH) |-> (ftap_tms_pulse === LOW);
197                           endproperty: stap_assert_tms_during_posedge_clk
198                           chk_stap_assert_tms_during_posedge_clk_0:
199                           assert property (stap_assert_tms_during_posedge_clk)
200                           else $error ("TMS is not asserted at negedge of tck, but asserted at posedge");
201                     
202                           // ====================================================================
203                           // Check TDI changes only on the negedge of clock
204                           // To cover the assertion TMS STABLE ON POSEDGE
205                           // ====================================================================
206                           // Based on the below PCR the successive sTAP in the network after the 
207                           // sTAP which is sending the "tdo" on posedge the below assertion will
208                           // be fired, so commented. 
209                           // https://vthsd.intel.com/hsd/seg_softip/pcr/default.aspx?pcr_id=57296
210                           // ====================================================================
211                           //logic stap_fsm_shift;
212                           //assign stap_fsm_shift = stap_fsm_shift_ir || stap_fsm_shift_dr;
213                     
214                           //property stap_assert_tdi_during_posedge_clk;
215                           //    @(posedge ftap_tck_delayed_by_1ps)
216                           //    disable iff (!stap_fsm_shift)
217                           //    (fdfx_powergood) |=> (ftap_tdi_pulse === LOW);
218                           //endproperty: stap_assert_tdi_during_posedge_clk
219                           //chk_stap_assert_tdi_during_posedge_clk_0:
220                           //assert property (stap_assert_tdi_during_posedge_clk)
221                           //else $error ("TDI is not asserted at negedge of tck, but asserted at posedge");
222                     
223                     
224                           // ====================================================================
225                           // Check TDO changes only on a negedge when STAP_ENABLE_TDO_POS_EDGE = 0
226                           // and TDO changes only on posedge when STAP_ENABLE_TDO_POS_EDGE = 1
227                           // ====================================================================
228                           generate
229                              if (STAP_ENABLE_TDO_POS_EDGE === 0)
230                              begin:generate_tdo_during_posedge_clk
231                                 property stap_assert_tdo_during_posedge_clk;
232                                    @(ftap_tck) 
233                                      disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
234                                      ((stap_fsm_shift_ir || stap_fsm_shift_dr) && (ftap_tms === LOW) && (ftap_tck === HIGH)) |-> $stable(atap_tdo);
235                                 endproperty: stap_assert_tdo_during_posedge_clk
236                                 chk_stap_assert_tdo_during_posedge_clk_0:
237                                 assert property (stap_assert_tdo_during_posedge_clk)
238                                 else $error ("TDO is not asserted at negedge of tck, but asserted at posedge");
239                              end
240                              else
241                              begin:generate_tdo_during_negedge_clk
242                                 property stap_assert_tdo_during_negedge_clk;
243                                    @(ftap_tck) 
244                                      disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
245                                      ((stap_fsm_shift_ir || stap_fsm_shift_dr) && (ftap_tms === LOW) && (ftap_tck === LOW)) |-> $stable(atap_tdo);
246                                 endproperty: stap_assert_tdo_during_negedge_clk
247                                 chk_stap_assert_tdo_during_negedge_clk_0:
248                                 assert property (stap_assert_tdo_during_negedge_clk)
249                                 else $error ("TDO is not asserted at posedge of tck, but asserted at posedge");
250                              end
251                           endgenerate
252                     
253                           // ====================================================================
254                           // Check TDO enable is high otherthan states shift_ir and shift_dr states
255                           // ====================================================================
256                           generate
257                              if (STAP_ENABLE_TDO_POS_EDGE === 0)
258                                begin:generate_tdo_en_high_during_shift_ir_dr
259                                  property stap_tdo_en_high_during_shift_ir_dr;
260                                     @(negedge ftap_tck)
261                                        disable iff (stap_fsm_tlrs === HIGH)
262                                           (stap_fsm_shift_ir || stap_fsm_shift_dr) |=> atap_tdoen;
263                                  endproperty: stap_tdo_en_high_during_shift_ir_dr
264                                  chk_stap_tdo_en_high_during_shift_ir_dr_0:
265                                  assert property (stap_tdo_en_high_during_shift_ir_dr) else
266                                     $error ("TDO enable is not high during states shift_ir and shift_dr states");
267                                end
268                              else
269                                begin:generate_tdo_en_high_during_shift_ir_dr_with_tck_posedge
270                                  property stap_tdo_en_high_during_shift_ir_dr_with_tck_posedge;
271                                     @(posedge ftap_tck)
272                                        disable iff (stap_fsm_tlrs === HIGH)
273                                           (stap_fsm_shift_ir || stap_fsm_shift_dr) |-> atap_tdoen;
274                                  endproperty: stap_tdo_en_high_during_shift_ir_dr_with_tck_posedge
275                                  chk_stap_tdo_en_high_during_shift_ir_dr_with_tck_posedge_0:
276                                  assert property (stap_tdo_en_high_during_shift_ir_dr_with_tck_posedge) else
277                                     $error ("TDO enable is not high during states shift_ir and shift_dr states with respect to posedge of tck");
278                                end
279                           endgenerate
280                     
281                           // ====================================================================
282                           // Check TAPNW TDI is Equal to TDI when Remove Bit is asserted
283                           // ====================================================================
284                           property stap_tapnw_tdi_equals_tdi_when_remove_asserted;
285                              @(negedge ftap_tck)
286                              tapc_remove |-> (sntapnw_ftap_tdi === ftap_tdi);
287                           endproperty : stap_tapnw_tdi_equals_tdi_when_remove_asserted
288                           chk_stap_tapnw_tdi_equals_tdi_when_remove_asserted :
289                           assert property (stap_tapnw_tdi_equals_tdi_when_remove_asserted) else
290                              $error("TAPNW TDI is not Equal to TDI when Remove bit is asserted");
291                     
292                           // ====================================================================
293                           // Check TDO_EN is Equal to TAP NW TDO_EN when Remove Bit is asserted
294                           // ====================================================================
295                           property stap_tdoen_equals_tapnw_tdi_when_remove_asserted;
296                              @(negedge ftap_tck)
297                              tapc_remove |-> (atap_tdoen === |sntapnw_atap_tdo_en);
298                           endproperty : stap_tdoen_equals_tapnw_tdi_when_remove_asserted
299                           chk_stap_tdoen_equals_tapnw_tdi_when_remove_asserted :
300                           assert property (stap_tdoen_equals_tapnw_tdi_when_remove_asserted) else
301                              $error("TDO_EN is not Equal to TAP NW TDO_EN when Remove Bit is asserted");
302                     
303                           // ====================================================================
304                           // Check Remove Bit is de-asserted at Pwer Good Reset
305                           // ====================================================================
306                           property stap_remove_bit_zero_at_powergood_reset;
307                              @(fdfx_powergood)
308                              (fdfx_powergood === LOW) |-> (tapc_remove === LOW);
309                           endproperty : stap_remove_bit_zero_at_powergood_reset
310                           chk_stap_remove_bit_zero_at_powergood_reset :
311                           assert property (stap_remove_bit_zero_at_powergood_reset) else
312                              $error("Remove Bit is asserted at Power Good Reset");
313                           // ====================================================================
314                           // Check TLRS is not high when TRST is low
315                           // ====================================================================
316                           property stap_tlrs_high_when_trst_low_0;
317                              @(powergood_rst_trst_b)
318                                 !powergood_rst_trst_b |-> (tlrs === HIGH);
319                           endproperty : stap_tlrs_high_when_trst_low_0
320                     
321                           chk_stap_tlrs_high_when_trst_low_0: assert property (stap_tlrs_high_when_trst_low_0)
322                           else $error("TLRS is not high when TRST is LOW");
323                     
324                     
325                           // ====================================================================
326                           // Check TMS is not high when TRST is LOW
327                           // ====================================================================
328                           property stap_tms_high_when_trst_is_low_0;
329                              @(negedge ftap_tck)
330                                 disable iff (fdfx_powergood !== HIGH)
331                                 (!ftap_trst_b) |-> (ftap_tms === HIGH);
332                           endproperty : stap_tms_high_when_trst_is_low_0
333                     
334                           chk_stap_tms_high_when_trst_is_low_0:
335                           assert property (stap_tms_high_when_trst_is_low_0) else
336                              $error("Error: TMS is not high when TRST is LOW.");
337                     
338                           // ====================================================================
339                           // To Check for all the SELECT_WIR signals
340                           // ====================================================================
341                           generate
342                              if (STAP_ENABLE_WTAP_NETWORK === 1)
343                              begin:generate_chk_select_wir
344                                    always @(posedge ftap_tck)
345                                    begin
346        1/1                            if (stap_fsm_tlrs === LOW)
347                                       begin
348                                          chk_wtapnw_selectwir_equals_wtap_sel:
349        1/1                                  assert property (sn_fwtap_selectwir === stap_selectwir)
350                                             else $error("WTAP_SELECT_WIR Logic is not equal to select_wir or not_wtap_sel");
351                                       end
                        MISSING_ELSE
352                                    end
353                              end
354                           endgenerate
355                     
356                           // ====================================================================
357                           // To Check for all the SELECT_WSI signals
358                           // ====================================================================
359                           generate
360                              if (STAP_ENABLE_WTAP_NETWORK === 1)
361                              begin:generate_chk_wsi
362                                 for (genvar b = 0; b < STAP_NUMBER_OF_WTAPS_IN_NETWORK_NZ; b = b + 1)
363                                 begin
364                                    always @(posedge ftap_tck)
365                                    begin
366        1/1                            if (stap_fsm_tlrs === LOW)
367                                       begin
368        1/1                               if(wtap_sel_priority_internal[b] === 1'b0)
369                                          begin
370                                             chk_wtapnw_wsi_high_when_not_sel:
371        1/1                                  assert property (sn_fwtap_wsi[b] === 1'b1)
372                                             else $error("WTAP_SELECT_WSI is not High when not selected");
373                                          end
                        MISSING_ELSE
374        1/1                               if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
375                                          begin
376                                             chk_wtapnw_wsi_muxtdo_when_sel:
377        1/1                                  assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
378                                             else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                                          end
                        MISSING_ELSE
380        1/1                               if(|(tapc_select)) begin
381                                             chk_wtapnw_wsi_high_when_tapnw_sel:
382        1/1                                     assert property (sn_fwtap_wsi[b] === 1'b1)
383                                             else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                                          end
                        MISSING_ELSE
385                                       end
                        MISSING_ELSE
***repeat 1
366        1/1                            if (stap_fsm_tlrs === LOW)
367                                       begin
368        1/1                               if(wtap_sel_priority_internal[b] === 1'b0)
369                                          begin
370                                             chk_wtapnw_wsi_high_when_not_sel:
371        1/1                                  assert property (sn_fwtap_wsi[b] === 1'b1)
372                                             else $error("WTAP_SELECT_WSI is not High when not selected");
373                                          end
                        MISSING_ELSE
374        1/1                               if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
375                                          begin
376                                             chk_wtapnw_wsi_muxtdo_when_sel:
377        1/1                                  assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
378                                             else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                                          end
                        MISSING_ELSE
380        1/1                               if(|(tapc_select)) begin
381                                             chk_wtapnw_wsi_high_when_tapnw_sel:
382        1/1                                     assert property (sn_fwtap_wsi[b] === 1'b1)
383                                             else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                                          end
                        MISSING_ELSE
385                                       end
                        MISSING_ELSE
***repeat 2
366        1/1                            if (stap_fsm_tlrs === LOW)
367                                       begin
368        1/1                               if(wtap_sel_priority_internal[b] === 1'b0)
369                                          begin
370                                             chk_wtapnw_wsi_high_when_not_sel:
371        1/1                                  assert property (sn_fwtap_wsi[b] === 1'b1)
372                                             else $error("WTAP_SELECT_WSI is not High when not selected");
373                                          end
                        MISSING_ELSE
374        1/1                               if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
375                                          begin
376                                             chk_wtapnw_wsi_muxtdo_when_sel:
377        1/1                                  assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
378                                             else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                                          end
                        MISSING_ELSE
380        1/1                               if(|(tapc_select)) begin
381                                             chk_wtapnw_wsi_high_when_tapnw_sel:
382        1/1                                     assert property (sn_fwtap_wsi[b] === 1'b1)
383                                             else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                                          end
                        MISSING_ELSE
385                                       end
                        MISSING_ELSE
386                                    end
387                                 end
388                              end
389                           endgenerate
390                           // ====================================================================
391                           // To Check for the TDO Control and TDO out signals
392                           // ====================================================================
393                           generate
394                              if (STAP_ENABLE_WTAP_NETWORK === 1)
395                              begin:generate_chk_wtap_tdo
396                                 for (genvar c = 0; c < STAP_NUMBER_OF_WTAPS_IN_NETWORK_NZ; c = c + 1)
397                                 begin
398                                    always @(posedge ftap_tck)
399                                    begin
400        1/1                            if (stap_fsm_tlrs === LOW)
401                                       begin
402        1/1                               if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
403                                          begin
404                                             chk_wtapnw_tdo_wsi_sel:
405        1/1                                  assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
406                                             else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                                          end
                        MISSING_ELSE
408                                       end
                        MISSING_ELSE
***repeat 3
400        1/1                            if (stap_fsm_tlrs === LOW)
401                                       begin
402        1/1                               if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
403                                          begin
404                                             chk_wtapnw_tdo_wsi_sel:
405        1/1                                  assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
406                                             else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                                          end
                        MISSING_ELSE
408                                       end
                        MISSING_ELSE
***repeat 4
400        1/1                            if (stap_fsm_tlrs === LOW)
401                                       begin
402        1/1                               if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
403                                          begin
404                                             chk_wtapnw_tdo_wsi_sel:
405        1/1                                  assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
406                                             else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                                          end
                        MISSING_ELSE
408                                       end
                        MISSING_ELSE
409                                    end
410                                 end
411                              end
412                           endgenerate
413                     
414                     //********************************************************************************************************************
415                           // ====================================================================
416                           // Check WTAP controls sn_fwtap_capturewr changes only on a negedge 
417                           // of ftap_tck when parameter STAP_ENABLE_WTAP_CTRL_POS_EDGE = 0
418                           // ====================================================================
419                           property stap_assert_sn_fwtap_capturewr_during_negedge_clk;
420                              @(capturewr_delayed_by_1ps)
421                                disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
422                                (STAP_ENABLE_WTAP_CTRL_POS_EDGE === LOW) |-> (ftap_tck === LOW);
423                           endproperty: stap_assert_sn_fwtap_capturewr_during_negedge_clk
424                           chk_stap_assert_sn_fwtap_capturewr_during_negedge_clk:
425                           assert property (stap_assert_sn_fwtap_capturewr_during_negedge_clk)
426                           else $error ("sn_fwtap_capturewr is not asserted at negedge of tck when STAP_ENABLE_WTAP_CTRL_POS_EDGE = 0, but asserted at posedge");
427                     
428                           // ====================================================================
429                           // Check WTAP controls sn_fwtap_shiftwr changes only on a negedge 
430                           // of ftap_tck when parameter STAP_ENABLE_WTAP_CTRL_POS_EDGE = 0
431                           // ====================================================================
432                           property stap_assert_sn_fwtap_shiftwr_during_negedge_clk;
433                              @(shiftwr_delayed_by_1ps)
434                                disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
435                                (STAP_ENABLE_WTAP_CTRL_POS_EDGE === LOW) |-> (ftap_tck === LOW);
436                           endproperty: stap_assert_sn_fwtap_shiftwr_during_negedge_clk
437                           chk_stap_assert_sn_fwtap_shiftwr_during_negedge_clk:
438                           assert property (stap_assert_sn_fwtap_shiftwr_during_negedge_clk)
439                           else $error ("sn_fwtap_shiftwr is not asserted at negedge of tck when STAP_ENABLE_WTAP_CTRL_POS_EDGE = 0, but asserted at posedge");
440                     
441                           // ====================================================================
442                           // Check WTAP controls sn_fwtap_capturewr changes only on a posedge 
443                           // of ftap_tck when parameter STAP_ENABLE_WTAP_CTRL_POS_EDGE = 1
444                           // ====================================================================
445                           property stap_assert_sn_fwtap_capturewr_during_posedge_clk;
446                              @(capturewr_delayed_by_1ps)
447                                disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
448                                (STAP_ENABLE_WTAP_CTRL_POS_EDGE === HIGH) |-> (ftap_tck === HIGH);
449                           endproperty: stap_assert_sn_fwtap_capturewr_during_posedge_clk
450                           chk_stap_assert_sn_fwtap_capturewr_during_posedge_clk:
451                           assert property (stap_assert_sn_fwtap_capturewr_during_posedge_clk)
452                           else $error ("sn_fwtap_capturewr is not asserted at posedge of tck when STAP_ENABLE_WTAP_CTRL_POS_EDGE = 1, but asserted at negedge");
453                     
454                           // ====================================================================
455                           // Check WTAP controls sn_fwtap_shiftwr changes only on a posedge 
456                           // of ftap_tck when parameter STAP_ENABLE_WTAP_CTRL_POS_EDGE = 1
457                           // ====================================================================
458                           property stap_assert_sn_fwtap_shiftwr_during_posedge_clk;
459                              @(shiftwr_delayed_by_1ps)
460                                disable iff ((fdfx_powergood !== HIGH) || (ftap_trst_b !== HIGH))
461                                (STAP_ENABLE_WTAP_CTRL_POS_EDGE === HIGH) |-> (ftap_tck === HIGH);
462                           endproperty: stap_assert_sn_fwtap_shiftwr_during_posedge_clk
463                           chk_stap_assert_sn_fwtap_shiftwr_during_posedge_clk:
464                           assert property (stap_assert_sn_fwtap_shiftwr_during_posedge_clk)
465                           else $error ("sn_fwtap_shiftwr is not asserted at posedge of tck when STAP_ENABLE_WTAP_CTRL_POS_EDGE = 1, but asserted at negedge");
466                     
467                     //********************************************************************************************************************
468                           // ======================================================================
469                           // To Check for the TDO Control and TDO out signals based on the priority
470                           // logic implmented in sTAP.
471                           // ======================================================================
472                     
473                           logic gen_select_bscan_internal;
474                     
475                          // generate:stap_bscan
476                          //    if (STAP_ENABLE_BSCAN === 1)
477                          //       begin:generate_chk_bscan_sel
478                          //          //assign gen_select_bscan_internal = generate_stap_bscan.i_stap_bscan.select_bscan_internal;
479                          //          assign gen_select_bscan_internal = stap_bscan_select_bscan_internal;
480                          //       end
481                          //    else
482                          //       begin
483                          //          assign gen_select_bscan_internal = LOW;
484                          //       end
485                          // endgenerate
486                     assign gen_select_bscan_internal = stap_bscan_select_bscan_internal;
487                     
488                           always @(posedge ftap_tck)
489                           begin
490        1/1                   if (stap_fsm_tlrs === LOW && tapc_remove === LOW)
491                              begin
492                                 //-----------------------------------------------------------------
493                                 //if( ((select_bscan_internal === 1'b1) | (lcl_fbscan_runbist === 1'b1)) &
494        1/1                      if( ((gen_select_bscan_internal === 1'b1) | (stap_fbscan_runbist_en === 1'b1)) & (atap_tdoen === 1'b1) &
495                                     (STAP_ENABLE_BSCAN === 1) &
496                                     (stap_fsm_shift_dr === 1) )
497                                 begin
498                                    chk_tdo_fbscan_tdo_bscanreg_sel:
499        1/1                         assert property (atap_tdo === stap_abscan_tdo)
500                                    else $error("TDO is not equal to the Bscan TDO when Bscan is selected and not TAPNW");
501                                 end
                        MISSING_ELSE
502                                 //-----------------------------------------------------------------
503        1/1                      if( (gen_select_bscan_internal === 1'b0)   &
504                                     (stap_fbscan_runbist_en === 1'b0)      &
505                                     (|tapc_select) & (atap_tdoen === 1'b1) &
506                                     (STAP_ENABLE_BSCAN === 0) )
507                                 begin
508                                    chk_tdo_tapnw_tdo_sel:
509        0/1     ==>                 assert property (atap_tdo === sntapnw_atap_tdo)
510                                    else $error("TDO is not equal to the TAPNW TDO when tap nw is selected and Boundary Scan is not");
511                                 end
                        MISSING_ELSE
512                                 //-----------------------------------------------------------------
513        1/1                      if( (gen_select_bscan_internal === 1'b0)     &
514                                     (stap_fbscan_runbist_en === 1'b0)        &
515                                     (~(|(tapc_select)))                 &
516                                     (~(|(wtap_sel_priority_internal)))  &
517                                     (STAP_ENABLE_BSCAN === 0) )
518                                 begin
519                                    chk_tdo_int_tdo_no_tapnw_no_wtapnw_no_direct_wtap_sel:
520        0/1     ==>                 assert property (atap_tdo === stap_mux_tdo)
521                                    else $error("TDO is not equal to the STAP internal TDO when no TAP in 0.7 is selected and No tap in a WTAP NW is selected and Single WTAP is also not connected");
522                                 end
                        MISSING_ELSE
523                                 //-----------------------------------------------------------------
524                              end
                        MISSING_ELSE
525                           end
526                     
527                        // ====================================================================
528                        // 0.7 TAPNW: Checks if entap is high for Normal, Excluded, Shadow mode.
529                        // ====================================================================
530                        logic [(STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK_NZ * 2) - 1:0] select;
531                     
532                        assign select = tapc_select;
533                     
534                        generate
535                           if (STAP_ENABLE_TAP_NETWORK === 1)
536                           begin:generate_chk_tapnw_tap_mode
537                              for (genvar d = 0; d < STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK_NZ; d = d + 1)
538                              begin
539                                 always @(posedge ftap_tck)
540                                 begin
541        1/1                         if (fdfx_powergood === HIGH)
542                                    begin
543        1/1                            if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
544                                       begin
545                                          chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                                          assert (sftapnw_ftap_enabletap[d] === HIGH)
547                                          else $error("Entap is not supposed to be high for Isolated mode");
548                                       end
                        MISSING_ELSE
549                                    end
                        MISSING_ELSE
***repeat 5
541        1/1                         if (fdfx_powergood === HIGH)
542                                    begin
543        1/1                            if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
544                                       begin
545                                          chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                                          assert (sftapnw_ftap_enabletap[d] === HIGH)
547                                          else $error("Entap is not supposed to be high for Isolated mode");
548                                       end
                        MISSING_ELSE
549                                    end
                        MISSING_ELSE
***repeat 6
541        1/1                         if (fdfx_powergood === HIGH)
542                                    begin
543        1/1                            if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
544                                       begin
545                                          chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                                          assert (sftapnw_ftap_enabletap[d] === HIGH)
547                                          else $error("Entap is not supposed to be high for Isolated mode");
548                                       end
                        MISSING_ELSE
549                                    end
                        MISSING_ELSE
***repeat 7
541        1/1                         if (fdfx_powergood === HIGH)
542                                    begin
543        1/1                            if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
544                                       begin
545                                          chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                                          assert (sftapnw_ftap_enabletap[d] === HIGH)
547                                          else $error("Entap is not supposed to be high for Isolated mode");
548                                       end
                        MISSING_ELSE
549                                    end
                        MISSING_ELSE
550                                 end
551                              end
552                           end
553                        endgenerate
554                     
555                        // ====================================================================
556                        // 0.7 TAPNW Checks if entdo is low for Isolated and Shadow mode.
557                        // ====================================================================
558                        generate
559                           if (STAP_ENABLE_TAP_NETWORK === 1)
560                           begin:generate_chk_tdo_in_isolated_and_shadow_mode
561                              for (genvar e = 0; e < STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK_NZ; e = e + 1)
562                              begin
563                                 always @(posedge ftap_tck)
564                                 begin
565        1/1                         if (fdfx_powergood === HIGH)
566                                    begin
567        1/1                            if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
568                                       begin
569                                          chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                                          assert (sftapnw_ftap_enabletdo[e] === LOW)
571                                          else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                                       end
                        MISSING_ELSE
573                                    end
                        MISSING_ELSE
***repeat 8
565        1/1                         if (fdfx_powergood === HIGH)
566                                    begin
567        1/1                            if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
568                                       begin
569                                          chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                                          assert (sftapnw_ftap_enabletdo[e] === LOW)
571                                          else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                                       end
                        MISSING_ELSE
573                                    end
                        MISSING_ELSE
***repeat 9
565        1/1                         if (fdfx_powergood === HIGH)
566                                    begin
567        1/1                            if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
568                                       begin
569                                          chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                                          assert (sftapnw_ftap_enabletdo[e] === LOW)
571                                          else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                                       end
                        MISSING_ELSE
573                                    end
                        MISSING_ELSE
***repeat 10
565        1/1                         if (fdfx_powergood === HIGH)
566                                    begin
567        1/1                            if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
568                                       begin
569                                          chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                                          assert (sftapnw_ftap_enabletdo[e] === LOW)
571                                          else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                                       end
                        MISSING_ELSE
573                                    end
                        MISSING_ELSE
574                                 end
575                              end
576                           end
577                        endgenerate
578                     
579                        // ====================================================================
580                        // Check State is TLRS atleast after 5 Clocks of Remove Bit assertion
581                        // ====================================================================
582                        property present_state_tlrs_when_remove_asserted;
583                            @(negedge ftap_tck)
584                               disable iff (fdfx_powergood !== HIGH)
585                                  $rose(tapc_remove) ##0 tapc_remove[*5] |->  stap_fsm_state_ps === 16'h0001;
586                                  //$rose(tapc_remove) ##0 tapc_remove[*5] |->  i_stap_fsm.state_ps === 16'h0001;
587                        endproperty : present_state_tlrs_when_remove_asserted
588                        chk_present_state_tlrs_when_remove_asserted:
589                        assume property (present_state_tlrs_when_remove_asserted);
590                        //   else $error ("Present state is not equal to TLRS after 5 Clock Cycle of Remove getting asserted");
591                     
592                        // ====================================================================
593                        // The assertion of Remove Bit should happen while accessing Remove Register
594                        // and at UPDR state
595                        // ====================================================================
596                        property stap_assertion_remove_bit_at_updr;
597                           @(ftap_tck)
598                               disable iff (fdfx_powergood !== HIGH)
599                               $rose(tapc_remove) |-> (stap_irreg_ireg === 'h14) && (stap_fsm_state_ps === 16'h0100);
600                               //$rose(tapc_remove) |-> (stap_irreg_ireg === 'h14) && (i_stap_fsm.state_ps === 16'h0100);
601                        endproperty : stap_assertion_remove_bit_at_updr
602                        chk_stap_assertion_remove_bit_at_updr:
603                        assume property (stap_assertion_remove_bit_at_updr);
604                        //   else $error ("The Remove Bit is not asserted at UPDR and While Remove register is Asserted");
605                        `endif
606                     `endif
607                     
608                     //-------------------------------------------------------------------------------------------
609                     // To check for valid address positions in the Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS
610                     //-------------------------------------------------------------------------------------------
611                     `ifndef INTEL_SVA_OFF
612                        `ifdef DFX_PARAMETER_CHECKER
613                           `ifndef DFX_FPV_ENABLE
614                     
615                              logic [STAP_SIZE_OF_EACH_INSTRUCTION-1:0] stap_ir_opcode_position [STAP_NUMBER_OF_TOTAL_REGISTERS-1:0];
616                              int index = 1;
617                     
618                              initial
619                              begin
620                                 //for (int i=0, k=0; i < STAP_NUMBER_OF_TOTAL_REGISTERS; i++)
621                                 // Slicing enhancement after introducing Secure Opcode feature.
622                                 // Hence ignore lower two bits of color info in each opcode when populating stap_ir_opcode_position array
623        1/1                      for (int i=0, k=2; i < STAP_NUMBER_OF_TOTAL_REGISTERS; i++, k=k+2)
624                                 begin
625        1/1                         for (int j=0; j < STAP_SIZE_OF_EACH_INSTRUCTION; j++, k++)
626        1/1                            stap_ir_opcode_position[i][j] = STAP_INSTRUCTION_FOR_DATA_REGISTERS[k];
627        1/1                         $display ("stap_ir_opcode_position[%0d] = %0h", i, stap_ir_opcode_position[i]);
628                                 end
629                     
630                                 // Mandatory Registers
631                                 // Position 0, 1
632                                 chk_opcode_00:
633                                 assert (stap_ir_opcode_position[0] === {STAP_SIZE_OF_EACH_INSTRUCTION{1'b1}})
634                                 else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index: 0");
635                     
636                                 // Boundary Scan Mandatory Registers
637        1/1                      if (STAP_ENABLE_BSCAN === 1)
638                                 // Position 2, 3, 4
639                                 begin
640                                    chk_opcode_01:
641                                    assert (stap_ir_opcode_position[index] === 'h01)
642                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
643        1/1                         index++;
644                                    chk_opcode_08:
645                                    assert (stap_ir_opcode_position[index] === 'h08)
646                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
647        1/1                         index++;
648                                    chk_opcode_09:
649                                    assert (stap_ir_opcode_position[index] === 'h09)
650                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
651        1/1                         index++;
652                                 end
                   ==>  MISSING_ELSE
653                     
654                                 // SLVIDCODE
655                                 // Position 2 or 5
656                                 chk_opcode_0c:
657                                 assert (stap_ir_opcode_position[index] === 'h0c)
658                                 else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
659        1/1                      index++;
660                     
661                                 // Boundary Scan Mandatory Registers
662        1/1                      if (STAP_ENABLE_BSCAN === 1)
663                                 // Position 6, 7
664                                 begin
665                                    chk_opcode_0E:
666                                    assert (stap_ir_opcode_position[index] === 'h0E)
667                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
668        1/1                         index++;
669                                    chk_opcode_0F:
670                                    assert (stap_ir_opcode_position[index] === 'h0F)
671                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
672        1/1                         index++;
673                                 end
                   ==>  MISSING_ELSE
674                     
675                                 // Optional TAPC_SELECT Register
676        1/1                      if (STAP_ENABLE_TAP_NETWORK === 1)
677                                 // Position 3 or 8
678                                 begin
679                                    chk_opcode_11:
680                                    assert (stap_ir_opcode_position[index] === 'h11)
681                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
682        1/1                         index++;
683                                 end
                   ==>  MISSING_ELSE
684                     
685                                 // Boundary Scan Optional Registers
686                                 // Position 8 or 9
687        1/1                      if (STAP_ENABLE_BSCAN === 1)
688                                 begin
689                                    chk_opcode_03:
690                                    assert (stap_ir_opcode_position[index] === 'h03)
691                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
692        1/1                         index++;
693                                 end
                   ==>  MISSING_ELSE
694        1/1                      if (STAP_ENABLE_BSCAN === 1)
695                                 // Position 9 or 10
696                                 begin
697                                    chk_opcode_04:
698                                    assert (stap_ir_opcode_position[index] === 'h04)
699                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
700        1/1                         index++;
701                                 end
                   ==>  MISSING_ELSE
702        1/1                      if (STAP_ENABLE_BSCAN === 1)
703                                 // Position 10 or 11
704                                 begin
705                                    chk_opcode_06:
706                                    assert (stap_ir_opcode_position[index] === 'h06)
707                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
708        1/1                         index++;
709                                 end
                   ==>  MISSING_ELSE
710        1/1                      if (STAP_ENABLE_BSCAN === 1)
711                                 // Position 11 or 12
712                                 begin
713                                    chk_opcode_07:
714                                    assert (stap_ir_opcode_position[index] === 'h07)
715                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
716        1/1                         index++;
717                                 end
                   ==>  MISSING_ELSE
718        1/1                      if (STAP_ENABLE_BSCAN === 1)
719                                 // Position 12 or 13
720                                 begin
721                                    chk_opcode_0D:
722                                    assert (stap_ir_opcode_position[index] === 'h0D)
723                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
724        1/1                         index++;
725                                 end
                   ==>  MISSING_ELSE
726                     
727                                 // Optional TAPC_SEC_SELECT Register
728        1/1                      if (STAP_ENABLE_TAPC_SEC_SEL === 1)
729                                 // Position 4 or 9
730                                 begin
731                                    chk_opcode_10:
732                                    assert (stap_ir_opcode_position[index] === 'h10)
733                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
734        1/1                         index++;
735                                 end
                   ==>  MISSING_ELSE
736                     
737                                 // Optional TAPC_WTAP_SELECT Register
738        1/1                      if (STAP_ENABLE_WTAP_NETWORK === 1)
739                                 // Position 3 or above
740                                 begin
741                                    chk_opcode_13:
742                                    assert (stap_ir_opcode_position[index] === 'h13)
743                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
744        1/1                         index++;
745                                 end
                   ==>  MISSING_ELSE
746                     
747                                 // Optional Remove Register
748        1/1                      if (STAP_ENABLE_TAPC_REMOVE === 1)
749                                 // Position 3 or above
750                                 begin
751                                    chk_opcode_14:
752                                    assert (stap_ir_opcode_position[index] === 'h14)
753                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
754        1/1                         index++;
755                                 end
                   ==>  MISSING_ELSE
756                     
757                                 // Optional TAPC_TDRRSTEN
758        1/1                      if ((STAP_ENABLE_RTDR_PROG_RST === 1) || (STAP_ENABLE_ITDR_PROG_RST === 1))
759                                 // Position 3 or above
760                                 begin
761                                    chk_opcode_15:
762                                    assert (stap_ir_opcode_position[index] === 'h15)
763                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
764        1/1                         index++;
765                                 end
                   ==>  MISSING_ELSE
766                     
767                                 // Optional TAPC_ITDRRSTSEL
768        1/1                      if (STAP_ENABLE_ITDR_PROG_RST === 1)
769                                 // Position 3 or above
770                                 begin
771                                    chk_opcode_16:
772                                    assert (stap_ir_opcode_position[index] === 'h16)
773                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
774        1/1                         index++;
775                                 end
                   ==>  MISSING_ELSE
776                     
777                                 // Optional TAPC_RTDRRSTSEL
778        1/1                      if (STAP_ENABLE_RTDR_PROG_RST === 1)
779                                 // Position 3 or above
780                                 begin
781                                    chk_opcode_17:
782                                    assert (stap_ir_opcode_position[index] === 'h17)
783                                    else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
784        1/1                         index++;
785                                 end
                   ==>  MISSING_ELSE
786                     
787                                 // TDR
788        1/1                      if ((STAP_ENABLE_TEST_DATA_REGISTERS === 1) || (STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS === 1))
789                                 // Position 3 or above
790                                 begin
791        1/1                         while (index < STAP_NUMBER_OF_TOTAL_REGISTERS)
792                                    begin
793                                       chk_opcode_lesser_than_h30_or_equals_20_or_21:
794                     					  assert (((stap_ir_opcode_position[index] >= 'h30) || (stap_ir_opcode_position[index] === 'h20) || (stap_ir_opcode_position[index] === 'h21))&& 
795                     				  (stap_ir_opcode_position[index] < {STAP_SIZE_OF_EACH_INSTRUCTION{1'b1}}))
796                                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
797        1/1                            index++;
798                                    end
799                                 end
                   ==>  MISSING_ELSE
800                     
801                                 // To check IR register width
802                                 chk_instruction_size_greater_than_8:
803                                 assert (STAP_SIZE_OF_EACH_INSTRUCTION >= 'h8)
804                                 else $fatal ("Parameter STAP_SIZE_OF_EACH_INSTRUCTION is less than 8");
805                     
806                                 // To check that when STAP_ENABLE_TDO_POS_EDGE = 1, then other parameters are set to 0 for Bscan, TAPNW, WTAPNW.
807        1/1                      if (STAP_ENABLE_TDO_POS_EDGE === 1)
808                                 begin
809                                    chk_that_for_retimetap_feature_bscan_is_disabled:
810                                    assert (STAP_ENABLE_BSCAN === 0)
811                                    else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
812                                                 "you cannot use this TAP for Boundary Scan operations.");
813                     
814                                    chk_that_for_retimetap_feature_tapnw_is_disabled:
815                                    assert (STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK === 0)
816                                    else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
817                                                 "you cannot use this TAP for Controlling a Sub Tap Network");
818                     
819                                    chk_that_for_retimetap_feature_wtapnw_is_disabled:
820                                    assert (STAP_NUMBER_OF_WTAPS_IN_NETWORK === 0)
821                                    else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
822                                                 "you cannot use this TAP for Controlling a WTAP Network");
823                                 end
                        MISSING_ELSE
824                     
825                              end
826                           `endif // DFX_FPV_ENABLE
827                        `endif // DFX_PARAMETER_CHECKER
828                     `endif // INTEL_SVA_OFF
829                     
830                     //********************************************************************************************************************
831                     //-------------------------------------------------------------------------------------------
832                     // To check width of the ports which are multiple bits based on the condition
833                     //-------------------------------------------------------------------------------------------
834                     `ifndef INTEL_SVA_OFF
835                        `ifdef DFX_PARAMETER_CHECKER
836                           `ifndef DFX_FPV_ENABLE
837                     
838                              initial
839                              begin
840                                 // -----------------------------------------------------------------
841                                 // Check width of Parallel ports of optional data registers
842                                 // -----------------------------------------------------------------
843        1/1                      if (STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS === 0)
844                                 begin
845                                    chk_width_of_port_tdr_data_out_1:
846                                    assert ($size(tdr_data_out) === 1) 
847                                    else $fatal ("The width of port tdr_data_out is not equal 1 when STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS = 0");
848        0/1     ==>                 $display ("tdr_data_out_width     = %0d ", $size(tdr_data_out));
849                     
850                                    chk_width_of_port_tdr_data_in_1:
851                                    assert ($size(tdr_data_in) === 1) 
852                                    else $fatal ("The width of port tdr_data_in is not equal 1 when STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS = 0");
853        0/1     ==>                 $display ("tdr_data_in_width     = %0d ", $size(tdr_data_in));
854                                 end
855                                 else
856                                 begin
857                                    chk_width_of_port_tdr_data_out_2:
858                                    assert ($size(tdr_data_out) === STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS) 
859                                    else $fatal ("The width of port tdr_data_out is not equal to STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS");
860        1/1                         $display ("tdr_data_out_width     = %0d ", $size(tdr_data_out));
861                     
862                                    chk_width_of_port_tdr_data_in_2:
863                                    assert ($size(tdr_data_in) === STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS) 
864                                    else $fatal ("The width of port tdr_data_in is not equal to STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS");
865        1/1                         $display ("tdr_data_in_width     = %0d ", $size(tdr_data_in));
866                                 end   
867                     
868                                 // -----------------------------------------------------------------
869                                 // Check the width of Control ports to 0.7 TAPNetwork
870                                 // -----------------------------------------------------------------
871        1/1                      if (STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK === 0)
872                                 begin
873                                    chk_width_of_port_sftapnw_ftap_secsel_1:
874                                    assert ($size(sftapnw_ftap_secsel) === 1) 
875                                    else $fatal ("The width of port sftapnw_ftap_secsel is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
876        0/1     ==>                 $display ("sftapnw_ftap_secsel_width     = %0d ", $size(sftapnw_ftap_secsel));
877                     
878                                    chk_width_of_port_sftapnw_ftap_enabletdo_1:
879                                    assert ($size(sftapnw_ftap_enabletdo) === 1) 
880                                    else $fatal ("The width of port sftapnw_ftap_enabletdo is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
881        0/1     ==>                 $display ("sftapnw_ftap_enabletdo_width     = %0d ", $size(sftapnw_ftap_enabletdo));
882                     
883                                    chk_width_of_port_sftapnw_ftap_enabletap_1:
884                                    assert ($size(sftapnw_ftap_enabletap) === 1) 
885                                    else $fatal ("The width of port sftapnw_ftap_enabletap is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
886        0/1     ==>                 $display ("sftapnw_ftap_enabletap_width     = %0d ", $size(sftapnw_ftap_enabletap));
887                     
888                                    chk_width_of_port_sntapnw_atap_tdo_en_1:
889                                    assert ($size(sntapnw_atap_tdo_en) === 1) 
890                                    else $fatal ("The width of port sntapnw_atap_tdo_en is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
891        0/1     ==>                 $display ("sntapnw_atap_tdo_en_width     = %0d ", $size(sntapnw_atap_tdo_en));
892                     
893                                    chk_width_of_port_sntapnw_atap_tdo2_en_1:
894                                    assert ($size(sntapnw_atap_tdo2_en) === 1) 
895                                    else $fatal ("The width of port sntapnw_atap_tdo2_en is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
896        0/1     ==>                 $display ("sntapnw_atap_tdo2_en_width     = %0d ", $size(sntapnw_atap_tdo2_en));
897                                 end
898                                 else
899                                 begin
900                                    chk_width_of_port_sftapnw_ftap_secsel_2:
901                                    assert ($size(sftapnw_ftap_secsel) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
902                                    else $fatal ("The width of port sftapnw_ftap_secsel is not equal to STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK");
903        1/1                         $display ("sftapnw_ftap_secsel_width     = %0d ", $size(sftapnw_ftap_secsel));
904                     
905                                    chk_width_of_port_sftapnw_ftap_enabletdo_3:
906                                    assert ($size(sftapnw_ftap_enabletdo) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
907                                    else $fatal ("The width of port sftapnw_ftap_enabletdo is not equal to STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK");
908        1/1                         $display ("sftapnw_ftap_enabletdo_width     = %0d ", $size(sftapnw_ftap_enabletdo));
909                     
910                                    chk_width_of_port_sftapnw_ftap_enabletap_2:
911                                    assert ($size(sftapnw_ftap_enabletap) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
912                                    else $fatal ("The width of port sftapnw_ftap_enabletap is not equal to STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK");
913        1/1                         $display ("sftapnw_ftap_enabletap_width     = %0d ", $size(sftapnw_ftap_enabletap));
914                     
915                                    chk_width_of_port_sntapnw_atap_tdo_en_2:
916                                    assert ($size(sntapnw_atap_tdo_en) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
917                                    else $fatal ("The width of port sntapnw_atap_tdo_en is not equal to STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK");
918        1/1                         $display ("sntapnw_atap_tdo_en_width     = %0d ", $size(sntapnw_atap_tdo_en));
919                     
920                                    chk_width_of_port_sntapnw_atap_tdo2_en_2:
921                                    assert ($size(sntapnw_atap_tdo2_en) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
922                                    else $fatal ("The width of port sntapnw_atap_tdo2_en is not equal to STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK");
923        1/1                         $display ("sntapnw_atap_tdo2_en_width     = %0d ", $size(sntapnw_atap_tdo2_en));
924                                 end   
925                     
926                                 // -----------------------------------------------------------------
927                                 // Check the width of Control prots only to WTAP Network
928                                 // -----------------------------------------------------------------
929        1/1                      if ((STAP_NUMBER_OF_WTAPS_IN_NETWORK === 0) || (STAP_WTAP_NETWORK_ONE_FOR_SERIES_ZERO_FOR_PARALLEL === 1))
930                                 begin
931                                    chk_width_of_port_sn_awtap_wso_1:
932                                    assert ($size(sn_awtap_wso) === 1) 
933                                    else $fatal ("The width of port sn_awtap_wso is not equal 1 when STAP_NUMBER_OF_WTAPS_IN_NETWORK = 0");
934        0/1     ==>                 $display ("sn_awtap_wso_width     = %0d ", $size(sn_awtap_wso));
935                     
936                                    chk_width_of_port_sn_fwtap_wsi_1:
937                                    assert ($size(sn_fwtap_wsi) === 1) 
938                                    else $fatal ("The width of port sn_fwtap_wsi is not equal 1 when STAP_NUMBER_OF_WTAPS_IN_NETWORK = 0");
939        0/1     ==>                 $display ("sn_fwtap_wsi_width     = %0d ", $size(sn_fwtap_wsi));
940                                 end
941                                 else
942                                 begin  
943                                    chk_width_of_port_sn_awtap_wso_2:
944                                    assert ($size(sn_awtap_wso) === STAP_NUMBER_OF_WTAPS_IN_NETWORK) 
945                                    else $fatal ("The width of port sn_awtap_wso is not equal to STAP_NUMBER_OF_WTAPS_IN_NETWORK");
946        1/1                         $display ("sn_awtap_wso_en_width     = %0d ", $size(sn_awtap_wso));
947                     
948                                    chk_width_of_port_sn_fwtap_wsi_2:
949                                    assert ($size(sn_fwtap_wsi) === STAP_NUMBER_OF_WTAPS_IN_NETWORK) 
950                                    else $fatal ("The width of port sn_fwtap_wsi is not equal to STAP_NUMBER_OF_WTAPS_IN_NETWORK");
951        1/1                         $display ("sn_fwtap_wsi_width     = %0d ", $size(sn_fwtap_wsi));
952                                 end   
953                     
954                                 //------------------------------------------------------------------
955                                 // To check the port widths of RTDR
956                                 //------------------------------------------------------------------
957        1/1                      if (STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS === 1)
958                                 begin
959                                    chk_width_of_port_rtdr_tap_tdo_1:
960                                    assert ($size(rtdr_tap_tdo) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
961                                    else $fatal ("The width of port rtdr_tap_tdo is not equal to number RTDRs");
962        1/1                         $display ("rtdr_tap_tdo_width  = %0d ", $size(rtdr_tap_tdo));
963                     
964                                    chk_width_of_port_tap_rtdr_irdec_1:
965                                    assert ($size(tap_rtdr_irdec) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
966                                    else $fatal ("The width of port tap_rtdr_irdec is not equal to number RTDRs");
967        1/1                         $display ("tap_rtdr_irdec_width  = %0d ", $size(tap_rtdr_irdec));
968                     
969                                    chk_width_of_port_tap_rtdr_prog_rst_b_1:
970                                    assert ($size(tap_rtdr_prog_rst_b) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
971                                    else $fatal ("The width of port tap_rtdr_prog_rst_b is not equal to number RTDRs");
972        1/1                         $display ("tap_rtdr_prog_rst_b_width  = %0d ", $size(tap_rtdr_prog_rst_b));
973                     
974        1/1                         if (STAP_RTDR_IS_BUSSED === 1)
975                                    begin  
976                                       chk_width_of_port_tap_rtdr_tdi_1:
977                                       assert ($size(tap_rtdr_tdi) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
978                                       else $fatal ("The width of port tap_rtdr_tdi is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
979        1/1                            $display ("tap_rtdr_tdi_width     = %0d ", $size(tap_rtdr_tdi));
980                     
981                                       chk_width_of_port_tap_rtdr_capture_1:
982                                       assert ($size(tap_rtdr_capture) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
983                                       else $fatal ("The width of port tap_rtdr_capture is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
984        1/1                            $display ("tap_rtdr_capture_width = %0d ", $size(tap_rtdr_capture));
985                     
986                                       chk_width_of_port_tap_rtdr_shift_1:
987                                       assert ($size(tap_rtdr_shift) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
988                                       else $fatal ("The width of port tap_rtdr_shift is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
989        1/1                            $display ("tap_rtdr_shift_width   = %0d ", $size(tap_rtdr_shift));
990                     
991                                       chk_width_of_port_tap_rtdr_update_1:
992                                       assert ($size(tap_rtdr_update) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
993                                       else $fatal ("The width of port tap_rtdr_update is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
994        1/1                            $display ("tap_rtdr_update_width  = %0d ", $size(tap_rtdr_update));
995                                    end
996                                    else
997                                    begin
998                                       chk_width_of_port_tap_rtdr_tdi_2:
999                                       assert ($size(tap_rtdr_tdi) === 1) 
1000                                      else $fatal ("The width of port tap_rtdr_tdi is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1001       0/1     ==>                    $display ("tap_rtdr_tdi_width     = %0d ", $size(tap_rtdr_tdi));
1002                    
1003                                      chk_width_of_port_tap_rtdr_capture_2:
1004                                      assert ($size(tap_rtdr_capture) === 1) 
1005                                      else $fatal ("The width of port tap_rtdr_capture is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1006       0/1     ==>                    $display ("tap_rtdr_capture_width = %0d ", $size(tap_rtdr_capture));
1007                    
1008                                      chk_width_of_port_tap_rtdr_shift_2:
1009                                      assert ($size(tap_rtdr_shift) === 1) 
1010                                      else $fatal ("The width of port tap_rtdr_shift is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1011       0/1     ==>                    $display ("tap_rtdr_shift_width   = %0d ", $size(tap_rtdr_shift));
1012                    
1013                                      chk_width_of_port_tap_rtdr_update_2:
1014                                      assert ($size(tap_rtdr_update) === 1) 
1015                                      else $fatal ("The width of port tap_rtdr_update is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1016       0/1     ==>                    $display ("tap_rtdr_update_width  = %0d ", $size(tap_rtdr_update));
1017                                   end   
1018                                end
1019                                else
1020                                begin
1021                                   chk_width_of_port_rtdr_tap_tdo_3:
1022                                   assert ($size(rtdr_tap_tdo) === 1) 
1023                                   else $fatal ("The width of port rtdr_tap_tdo is not equal 1 when RTDR not selected");
1024       0/1     ==>                 $display ("rtdr_tap_tdo_width  = %0d ", $size(rtdr_tap_tdo));
1025                    
1026                                   chk_width_of_port_tap_rtdr_irdec_3:
1027                                   assert ($size(tap_rtdr_irdec) === 1) 
1028                                   else $fatal ("The width of port tap_rtdr_irdec is not equal 1 when RTDR not selected");
1029       0/1     ==>                 $display ("tap_rtdr_irdec_width  = %0d ", $size(tap_rtdr_irdec));
1030                    
1031                                   chk_width_of_port_tap_rtdr_prog_rst_b_3:
1032                                   assert ($size(tap_rtdr_prog_rst_b) === 1) 
1033                                   else $fatal ("The width of port tap_rtdr_prog_rst_b is not equal 1 when RTDR not selected");
1034       0/1     ==>                 $display ("tap_rtdr_prog_rst_b_width  = %0d ", $size(tap_rtdr_prog_rst_b));
1035                    
1036                                   chk_width_of_port_tap_rtdr_tdi_3:
1037                                   assert ($size(tap_rtdr_tdi) === 1) 
1038                                   else $fatal ("The width of port tap_rtdr_tdi is not equal 1 when RTDR not selected");
1039       0/1     ==>                 $display ("tap_rtdr_tdi_width     = %0d ", $size(tap_rtdr_tdi));
1040                    
1041                                   chk_width_of_port_tap_rtdr_capture_3:
1042                                   assert ($size(tap_rtdr_capture) === 1) 
1043                                   else $fatal ("The width of port tap_rtdr_capture is not equal 1 when RTDR not selected");
1044       0/1     ==>                 $display ("tap_rtdr_capture_width = %0d ", $size(tap_rtdr_capture));
1045                    
1046                                   chk_width_of_port_tap_rtdr_shift_3:
1047                                   assert ($size(tap_rtdr_shift) === 1) 
1048                                   else $fatal ("The width of port tap_rtdr_shift is not equal 1 when RTDR not selected");
1049       0/1     ==>                 $display ("tap_rtdr_shift_width   = %0d ", $size(tap_rtdr_shift));
1050                    
1051                                   chk_width_of_port_tap_rtdr_update_3:
1052                                   assert ($size(tap_rtdr_update) === 1) 
1053                                   else $fatal ("The width of port tap_rtdr_update is not equal 1 when RTDR not selected");
1054       0/1     ==>                 $display ("tap_rtdr_update_width  = %0d ", $size(tap_rtdr_update));

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_top_assertions 
                Total Covered Percent 
Totals          73    56      76.71   
Total Bits      688   527     76.60   
Total Bits 0->1 344   264     76.74   
Total Bits 1->0 344   263     76.45   

                              
Ports          43  42  97.67  
Port Bits      482 481 99.79  
Port Bits 0->1 241 241 100.00 
Port Bits 1->0 241 240 99.59  

                               
Signals          30  14 46.67  
Signal Bits      206 46 22.33  
Signal Bits 0->1 103 23 22.33  
Signal Bits 1->0 103 23 22.33  

Port Details
                                 Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_fsm_tlrs                    Yes    Yes         Yes         INPUT     
sn_fwtap_capturewr               Yes    Yes         Yes         INPUT     
sn_fwtap_shiftwr                 Yes    Yes         Yes         INPUT     
ftap_tms                         Yes    Yes         Yes         INPUT     
ftap_tdi                         Yes    Yes         Yes         INPUT     
ftap_tck                         Yes    Yes         Yes         INPUT     
ftap_trst_b                      Yes    Yes         Yes         INPUT     
tapc_wtap_sel[2:0]               Yes    Yes         Yes         INPUT     
fdfx_powergood                   Yes    Yes         Yes         INPUT     
stap_fsm_shift_ir                Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr                Yes    Yes         Yes         INPUT     
atap_tdo                         Yes    Yes         Yes         INPUT     
atap_tdoen                       Yes    Yes         Yes         INPUT     
tapc_remove                      No     No          Yes         INPUT     
powergood_rst_trst_b             Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo_en[3:0]         Yes    Yes         Yes         INPUT     
sn_fwtap_selectwir               Yes    Yes         Yes         INPUT     
stap_selectwir                   Yes    Yes         Yes         INPUT     
stap_fbscan_runbist_en           Yes    Yes         Yes         INPUT     
sn_fwtap_wsi[2:0]                Yes    Yes         Yes         INPUT     
tapc_select[7:0]                 Yes    Yes         Yes         INPUT     
stap_mux_tdo                     Yes    Yes         Yes         INPUT     
stap_wtapnw_tdo                  Yes    Yes         Yes         INPUT     
stap_abscan_tdo                  Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo                 Yes    Yes         Yes         INPUT     
sn_awtap_wso[2:0]                Yes    Yes         Yes         INPUT     
sftapnw_ftap_enabletap[3:0]      Yes    Yes         Yes         INPUT     
sftapnw_ftap_enabletdo[3:0]      Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]            Yes    Yes         Yes         INPUT     
tdr_data_out[63:0]               Yes    Yes         Yes         INPUT     
tdr_data_in[63:0]                Yes    Yes         Yes         INPUT     
sftapnw_ftap_secsel[3:0]         Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo2_en[3:0]        Yes    Yes         Yes         INPUT     
rtdr_tap_tdo[2:0]                Yes    Yes         Yes         INPUT     
tap_rtdr_irdec[2:0]              Yes    Yes         Yes         INPUT     
tap_rtdr_prog_rst_b[2:0]         Yes    Yes         Yes         INPUT     
tap_rtdr_tdi[2:0]                Yes    Yes         Yes         INPUT     
tap_rtdr_capture[2:0]            Yes    Yes         Yes         INPUT     
tap_rtdr_shift[2:0]              Yes    Yes         Yes         INPUT     
tap_rtdr_update[2:0]             Yes    Yes         Yes         INPUT     
stap_fsm_state_ps[15:0]          Yes    Yes         Yes         INPUT     
sntapnw_ftap_tdi                 Yes    Yes         Yes         INPUT     
stap_bscan_select_bscan_internal Yes    Yes         Yes         INPUT     

Signal Details
                                  Toggle Toggle 1->0 Toggle 0->1 
tlrs                              Yes    Yes         Yes         
ftap_tms_delayed_by_1ps           Yes    Yes         Yes         
ftap_tdi_delayed_by_1ps           Yes    Yes         Yes         
ftap_tck_delayed_by_1ps           Yes    Yes         Yes         
ftap_trst_b_delayed_by_1ps        Yes    Yes         Yes         
ftap_trst_b_raising_edge_pulse    Yes    Yes         Yes         
ftap_trst_b_falling_edge_pulse    Yes    Yes         Yes         
ftap_tms_pulse                    Yes    Yes         Yes         
ftap_tdi_pulse                    Yes    Yes         Yes         
capturewr_delayed_by_1ps          Yes    Yes         Yes         
shiftwr_delayed_by_1ps            Yes    Yes         Yes         
wtap_sel_priority_internal[2:0]   Yes    Yes         Yes         
gen_select_bscan_internal         Yes    Yes         Yes         
select[7:0]                       Yes    Yes         Yes         
stap_secure_policy_matrix_0[4:0]  No     No          No          
stap_secure_policy_matrix_1[4:0]  No     No          No          
stap_secure_policy_matrix_2[4:0]  No     No          No          
stap_secure_policy_matrix_3[4:0]  No     No          No          
stap_secure_policy_matrix_4[4:0]  No     No          No          
stap_secure_policy_matrix_5[4:0]  No     No          No          
stap_secure_policy_matrix_6[4:0]  No     No          No          
stap_secure_policy_matrix_7[4:0]  No     No          No          
stap_secure_policy_matrix_8[4:0]  No     No          No          
stap_secure_policy_matrix_9[4:0]  No     No          No          
stap_secure_policy_matrix_10[4:0] No     No          No          
stap_secure_policy_matrix_11[4:0] No     No          No          
stap_secure_policy_matrix_12[4:0] No     No          No          
stap_secure_policy_matrix_13[4:0] No     No          No          
stap_secure_policy_matrix_14[4:0] No     No          No          
stap_secure_policy_matrix_15[4:0] No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_top_assertions 
         Line No. Total Covered Percent 
Branches          104   81      77.88   
IF       490      7     5       71.43   
IF       637      2     1       50.00   
IF       662      2     1       50.00   
IF       676      2     1       50.00   
IF       687      2     1       50.00   
IF       694      2     1       50.00   
IF       702      2     1       50.00   
IF       710      2     1       50.00   
IF       718      2     1       50.00   
IF       728      2     1       50.00   
IF       738      2     1       50.00   
IF       748      2     1       50.00   
IF       758      2     1       50.00   
IF       768      2     1       50.00   
IF       778      2     1       50.00   
IF       788      2     1       50.00   
IF       807      2     1       50.00   
IF       843      2     1       50.00   
IF       871      2     1       50.00   
IF       929      2     1       50.00   
IF       957      3     1       33.33   
IF       346      2     2       100.00  
IF       366      7     7       100.00  
IF       366      7     7       100.00  
IF       366      7     7       100.00  
IF       400      3     3       100.00  
IF       400      3     3       100.00  
IF       400      3     3       100.00  
IF       541      3     3       100.00  
IF       541      3     3       100.00  
IF       541      3     3       100.00  
IF       541      3     3       100.00  
IF       565      3     3       100.00  
IF       565      3     3       100.00  
IF       565      3     3       100.00  
IF       565      3     3       100.00  


490                 if (stap_fsm_tlrs === LOW && tapc_remove === LOW)
                    -1-  
491                 begin
492                    //-----------------------------------------------------------------
493                    //if( ((select_bscan_internal === 1'b1) | (lcl_fbscan_runbist === 1'b1)) &
494                    if( ((gen_select_bscan_internal === 1'b1) | (stap_fbscan_runbist_en === 1'b1)) & (atap_tdoen === 1'b1) &
                       -2-  
495                        (STAP_ENABLE_BSCAN === 1) &
496                        (stap_fsm_shift_dr === 1) )
497                    begin
498                       chk_tdo_fbscan_tdo_bscanreg_sel:
499                       assert property (atap_tdo === stap_abscan_tdo)
                          ==>
500                       else $error("TDO is not equal to the Bscan TDO when Bscan is selected and not TAPNW");
501                    end
                       MISSING_ELSE
                       ==>
502                    //-----------------------------------------------------------------
503                    if( (gen_select_bscan_internal === 1'b0)   &
                       -3-  
504                        (stap_fbscan_runbist_en === 1'b0)      &
505                        (|tapc_select) & (atap_tdoen === 1'b1) &
506                        (STAP_ENABLE_BSCAN === 0) )
507                    begin
508                       chk_tdo_tapnw_tdo_sel:
509                       assert property (atap_tdo === sntapnw_atap_tdo)
                          ==>
510                       else $error("TDO is not equal to the TAPNW TDO when tap nw is selected and Boundary Scan is not");
511                    end
                       MISSING_ELSE
                       ==>
512                    //-----------------------------------------------------------------
513                    if( (gen_select_bscan_internal === 1'b0)     &
                       -4-  
514                        (stap_fbscan_runbist_en === 1'b0)        &
515                        (~(|(tapc_select)))                 &
516                        (~(|(wtap_sel_priority_internal)))  &
517                        (STAP_ENABLE_BSCAN === 0) )
518                    begin
519                       chk_tdo_int_tdo_no_tapnw_no_wtapnw_no_direct_wtap_sel:
520                       assert property (atap_tdo === stap_mux_tdo)
                          ==>
521                       else $error("TDO is not equal to the STAP internal TDO when no TAP in 0.7 is selected and No tap in a WTAP NW is selected and Single WTAP is also not connected");
522                    end
                       MISSING_ELSE
                       ==>
523                    //-----------------------------------------------------------------
524                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- -3- -4- Status      
1   1   -   -   Covered     
1   0   -   -   Covered     
1   -   1   -   Not Covered 
1   -   0   -   Covered     
1   -   -   1   Not Covered 
1   -   -   0   Covered     
0   -   -   -   Covered     


637                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
638                    // Position 2, 3, 4
639                    begin
640                       chk_opcode_01:
641                       assert (stap_ir_opcode_position[index] === 'h01)
                          ==>
642                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
643                       index++;
644                       chk_opcode_08:
645                       assert (stap_ir_opcode_position[index] === 'h08)
646                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
647                       index++;
648                       chk_opcode_09:
649                       assert (stap_ir_opcode_position[index] === 'h09)
650                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
651                       index++;
652                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


662                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
663                    // Position 6, 7
664                    begin
665                       chk_opcode_0E:
666                       assert (stap_ir_opcode_position[index] === 'h0E)
                          ==>
667                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
668                       index++;
669                       chk_opcode_0F:
670                       assert (stap_ir_opcode_position[index] === 'h0F)
671                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
672                       index++;
673                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


676                    if (STAP_ENABLE_TAP_NETWORK === 1)
                       -1-  
677                    // Position 3 or 8
678                    begin
679                       chk_opcode_11:
680                       assert (stap_ir_opcode_position[index] === 'h11)
                          ==>
681                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
682                       index++;
683                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


687                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
688                    begin
689                       chk_opcode_03:
690                       assert (stap_ir_opcode_position[index] === 'h03)
                          ==>
691                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
692                       index++;
693                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


694                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
695                    // Position 9 or 10
696                    begin
697                       chk_opcode_04:
698                       assert (stap_ir_opcode_position[index] === 'h04)
                          ==>
699                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
700                       index++;
701                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


702                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
703                    // Position 10 or 11
704                    begin
705                       chk_opcode_06:
706                       assert (stap_ir_opcode_position[index] === 'h06)
                          ==>
707                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
708                       index++;
709                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


710                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
711                    // Position 11 or 12
712                    begin
713                       chk_opcode_07:
714                       assert (stap_ir_opcode_position[index] === 'h07)
                          ==>
715                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
716                       index++;
717                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


718                    if (STAP_ENABLE_BSCAN === 1)
                       -1-  
719                    // Position 12 or 13
720                    begin
721                       chk_opcode_0D:
722                       assert (stap_ir_opcode_position[index] === 'h0D)
                          ==>
723                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
724                       index++;
725                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


728                    if (STAP_ENABLE_TAPC_SEC_SEL === 1)
                       -1-  
729                    // Position 4 or 9
730                    begin
731                       chk_opcode_10:
732                       assert (stap_ir_opcode_position[index] === 'h10)
                          ==>
733                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
734                       index++;
735                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


738                    if (STAP_ENABLE_WTAP_NETWORK === 1)
                       -1-  
739                    // Position 3 or above
740                    begin
741                       chk_opcode_13:
742                       assert (stap_ir_opcode_position[index] === 'h13)
                          ==>
743                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
744                       index++;
745                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


748                    if (STAP_ENABLE_TAPC_REMOVE === 1)
                       -1-  
749                    // Position 3 or above
750                    begin
751                       chk_opcode_14:
752                       assert (stap_ir_opcode_position[index] === 'h14)
                          ==>
753                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
754                       index++;
755                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


758                    if ((STAP_ENABLE_RTDR_PROG_RST === 1) || (STAP_ENABLE_ITDR_PROG_RST === 1))
                       -1-  
759                    // Position 3 or above
760                    begin
761                       chk_opcode_15:
762                       assert (stap_ir_opcode_position[index] === 'h15)
                          ==>
763                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
764                       index++;
765                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


768                    if (STAP_ENABLE_ITDR_PROG_RST === 1)
                       -1-  
769                    // Position 3 or above
770                    begin
771                       chk_opcode_16:
772                       assert (stap_ir_opcode_position[index] === 'h16)
                          ==>
773                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
774                       index++;
775                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


778                    if (STAP_ENABLE_RTDR_PROG_RST === 1)
                       -1-  
779                    // Position 3 or above
780                    begin
781                       chk_opcode_17:
782                       assert (stap_ir_opcode_position[index] === 'h17)
                          ==>
783                       else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
784                       index++;
785                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


788                    if ((STAP_ENABLE_TEST_DATA_REGISTERS === 1) || (STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS === 1))
                       -1-  
789                    // Position 3 or above
790                    begin
791                       while (index < STAP_NUMBER_OF_TOTAL_REGISTERS)
                          ==>
792                       begin
793                          chk_opcode_lesser_than_h30_or_equals_20_or_21:
794        					  assert (((stap_ir_opcode_position[index] >= 'h30) || (stap_ir_opcode_position[index] === 'h20) || (stap_ir_opcode_position[index] === 'h21))&& 
795        				  (stap_ir_opcode_position[index] < {STAP_SIZE_OF_EACH_INSTRUCTION{1'b1}}))
796                          else $fatal ("Parameter STAP_INSTRUCTION_FOR_DATA_REGISTERS is not correct at index:%0d", index);
797                          index++;
798                       end
799                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Covered     
0   Not Covered 


807                    if (STAP_ENABLE_TDO_POS_EDGE === 1)
                       -1-  
808                    begin
809                       chk_that_for_retimetap_feature_bscan_is_disabled:
810                       assert (STAP_ENABLE_BSCAN === 0)
                          ==>
811                       else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
812                                    "you cannot use this TAP for Boundary Scan operations.");
813        
814                       chk_that_for_retimetap_feature_tapnw_is_disabled:
815                       assert (STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK === 0)
816                       else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
817                                    "you cannot use this TAP for Controlling a Sub Tap Network");
818        
819                       chk_that_for_retimetap_feature_wtapnw_is_disabled:
820                       assert (STAP_NUMBER_OF_WTAPS_IN_NETWORK === 0)
821                       else $fatal ("When the current TAP is used for retime by setting parameter STAP_ENABLE_TDO_POS_EDGE to 1,\n",
822                                    "you cannot use this TAP for Controlling a WTAP Network");
823                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


843                    if (STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS === 0)
                       -1-  
844                    begin
845                       chk_width_of_port_tdr_data_out_1:
846                       assert ($size(tdr_data_out) === 1) 
                          ==>
847                       else $fatal ("The width of port tdr_data_out is not equal 1 when STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS = 0");
848                       $display ("tdr_data_out_width     = %0d ", $size(tdr_data_out));
849        
850                       chk_width_of_port_tdr_data_in_1:
851                       assert ($size(tdr_data_in) === 1) 
852                       else $fatal ("The width of port tdr_data_in is not equal 1 when STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS = 0");
853                       $display ("tdr_data_in_width     = %0d ", $size(tdr_data_in));
854                    end
855                    else
856                    begin
857                       chk_width_of_port_tdr_data_out_2:
858                       assert ($size(tdr_data_out) === STAP_TOTAL_WIDTH_OF_TEST_DATA_REGISTERS) 
                          ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


871                    if (STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK === 0)
                       -1-  
872                    begin
873                       chk_width_of_port_sftapnw_ftap_secsel_1:
874                       assert ($size(sftapnw_ftap_secsel) === 1) 
                          ==>
875                       else $fatal ("The width of port sftapnw_ftap_secsel is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
876                       $display ("sftapnw_ftap_secsel_width     = %0d ", $size(sftapnw_ftap_secsel));
877        
878                       chk_width_of_port_sftapnw_ftap_enabletdo_1:
879                       assert ($size(sftapnw_ftap_enabletdo) === 1) 
880                       else $fatal ("The width of port sftapnw_ftap_enabletdo is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
881                       $display ("sftapnw_ftap_enabletdo_width     = %0d ", $size(sftapnw_ftap_enabletdo));
882        
883                       chk_width_of_port_sftapnw_ftap_enabletap_1:
884                       assert ($size(sftapnw_ftap_enabletap) === 1) 
885                       else $fatal ("The width of port sftapnw_ftap_enabletap is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
886                       $display ("sftapnw_ftap_enabletap_width     = %0d ", $size(sftapnw_ftap_enabletap));
887        
888                       chk_width_of_port_sntapnw_atap_tdo_en_1:
889                       assert ($size(sntapnw_atap_tdo_en) === 1) 
890                       else $fatal ("The width of port sntapnw_atap_tdo_en is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
891                       $display ("sntapnw_atap_tdo_en_width     = %0d ", $size(sntapnw_atap_tdo_en));
892        
893                       chk_width_of_port_sntapnw_atap_tdo2_en_1:
894                       assert ($size(sntapnw_atap_tdo2_en) === 1) 
895                       else $fatal ("The width of port sntapnw_atap_tdo2_en is not equal 1 when STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK = 0");
896                       $display ("sntapnw_atap_tdo2_en_width     = %0d ", $size(sntapnw_atap_tdo2_en));
897                    end
898                    else
899                    begin
900                       chk_width_of_port_sftapnw_ftap_secsel_2:
901                       assert ($size(sftapnw_ftap_secsel) === STAP_NUMBER_OF_TAPS_IN_TAP_NETWORK) 
                          ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


929                    if ((STAP_NUMBER_OF_WTAPS_IN_NETWORK === 0) || (STAP_WTAP_NETWORK_ONE_FOR_SERIES_ZERO_FOR_PARALLEL === 1))
                       -1-  
930                    begin
931                       chk_width_of_port_sn_awtap_wso_1:
932                       assert ($size(sn_awtap_wso) === 1) 
                          ==>
933                       else $fatal ("The width of port sn_awtap_wso is not equal 1 when STAP_NUMBER_OF_WTAPS_IN_NETWORK = 0");
934                       $display ("sn_awtap_wso_width     = %0d ", $size(sn_awtap_wso));
935        
936                       chk_width_of_port_sn_fwtap_wsi_1:
937                       assert ($size(sn_fwtap_wsi) === 1) 
938                       else $fatal ("The width of port sn_fwtap_wsi is not equal 1 when STAP_NUMBER_OF_WTAPS_IN_NETWORK = 0");
939                       $display ("sn_fwtap_wsi_width     = %0d ", $size(sn_fwtap_wsi));
940                    end
941                    else
942                    begin  
943                       chk_width_of_port_sn_awtap_wso_2:
944                       assert ($size(sn_awtap_wso) === STAP_NUMBER_OF_WTAPS_IN_NETWORK) 
                          ==>

Branches:

-1- Status      
1   Not Covered 
0   Covered     


957                    if (STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS === 1)
                       -1-  
958                    begin
959                       chk_width_of_port_rtdr_tap_tdo_1:
960                       assert ($size(rtdr_tap_tdo) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
961                       else $fatal ("The width of port rtdr_tap_tdo is not equal to number RTDRs");
962                       $display ("rtdr_tap_tdo_width  = %0d ", $size(rtdr_tap_tdo));
963        
964                       chk_width_of_port_tap_rtdr_irdec_1:
965                       assert ($size(tap_rtdr_irdec) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
966                       else $fatal ("The width of port tap_rtdr_irdec is not equal to number RTDRs");
967                       $display ("tap_rtdr_irdec_width  = %0d ", $size(tap_rtdr_irdec));
968        
969                       chk_width_of_port_tap_rtdr_prog_rst_b_1:
970                       assert ($size(tap_rtdr_prog_rst_b) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
971                       else $fatal ("The width of port tap_rtdr_prog_rst_b is not equal to number RTDRs");
972                       $display ("tap_rtdr_prog_rst_b_width  = %0d ", $size(tap_rtdr_prog_rst_b));
973        
974                       if (STAP_RTDR_IS_BUSSED === 1)
                          -2-  
975                       begin  
976                          chk_width_of_port_tap_rtdr_tdi_1:
977                          assert ($size(tap_rtdr_tdi) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
                             ==>
978                          else $fatal ("The width of port tap_rtdr_tdi is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
979                          $display ("tap_rtdr_tdi_width     = %0d ", $size(tap_rtdr_tdi));
980        
981                          chk_width_of_port_tap_rtdr_capture_1:
982                          assert ($size(tap_rtdr_capture) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
983                          else $fatal ("The width of port tap_rtdr_capture is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
984                          $display ("tap_rtdr_capture_width = %0d ", $size(tap_rtdr_capture));
985        
986                          chk_width_of_port_tap_rtdr_shift_1:
987                          assert ($size(tap_rtdr_shift) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
988                          else $fatal ("The width of port tap_rtdr_shift is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
989                          $display ("tap_rtdr_shift_width   = %0d ", $size(tap_rtdr_shift));
990        
991                          chk_width_of_port_tap_rtdr_update_1:
992                          assert ($size(tap_rtdr_update) === STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS) 
993                          else $fatal ("The width of port tap_rtdr_update is not equal to number RTDRs when parameter STAP_RTDR_IS_BUSSED = 1");
994                          $display ("tap_rtdr_update_width  = %0d ", $size(tap_rtdr_update));
995                       end
996                       else
997                       begin
998                          chk_width_of_port_tap_rtdr_tdi_2:
999                          assert ($size(tap_rtdr_tdi) === 1) 
                             ==>
1000                         else $fatal ("The width of port tap_rtdr_tdi is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1001                         $display ("tap_rtdr_tdi_width     = %0d ", $size(tap_rtdr_tdi));
1002       
1003                         chk_width_of_port_tap_rtdr_capture_2:
1004                         assert ($size(tap_rtdr_capture) === 1) 
1005                         else $fatal ("The width of port tap_rtdr_capture is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1006                         $display ("tap_rtdr_capture_width = %0d ", $size(tap_rtdr_capture));
1007       
1008                         chk_width_of_port_tap_rtdr_shift_2:
1009                         assert ($size(tap_rtdr_shift) === 1) 
1010                         else $fatal ("The width of port tap_rtdr_shift is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1011                         $display ("tap_rtdr_shift_width   = %0d ", $size(tap_rtdr_shift));
1012       
1013                         chk_width_of_port_tap_rtdr_update_2:
1014                         assert ($size(tap_rtdr_update) === 1) 
1015                         else $fatal ("The width of port tap_rtdr_update is not equal to 1 when parameter STAP_RTDR_IS_BUSSED = 0");
1016                         $display ("tap_rtdr_update_width  = %0d ", $size(tap_rtdr_update));
1017                      end   
1018                   end
1019                   else
1020                   begin
1021                      chk_width_of_port_rtdr_tap_tdo_3:
1022                      assert ($size(rtdr_tap_tdo) === 1) 
                          ==>

Branches:

-1- -2- Status      
1   1   Covered     
1   0   Not Covered 
0   -   Not Covered 


346                          if (stap_fsm_tlrs === LOW)
                             -1-  
347                          begin
348                             chk_wtapnw_selectwir_equals_wtap_sel:
349                                assert property (sn_fwtap_selectwir === stap_selectwir)
                                   ==>
350                                else $error("WTAP_SELECT_WIR Logic is not equal to select_wir or not_wtap_sel");
351                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


366                          if (stap_fsm_tlrs === LOW)
                             -1-  
367                          begin
368                             if(wtap_sel_priority_internal[b] === 1'b0)
                                -2-  
369                             begin
370                                chk_wtapnw_wsi_high_when_not_sel:
371                                assert property (sn_fwtap_wsi[b] === 1'b1)
                                   ==>
372                                else $error("WTAP_SELECT_WSI is not High when not selected");
373                             end
                                MISSING_ELSE
                                ==>
374                             if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
                                -3-  
375                             begin
376                                chk_wtapnw_wsi_muxtdo_when_sel:
377                                assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
                                   ==>
378                                else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                             end
                                MISSING_ELSE
                                ==>
380                             if(|(tapc_select)) begin
                                -4-  
381                                chk_wtapnw_wsi_high_when_tapnw_sel:
382                                   assert property (sn_fwtap_wsi[b] === 1'b1)
                                      ==>
383                                else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                             end
                                MISSING_ELSE
                                ==>
385                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
1   -   1   -   Covered 
1   -   0   -   Covered 
1   -   -   1   Covered 
1   -   -   0   Covered 
0   -   -   -   Covered 


366                          if (stap_fsm_tlrs === LOW)
                             -1-  
367                          begin
368                             if(wtap_sel_priority_internal[b] === 1'b0)
                                -2-  
369                             begin
370                                chk_wtapnw_wsi_high_when_not_sel:
371                                assert property (sn_fwtap_wsi[b] === 1'b1)
                                   ==>
372                                else $error("WTAP_SELECT_WSI is not High when not selected");
373                             end
                                MISSING_ELSE
                                ==>
374                             if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
                                -3-  
375                             begin
376                                chk_wtapnw_wsi_muxtdo_when_sel:
377                                assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
                                   ==>
378                                else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                             end
                                MISSING_ELSE
                                ==>
380                             if(|(tapc_select)) begin
                                -4-  
381                                chk_wtapnw_wsi_high_when_tapnw_sel:
382                                   assert property (sn_fwtap_wsi[b] === 1'b1)
                                      ==>
383                                else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                             end
                                MISSING_ELSE
                                ==>
385                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
1   -   1   -   Covered 
1   -   0   -   Covered 
1   -   -   1   Covered 
1   -   -   0   Covered 
0   -   -   -   Covered 


366                          if (stap_fsm_tlrs === LOW)
                             -1-  
367                          begin
368                             if(wtap_sel_priority_internal[b] === 1'b0)
                                -2-  
369                             begin
370                                chk_wtapnw_wsi_high_when_not_sel:
371                                assert property (sn_fwtap_wsi[b] === 1'b1)
                                   ==>
372                                else $error("WTAP_SELECT_WSI is not High when not selected");
373                             end
                                MISSING_ELSE
                                ==>
374                             if(wtap_sel_priority_internal[b] === 1'b1 & (~(|(tapc_select))))
                                -3-  
375                             begin
376                                chk_wtapnw_wsi_muxtdo_when_sel:
377                                assert property (sn_fwtap_wsi[b] === stap_mux_tdo)
                                   ==>
378                                else $error("WTAP_SELECT_WSI is not Mux tdo when selected");
379                             end
                                MISSING_ELSE
                                ==>
380                             if(|(tapc_select)) begin
                                -4-  
381                                chk_wtapnw_wsi_high_when_tapnw_sel:
382                                   assert property (sn_fwtap_wsi[b] === 1'b1)
                                      ==>
383                                else $error("WTAP_SELECT_WSI is high when tapnw is selected");
384                             end
                                MISSING_ELSE
                                ==>
385                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- -3- -4- Status  
1   1   -   -   Covered 
1   0   -   -   Covered 
1   -   1   -   Covered 
1   -   0   -   Covered 
1   -   -   1   Covered 
1   -   -   0   Covered 
0   -   -   -   Covered 


400                          if (stap_fsm_tlrs === LOW)
                             -1-  
401                          begin
402                             if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
                                -2-  
403                             begin
404                                chk_wtapnw_tdo_wsi_sel:
405                                assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
                                   ==>
406                                else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                             end
                                MISSING_ELSE
                                ==>
408                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


400                          if (stap_fsm_tlrs === LOW)
                             -1-  
401                          begin
402                             if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
                                -2-  
403                             begin
404                                chk_wtapnw_tdo_wsi_sel:
405                                assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
                                   ==>
406                                else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                             end
                                MISSING_ELSE
                                ==>
408                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


400                          if (stap_fsm_tlrs === LOW)
                             -1-  
401                          begin
402                             if(wtap_sel_priority_internal[c] === 1'b1 & (~(|(tapc_select))))
                                -2-  
403                             begin
404                                chk_wtapnw_tdo_wsi_sel:
405                                assert property (stap_wtapnw_tdo === sn_awtap_wso[c])
                                   ==>
406                                else $error("WTAP TDO is not equal to the WSO of the wtap selected");
407                             end
                                MISSING_ELSE
                                ==>
408                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


541                       if (fdfx_powergood === HIGH)
                          -1-  
542                       begin
543                          if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
                             -2-  
544                          begin
545                             chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                             assert (sftapnw_ftap_enabletap[d] === HIGH)
                                ==>
547                             else $error("Entap is not supposed to be high for Isolated mode");
548                          end
                             MISSING_ELSE
                             ==>
549                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


541                       if (fdfx_powergood === HIGH)
                          -1-  
542                       begin
543                          if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
                             -2-  
544                          begin
545                             chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                             assert (sftapnw_ftap_enabletap[d] === HIGH)
                                ==>
547                             else $error("Entap is not supposed to be high for Isolated mode");
548                          end
                             MISSING_ELSE
                             ==>
549                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


541                       if (fdfx_powergood === HIGH)
                          -1-  
542                       begin
543                          if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
                             -2-  
544                          begin
545                             chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                             assert (sftapnw_ftap_enabletap[d] === HIGH)
                                ==>
547                             else $error("Entap is not supposed to be high for Isolated mode");
548                          end
                             MISSING_ELSE
                             ==>
549                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


541                       if (fdfx_powergood === HIGH)
                          -1-  
542                       begin
543                          if ((select[(TWO * d) + 1] | select[(TWO * d)]) === HIGH)
                             -2-  
544                          begin
545                             chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes:
546                             assert (sftapnw_ftap_enabletap[d] === HIGH)
                                ==>
547                             else $error("Entap is not supposed to be high for Isolated mode");
548                          end
                             MISSING_ELSE
                             ==>
549                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


565                       if (fdfx_powergood === HIGH)
                          -1-  
566                       begin
567                          if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
                             -2-  
568                          begin
569                             chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                             assert (sftapnw_ftap_enabletdo[e] === LOW)
                                ==>
571                             else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                          end
                             MISSING_ELSE
                             ==>
573                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


565                       if (fdfx_powergood === HIGH)
                          -1-  
566                       begin
567                          if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
                             -2-  
568                          begin
569                             chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                             assert (sftapnw_ftap_enabletdo[e] === LOW)
                                ==>
571                             else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                          end
                             MISSING_ELSE
                             ==>
573                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


565                       if (fdfx_powergood === HIGH)
                          -1-  
566                       begin
567                          if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
                             -2-  
568                          begin
569                             chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                             assert (sftapnw_ftap_enabletdo[e] === LOW)
                                ==>
571                             else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                          end
                             MISSING_ELSE
                             ==>
573                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


565                       if (fdfx_powergood === HIGH)
                          -1-  
566                       begin
567                          if ((select[(TWO * e) + 1]  ^ select[(TWO * e)]) === LOW)
                             -2-  
568                          begin
569                             chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes:
570                             assert (sftapnw_ftap_enabletdo[e] === LOW)
                                ==>
571                             else $error("Entdo is not supposed to be high for Isolated and Shadow modes");
572                          end
                             MISSING_ELSE
                             ==>
573                       end
                          MISSING_ELSE
                          ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_top_assertions 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       116   112       96.55   109               93.97   
Cover properties 6     6         100.00  3                 50.00   
Cover sequences  0     0                 0                         
Total            122   118       96.72   112               91.80   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                                                                Attempts Real Successes Failures Incomplete 
chk_instruction_size_greater_than_8                                                                                 16       16             0        0          
chk_opcode_00                                                                                                       16       16             0        0          
chk_opcode_01                                                                                                       15       15             0        0          
chk_opcode_03                                                                                                       15       15             0        0          
chk_opcode_04                                                                                                       15       15             0        0          
chk_opcode_06                                                                                                       15       15             0        0          
chk_opcode_07                                                                                                       15       15             0        0          
chk_opcode_08                                                                                                       15       15             0        0          
chk_opcode_09                                                                                                       15       15             0        0          
chk_opcode_0D                                                                                                       15       15             0        0          
chk_opcode_0E                                                                                                       15       15             0        0          
chk_opcode_0F                                                                                                       15       15             0        0          
chk_opcode_0c                                                                                                       16       16             0        0          
chk_opcode_10                                                                                                       15       15             0        0          
chk_opcode_11                                                                                                       15       15             0        0          
chk_opcode_13                                                                                                       15       15             0        0          
chk_opcode_14                                                                                                       15       15             0        0          
chk_opcode_15                                                                                                       15       15             0        0          
chk_opcode_16                                                                                                       15       15             0        0          
chk_opcode_17                                                                                                       15       15             0        0          
chk_opcode_lesser_than_h30_or_equals_20_or_21                                                                       105      105            0        0          
chk_present_state_tlrs_when_remove_asserted                                                                         88848    3              0        0          
chk_stap_assert_sn_fwtap_capturewr_during_negedge_clk                                                               5090     0              0        0          
chk_stap_assert_sn_fwtap_capturewr_during_posedge_clk                                                               5090     5074           0        0          
chk_stap_assert_sn_fwtap_shiftwr_during_negedge_clk                                                                 5070     0              0        0          
chk_stap_assert_sn_fwtap_shiftwr_during_posedge_clk                                                                 5070     5049           0        0          
chk_stap_assert_tms_during_posedge_clk_0                                                                            88842    87068          0        0          
chk_stap_assertion_remove_bit_at_updr                                                                               177690   3              0        0          
chk_stap_remove_bit_zero_at_powergood_reset                                                                         3344     1672           0        0          
chk_stap_tapnw_tdi_equals_tdi_when_remove_asserted                                                                  88848    33             0        0          
chk_stap_tdoen_equals_tapnw_tdi_when_remove_asserted                                                                88848    33             0        0          
chk_stap_tlrs_high_when_trst_low_0                                                                                  3518     1759           0        0          
chk_stap_tms_high_when_trst_is_low_0                                                                                88848    86             0        0          
chk_tdo_fbscan_tdo_bscanreg_sel                                                                                     88842    12288          0        0          
chk_tdo_int_tdo_no_tapnw_no_wtapnw_no_direct_wtap_sel                                                               88842    2914           0        0          
chk_tdo_tapnw_tdo_sel                                                                                               88842    0              0        0          
chk_that_for_retimetap_feature_bscan_is_disabled                                                                    1        1              0        0          
chk_that_for_retimetap_feature_tapnw_is_disabled                                                                    1        1              0        0          
chk_that_for_retimetap_feature_wtapnw_is_disabled                                                                   1        1              0        0          
chk_width_of_port_rtdr_tap_tdo_1                                                                                    15       15             0        0          
chk_width_of_port_rtdr_tap_tdo_3                                                                                    1        1              0        0          
chk_width_of_port_sftapnw_ftap_enabletap_1                                                                          1        1              0        0          
chk_width_of_port_sftapnw_ftap_enabletap_2                                                                          15       15             0        0          
chk_width_of_port_sftapnw_ftap_enabletdo_1                                                                          1        1              0        0          
chk_width_of_port_sftapnw_ftap_enabletdo_3                                                                          15       15             0        0          
chk_width_of_port_sftapnw_ftap_secsel_1                                                                             1        1              0        0          
chk_width_of_port_sftapnw_ftap_secsel_2                                                                             15       15             0        0          
chk_width_of_port_sn_awtap_wso_1                                                                                    1        1              0        0          
chk_width_of_port_sn_awtap_wso_2                                                                                    15       15             0        0          
chk_width_of_port_sn_fwtap_wsi_1                                                                                    1        1              0        0          
chk_width_of_port_sn_fwtap_wsi_2                                                                                    15       15             0        0          
chk_width_of_port_sntapnw_atap_tdo2_en_1                                                                            1        1              0        0          
chk_width_of_port_sntapnw_atap_tdo2_en_2                                                                            15       15             0        0          
chk_width_of_port_sntapnw_atap_tdo_en_1                                                                             1        1              0        0          
chk_width_of_port_sntapnw_atap_tdo_en_2                                                                             15       15             0        0          
chk_width_of_port_tap_rtdr_capture_1                                                                                15       15             0        0          
chk_width_of_port_tap_rtdr_capture_2                                                                                0        0              0        0          
chk_width_of_port_tap_rtdr_capture_3                                                                                1        1              0        0          
chk_width_of_port_tap_rtdr_irdec_1                                                                                  15       15             0        0          
chk_width_of_port_tap_rtdr_irdec_3                                                                                  1        1              0        0          
chk_width_of_port_tap_rtdr_prog_rst_b_1                                                                             15       15             0        0          
chk_width_of_port_tap_rtdr_prog_rst_b_3                                                                             1        1              0        0          
chk_width_of_port_tap_rtdr_shift_1                                                                                  15       15             0        0          
chk_width_of_port_tap_rtdr_shift_2                                                                                  0        0              0        0          
chk_width_of_port_tap_rtdr_shift_3                                                                                  1        1              0        0          
chk_width_of_port_tap_rtdr_tdi_1                                                                                    15       15             0        0          
chk_width_of_port_tap_rtdr_tdi_2                                                                                    0        0              0        0          
chk_width_of_port_tap_rtdr_tdi_3                                                                                    1        1              0        0          
chk_width_of_port_tap_rtdr_update_1                                                                                 15       15             0        0          
chk_width_of_port_tap_rtdr_update_2                                                                                 0        0              0        0          
chk_width_of_port_tap_rtdr_update_3                                                                                 1        1              0        0          
chk_width_of_port_tdr_data_in_1                                                                                     1        1              0        0          
chk_width_of_port_tdr_data_in_2                                                                                     15       15             0        0          
chk_width_of_port_tdr_data_out_1                                                                                    1        1              0        0          
chk_width_of_port_tdr_data_out_2                                                                                    15       15             0        0          
dfx_stap_secure_policy_matrix_0_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_10_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_11_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_12_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_13_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_14_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_15_assrt                                                                              16       16             0        0          
dfx_stap_secure_policy_matrix_1_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_2_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_3_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_4_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_5_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_6_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_7_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_8_assrt                                                                               16       16             0        0          
dfx_stap_secure_policy_matrix_9_assrt                                                                               16       16             0        0          
generate_chk_select_wir.chk_wtapnw_selectwir_equals_wtap_sel                                                        85370    76738          0        0          
generate_chk_tapnw_tap_mode.genblk1[0].chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes                  2040     2040           0        0          
generate_chk_tapnw_tap_mode.genblk1[1].chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes                  2036     2036           0        0          
generate_chk_tapnw_tap_mode.genblk1[2].chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes                  3787     3787           0        0          
generate_chk_tapnw_tap_mode.genblk1[3].chk_tapnw_entap_equals_one_for_normal_excluded_shadow_modes                  3775     3775           0        0          
generate_chk_tdo_in_isolated_and_shadow_mode.genblk1[0].chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes       82122    82122          0        0          
generate_chk_tdo_in_isolated_and_shadow_mode.genblk1[1].chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes       82122    82122          0        0          
generate_chk_tdo_in_isolated_and_shadow_mode.genblk1[2].chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes       80489    80489          0        0          
generate_chk_tdo_in_isolated_and_shadow_mode.genblk1[3].chk_tapnw_entdo_equals_zero_for_isolated_shadow_modes       80491    80491          0        0          
generate_chk_wsi.genblk1[0].chk_wtapnw_wsi_high_when_not_sel                                                        85370    76515          0        0          
generate_chk_wsi.genblk1[0].chk_wtapnw_wsi_high_when_tapnw_sel                                                      85370    3793           0        0          
generate_chk_wsi.genblk1[0].chk_wtapnw_wsi_muxtdo_when_sel                                                          85370    223            0        0          
generate_chk_wsi.genblk1[1].chk_wtapnw_wsi_high_when_not_sel                                                        85370    76249          0        0          
generate_chk_wsi.genblk1[1].chk_wtapnw_wsi_high_when_tapnw_sel                                                      85370    3793           0        0          
generate_chk_wsi.genblk1[1].chk_wtapnw_wsi_muxtdo_when_sel                                                          85370    489            0        0          
generate_chk_wsi.genblk1[2].chk_wtapnw_wsi_high_when_not_sel                                                        85370    76067          0        0          
generate_chk_wsi.genblk1[2].chk_wtapnw_wsi_high_when_tapnw_sel                                                      85370    3793           0        0          
generate_chk_wsi.genblk1[2].chk_wtapnw_wsi_muxtdo_when_sel                                                          85370    567            0        0          
generate_chk_wtap_tdo.genblk1[0].chk_wtapnw_tdo_wsi_sel                                                             85370    223            0        0          
generate_chk_wtap_tdo.genblk1[1].chk_wtapnw_tdo_wsi_sel                                                             85370    489            0        0          
generate_chk_wtap_tdo.genblk1[2].chk_wtapnw_tdo_wsi_sel                                                             85370    567            0        0          
generate_tdo_during_negedge_clk.chk_stap_assert_tdo_during_negedge_clk_0                                            6945     2014           0        0          
generate_tdo_during_posedge_clk.chk_stap_assert_tdo_during_posedge_clk_0                                            170745   56640          0        0          
generate_tdo_en_high_during_shift_ir_dr.chk_stap_tdo_en_high_during_shift_ir_dr_0                                   85375    56640          0        0          
generate_tdo_en_high_during_shift_ir_dr_with_tck_posedge.chk_stap_tdo_en_high_during_shift_ir_dr_with_tck_posedge_0 3472     2120           0        0          


-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                                       Attempts Matches Incomplete 
cov_stap_assert_reset_during_negedge_clk   88848    86      0          
cov_stap_assert_reset_during_posedge_clk   88842    0       0          
cov_stap_deassert_reset_during_negedge_clk 88848    86      0          
cov_stap_deassert_reset_during_posedge_clk 88842    0       0          
cov_stap_glitch_on_tms_01                  88842    0       18         
cov_stap_soft_reset_01                     88842    4135    15         


===============================================================================
Module : STAP_RTL_LIB.stap_dfxsecure_plugin
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 83.04  95.35  90.00  53.19 --      93.33  83.33 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/subIP/DfxSecurePlugin/source/rtl/dfxsecure_plugin/stap_dfxsecure_plugin.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                         
100.00 100.00 100.00 100.00 --     100.00 100.00 top.stap_top_inst.i_stap_dfxsecure_plugin(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_dfxsecure_plugin 

             Line No.   Total   Covered  Percent
TOTAL                       43       41    95.35
ALWAYS            169        4        4   100.00
ALWAYS            185       18       17    94.44
ALWAYS            280        1        1   100.00
ROUTINE           286       19       18    94.74
INITIAL            62        1        1   100.00

168                        begin
169        1/1                if (!fdfx_powergood)
170                           begin  
171        1/1                  dfxsecure_feature_lch <= {DFX_SECURE_WIDTH{LOW}};
172                           end  
173                           else
174                           begin
175        1/1                   if (fdfx_policy_update)
176                              begin  
177        1/1                      dfxsecure_feature_lch <= fdfx_secure_policy;
178                              end   
                        MISSING_ELSE
179                           end   
180                        end     
181                       
182                       //---------------------------------------------------------------------------------------
183                       always_comb
184                       begin
185        1/1              case (dfxsecure_feature_lch)
186                         POLICY0:
187                         begin
188        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY0 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY0 * SIZE_OF_EACH_FEATURE_GROUP)]; 
189                         end
190                         POLICY1:
191                         begin
192        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY1 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY1 * SIZE_OF_EACH_FEATURE_GROUP)]; 
193                         end
194                         POLICY2:
195                         begin
196        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY2 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY2 * SIZE_OF_EACH_FEATURE_GROUP)];
197                         end
198                         POLICY3:
199                         begin
200        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY3 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY3 * SIZE_OF_EACH_FEATURE_GROUP)];
201                         end
202                         POLICY4:
203                         begin
204        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY4 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY4 * SIZE_OF_EACH_FEATURE_GROUP)] ;
205                         end
206                         POLICY5:
207                         begin
208        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY5 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY5 * SIZE_OF_EACH_FEATURE_GROUP)] ;
209                         end
210                         POLICY6:
211                         begin
212        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY6 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY6 * SIZE_OF_EACH_FEATURE_GROUP)] ;
213                         end
214                         POLICY7:
215                         begin
216        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY7 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY7 * SIZE_OF_EACH_FEATURE_GROUP)] ;
217                         end
218                         POLICY8:
219                         begin
220        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY8 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY8 * SIZE_OF_EACH_FEATURE_GROUP)] ;
221                         end
222                         POLICY9:
223                         begin
224        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY9 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY9 * SIZE_OF_EACH_FEATURE_GROUP)] ;
225                         end
226                         POLICY10:
227                         begin
228        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY10 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY10 * SIZE_OF_EACH_FEATURE_GROUP)] ;
229                         end
230                         POLICY11:
231                         begin
232        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY11 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY11 * SIZE_OF_EACH_FEATURE_GROUP)] ;
233                         end
234                         POLICY12:
235                         begin
236        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY12 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY12 * SIZE_OF_EACH_FEATURE_GROUP)] ;
237                         end
238                         POLICY13:
239                         begin
240        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY13 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY13 * SIZE_OF_EACH_FEATURE_GROUP)] ;
241                         end
242                         POLICY14:
243                         begin
244        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY14 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY14 * SIZE_OF_EACH_FEATURE_GROUP)] ;
245                         end
246                         POLICY15:
247                         begin
248        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY15 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY15 * SIZE_OF_EACH_FEATURE_GROUP)] ;
249                         end
250                         default:
251                         begin
252        0/1     ==>        dfxsecure_feature_int = {SIZE_OF_EACH_FEATURE_GROUP{LOW}};
253                         end
254                         endcase
255                       end  
256                     `ifdef INTEL_SIMONLY
257                       typedef enum logic [4:0] {
258                           security_locked       = {1'b0,POLICY0},
259                           functionality_locked  = {1'b0,POLICY1},
260                           security_unlocked     = {1'b0,POLICY2},
261                           fuse_programming_only = {1'b0,POLICY3},
262                           intel_unlocked        = {1'b0,POLICY4},
263                           oem_unlocked          = {1'b0,POLICY5},
264                           endebug_unlocked      = {1'b0,POLICY6},
265                           infrared_unlocked     = {1'b0,POLICY7},
266                           dram_debug_unlocked   = {1'b0,POLICY8},
267                           user3_unlocked        = {1'b0,POLICY9},
268                           user4_unlocked        = {1'b0,POLICY10},
269                           user5_unlocked        = {1'b0,POLICY11},
270                           user6_unlocked        = {1'b0,POLICY12},
271                           user7_unlocked        = {1'b0,POLICY13},
272                           user8_unlocked        = {1'b0,POLICY14},
273                           part_disabled         = {1'b0,POLICY15},
274                           undriven              = UNDRIVEN} dfxsecure_policy_encode;
275                     
276                        dfxsecure_policy_encode policy_name;
277                     
278                        always_comb
279                        begin
280        1/1                policy_name = dfxsecure_policy_str(dfxsecure_feature_lch);
281                        end
282                     
283                        function automatic dfxsecure_policy_encode dfxsecure_policy_str(logic [(DFX_SECURE_WIDTH - 1):0] secure_policy);
284                           begin
285                              dfxsecure_policy_encode str;
286        1/1                   case (secure_policy)
287        1/1                      POLICY0 : begin str = security_locked;       end
288        1/1                      POLICY1 : begin str = functionality_locked;  end
289        1/1                      POLICY2 : begin str = security_unlocked;     end
290        1/1                      POLICY3 : begin str = fuse_programming_only; end
291        1/1                      POLICY4 : begin str = intel_unlocked;        end
292        1/1                      POLICY5 : begin str = oem_unlocked;          end
293        1/1                      POLICY6 : begin str = endebug_unlocked;      end
294        1/1                      POLICY7 : begin str = infrared_unlocked;     end
295        1/1                      POLICY8 : begin str = dram_debug_unlocked;   end
296        1/1                      POLICY9 : begin str = user3_unlocked;        end
297        1/1                      POLICY10: begin str = user4_unlocked;        end
298        1/1                      POLICY11: begin str = user5_unlocked;        end
299        1/1                      POLICY12: begin str = user6_unlocked;        end
300        1/1                      POLICY13: begin str = user7_unlocked;        end
301        1/1                      POLICY14: begin str = user8_unlocked;        end
302        1/1                      POLICY15: begin str = part_disabled;         end
303        0/1     ==>              default:  begin str = undriven;              end
304                              endcase
305        1/1                   return str;

  FILE: /nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/subIP/DfxSecurePlugin/source/rtl/include/assertions/stap_dfxsecure_include.sv
68         1/1                      #1ps

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_dfxsecure_plugin 

               Total   Covered  Percent
Conditions         10        9    90.00
Logical            10        9    90.00
Non-Logical         0        0
Event               0        0

 LINE       153
 EXPRESSION ((fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[0] : dfxsecure_feature_mux[0])
             --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       154
 EXPRESSION ((fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[1] : dfxsecure_feature_mux[1])
             --------------1-------------

-1- Status
 0  Covered
 1  Covered

 LINE       155
 EXPRESSION 
 Number  Term
      1  (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[(SIZE_OF_EACH_FEATURE_GROUP - 1):2] : dfxsecure_feature_mux[(SIZE_OF_EACH_FEATURE_GROUP - 1):2])

-1- Status
 0  Covered
 1  Covered

 LINE       160
 EXPRESSION ((dfxsecure_feature_lch == oem_secure_policy) ? HIGH : LOW)
             ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       162
 EXPRESSION ((oem_select == HIGH) ? sb_policy_ovr_value : dfxsecure_feature_int)
             ----------1---------

-1- Status
 0  Covered
 1  Not Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_dfxsecure_plugin 
                Total Covered Percent 
Totals          16    5       31.25   
Total Bits      94    50      53.19   
Total Bits 0->1 47    25      53.19   
Total Bits 1->0 47    25      53.19   

                            
Ports          9  4  44.44  
Port Bits      42 18 42.86  
Port Bits 0->1 21 9  42.86  
Port Bits 1->0 21 9  42.86  

                              
Signals          7  1  14.29  
Signal Bits      52 32 61.54  
Signal Bits 0->1 26 16 61.54  
Signal Bits 1->0 26 16 61.54  

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
fdfx_powergood            Yes    Yes         Yes         INPUT     
fdfx_secure_policy[2:0]   Yes    Yes         Yes         INPUT     
fdfx_secure_policy[3]     No     No          No          INPUT     
fdfx_earlyboot_exit       Yes    Yes         Yes         INPUT     
fdfx_policy_update        Yes    Yes         Yes         INPUT     
dfxsecure_feature_en[2:0] Yes    Yes         Yes         OUTPUT    
visa_all_dis              No     No          No          OUTPUT    
visa_customer_dis         No     No          No          OUTPUT    
sb_policy_ovr_value[4:0]  No     No          No          INPUT     
oem_secure_policy[3:0]    No     No          No          INPUT     

Signal Details
                            Toggle Toggle 1->0 Toggle 0->1 
dfxsecure_feature_int[1:0]  No     No          No          
dfxsecure_feature_int[4:2]  Yes    Yes         Yes         
dfxsecure_feature_lch[2:0]  Yes    Yes         Yes         
dfxsecure_feature_lch[3]    No     No          No          
dfxsecure_feature_mux[1:0]  No     No          No          
dfxsecure_feature_mux[4:2]  Yes    Yes         Yes         
oem_dfx_compare             Yes    Yes         Yes         
oem_select                  No     No          No          
policy_name[2:0]            Yes    Yes         Yes         
policy_name[4:3]            No     No          No          
local_feature_en_value[1:0] No     No          No          
local_feature_en_value[4:2] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_dfxsecure_plugin 
         Line No. Total Covered Percent 
Branches          30    28      93.33   
TERNARY  153      2     2       100.00  
TERNARY  154      2     2       100.00  
TERNARY  155      2     2       100.00  
TERNARY  160      2     2       100.00  
TERNARY  162      2     1       50.00   
IF       169      3     3       100.00  
CASE     185      17    16      94.12   


153           assign visa_customer_dis    = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[0] : dfxsecure_feature_mux[0];
                                                                         -1-  
                                                                         ==>  
                                                                         ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


154           assign visa_all_dis         = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[1] : dfxsecure_feature_mux[1]; 
                                                                         -1-  
                                                                         ==>  
                                                                         ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


155           assign dfxsecure_feature_en = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[(SIZE_OF_EACH_FEATURE_GROUP - 1):2] : dfxsecure_feature_mux[(SIZE_OF_EACH_FEATURE_GROUP - 1):2];
                                                                         -1-  
                                                                         ==>  
                                                                         ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


160           assign oem_dfx_compare       = (dfxsecure_feature_lch == oem_secure_policy) ? HIGH : LOW; 
                                                                                          -1-  
                                                                                          ==>  
                                                                                          ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


162           assign dfxsecure_feature_mux = (oem_select == HIGH) ? sb_policy_ovr_value : dfxsecure_feature_int;
                                                                  -1-  
                                                                  ==>  
                                                                  ==>  

Branches:

-1- Status      
1   Not Covered 
0   Covered     


169              if (!fdfx_powergood)
                 -1-  
170              begin  
171                dfxsecure_feature_lch <= {DFX_SECURE_WIDTH{LOW}};
                   ==>
172              end  
173              else
174              begin
175                 if (fdfx_policy_update)
                    -2-  
176                 begin  
177                    dfxsecure_feature_lch <= fdfx_secure_policy;
                       ==>
178                 end   
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


185            case (dfxsecure_feature_lch)
               -1-  
186            POLICY0:
187            begin
188              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY0 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY0 * SIZE_OF_EACH_FEATURE_GROUP)]; 
                 ==>
189            end
190            POLICY1:
191            begin
192              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY1 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY1 * SIZE_OF_EACH_FEATURE_GROUP)]; 
                 ==>
193            end
194            POLICY2:
195            begin
196              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY2 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY2 * SIZE_OF_EACH_FEATURE_GROUP)];
                 ==>
197            end
198            POLICY3:
199            begin
200              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY3 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY3 * SIZE_OF_EACH_FEATURE_GROUP)];
                 ==>
201            end
202            POLICY4:
203            begin
204              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY4 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY4 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
205            end
206            POLICY5:
207            begin
208              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY5 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY5 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
209            end
210            POLICY6:
211            begin
212              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY6 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY6 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
213            end
214            POLICY7:
215            begin
216              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY7 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY7 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
217            end
218            POLICY8:
219            begin
220              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY8 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY8 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
221            end
222            POLICY9:
223            begin
224              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY9 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY9 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
225            end
226            POLICY10:
227            begin
228              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY10 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY10 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
229            end
230            POLICY11:
231            begin
232              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY11 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY11 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
233            end
234            POLICY12:
235            begin
236              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY12 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY12 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
237            end
238            POLICY13:
239            begin
240              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY13 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY13 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
241            end
242            POLICY14:
243            begin
244              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY14 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY14 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
245            end
246            POLICY15:
247            begin
248              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY15 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY15 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
249            end
250            default:
251            begin
252              dfxsecure_feature_int = {SIZE_OF_EACH_FEATURE_GROUP{LOW}};
                 ==>

Branches:

-1-       Status      
POLICY0   Covered     
POLICY1   Covered     
POLICY2   Covered     
POLICY3   Covered     
POLICY4   Covered     
POLICY5   Covered     
POLICY6   Covered     
POLICY7   Covered     
POLICY8   Covered     
POLICY9   Covered     
POLICY10  Covered     
POLICY11  Covered     
POLICY12  Covered     
POLICY13  Covered     
POLICY14  Covered     
POLICY15  Covered     
default   Not Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_dfxsecure_plugin 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       6     6         100.00  5                 83.33   
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            6     6         100.00  5                 83.33   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                                     Attempts Real Successes Failures Incomplete 
CHK_DFX_SECURE_WIDTH_IS_FOUR                                                             16       16             0        0          
CHK_OEM_SECURE_POLICY_IS_USER_DEFINED_POLICY_STATES_IF_USE_OVR_IS_HIGH                   16       16             0        0          
CHK_OEM_SECURE_POLICY_IS_ZERO_IF_USE_OVR_IS_ZERO                                         16       16             0        0          
CHK_SB_POLICY_OVR_VALUE_IS_ZERO_IF_USE_OVR_IS_ZERO                                       16       16             0        0          
chk_check_output_eq_early_bootexit_val_when_early_bootexit_low                           3345     0              0        0          
genblk2.chk_check_output_eq_plcy_matrix_val_when_use_sb_disabled_and_early_bootexit_high 3345     1675           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
 83.04  95.35  90.00  53.19 --      93.33  83.33 STAP_RTL_LIB.stap_dfxsecure_plugin 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)

             Line No.   Total   Covered  Percent
TOTAL                       28       28   100.00
ALWAYS            169        4        4   100.00
ALWAYS            185        4        4   100.00
ALWAYS            280        1        1   100.00
ROUTINE           286       18       18   100.00
INITIAL            62        1        1   100.00

168                        begin
169        1/1                if (!fdfx_powergood)
170                           begin  
171        1/1                  dfxsecure_feature_lch <= {DFX_SECURE_WIDTH{LOW}};
172                           end  
173                           else
174                           begin
175        1/1                   if (fdfx_policy_update)
176                              begin  
177        1/1                      dfxsecure_feature_lch <= fdfx_secure_policy;
178                              end   
                        MISSING_ELSE
179                           end   
180                        end     
181                       
182                       //---------------------------------------------------------------------------------------
183                       always_comb
184                       begin
185        1/1              case (dfxsecure_feature_lch)
186                         POLICY0:
187                         begin
188        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY0 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY0 * SIZE_OF_EACH_FEATURE_GROUP)]; 
189                         end
190                         POLICY1:
191                         begin
192        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY1 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY1 * SIZE_OF_EACH_FEATURE_GROUP)]; 
193                         end
194                         POLICY2:
195                         begin
196        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY2 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY2 * SIZE_OF_EACH_FEATURE_GROUP)];
197                         end
198                         POLICY3:
199                         begin
200        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY3 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY3 * SIZE_OF_EACH_FEATURE_GROUP)];
201                         end
202                         POLICY4:
203                         begin
204        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY4 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY4 * SIZE_OF_EACH_FEATURE_GROUP)] ;
205                         end
206                         POLICY5:
207                         begin
208        1/1                dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY5 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY5 * SIZE_OF_EACH_FEATURE_GROUP)] ;
209                         end
210                         POLICY6:
211                         begin
212        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY6 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY6 * SIZE_OF_EACH_FEATURE_GROUP)] ;
213                         end
214                         POLICY7:
215                         begin
216        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY7 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY7 * SIZE_OF_EACH_FEATURE_GROUP)] ;
217                         end
218                         POLICY8:
219                         begin
220        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY8 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY8 * SIZE_OF_EACH_FEATURE_GROUP)] ;
221                         end
222                         POLICY9:
223                         begin
224        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY9 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY9 * SIZE_OF_EACH_FEATURE_GROUP)] ;
225                         end
226                         POLICY10:
227                         begin
228        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY10 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY10 * SIZE_OF_EACH_FEATURE_GROUP)] ;
229                         end
230                         POLICY11:
231                         begin
232        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY11 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY11 * SIZE_OF_EACH_FEATURE_GROUP)] ;
233                         end
234                         POLICY12:
235                         begin
236        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY12 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY12 * SIZE_OF_EACH_FEATURE_GROUP)] ;
237                         end
238                         POLICY13:
239                         begin
240        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY13 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY13 * SIZE_OF_EACH_FEATURE_GROUP)] ;
241                         end
242                         POLICY14:
243                         begin
244        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY14 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY14 * SIZE_OF_EACH_FEATURE_GROUP)] ;
245                         end
246                         POLICY15:
247                         begin
248        excluded           dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY15 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY15 * SIZE_OF_EACH_FEATURE_GROUP)] ;
249                         end
250                         default:
251                         begin
252        excluded           dfxsecure_feature_int = {SIZE_OF_EACH_FEATURE_GROUP{LOW}};
253                         end
254                         endcase
255                       end  
256                     `ifdef INTEL_SIMONLY
257                       typedef enum logic [4:0] {
258                           security_locked       = {1'b0,POLICY0},
259                           functionality_locked  = {1'b0,POLICY1},
260                           security_unlocked     = {1'b0,POLICY2},
261                           fuse_programming_only = {1'b0,POLICY3},
262                           intel_unlocked        = {1'b0,POLICY4},
263                           oem_unlocked          = {1'b0,POLICY5},
264                           endebug_unlocked      = {1'b0,POLICY6},
265                           infrared_unlocked     = {1'b0,POLICY7},
266                           dram_debug_unlocked   = {1'b0,POLICY8},
267                           user3_unlocked        = {1'b0,POLICY9},
268                           user4_unlocked        = {1'b0,POLICY10},
269                           user5_unlocked        = {1'b0,POLICY11},
270                           user6_unlocked        = {1'b0,POLICY12},
271                           user7_unlocked        = {1'b0,POLICY13},
272                           user8_unlocked        = {1'b0,POLICY14},
273                           part_disabled         = {1'b0,POLICY15},
274                           undriven              = UNDRIVEN} dfxsecure_policy_encode;
275                     
276                        dfxsecure_policy_encode policy_name;
277                     
278                        always_comb
279                        begin
280        1/1                policy_name = dfxsecure_policy_str(dfxsecure_feature_lch);
281                        end
282                     
283                        function automatic dfxsecure_policy_encode dfxsecure_policy_str(logic [(DFX_SECURE_WIDTH - 1):0] secure_policy);
284                           begin
285                              dfxsecure_policy_encode str;
286        1/1                   case (secure_policy)
287        1/1                      POLICY0 : begin str = security_locked;       end
288        1/1                      POLICY1 : begin str = functionality_locked;  end
289        1/1                      POLICY2 : begin str = security_unlocked;     end
290        1/1                      POLICY3 : begin str = fuse_programming_only; end
291        1/1                      POLICY4 : begin str = intel_unlocked;        end
292        1/1                      POLICY5 : begin str = oem_unlocked;          end
293        1/1                      POLICY6 : begin str = endebug_unlocked;      end
294        1/1                      POLICY7 : begin str = infrared_unlocked;     end
295        1/1                      POLICY8 : begin str = dram_debug_unlocked;   end
296        1/1                      POLICY9 : begin str = user3_unlocked;        end
297        1/1                      POLICY10: begin str = user4_unlocked;        end
298        1/1                      POLICY11: begin str = user5_unlocked;        end
299        1/1                      POLICY12: begin str = user6_unlocked;        end
300        1/1                      POLICY13: begin str = user7_unlocked;        end
301        1/1                      POLICY14: begin str = user8_unlocked;        end
302        1/1                      POLICY15: begin str = part_disabled;         end
303        excluded                 default:  begin str = undriven;              end
304                              endcase
305        1/1                   return str;

  FILE: /nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/subIP/DfxSecurePlugin/source/rtl/include/assertions/stap_dfxsecure_include.sv
68         1/1                      #1ps

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       153
 EXPRESSION ((fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[0] : dfxsecure_feature_mux[0])
             --------------1-------------

-1- Status
 0  Covered
 1  Excluded

 LINE       154
 EXPRESSION ((fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[1] : dfxsecure_feature_mux[1])
             --------------1-------------

-1- Status
 0  Covered
 1  Excluded

 LINE       155
 EXPRESSION 
 Number  Term
      1  (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[(SIZE_OF_EACH_FEATURE_GROUP - 1):2] : dfxsecure_feature_mux[(SIZE_OF_EACH_FEATURE_GROUP - 1):2])

-1- Status
 0  Covered
 1  Excluded

 LINE       160
 EXPRESSION ((dfxsecure_feature_lch == oem_secure_policy) ? HIGH : LOW)
             ----------------------1---------------------

-1- Status
 0  Covered
 1  Covered

 LINE       162
 EXPRESSION ((oem_select == HIGH) ? sb_policy_ovr_value : dfxsecure_feature_int)
             ----------1---------

-1- Status
 0  Covered
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)
                Total Covered Percent 
Totals          9     9       100.00  
Total Bits      32    32      100.00  
Total Bits 0->1 16    16      100.00  
Total Bits 1->0 16    16      100.00  

                          
Ports          3 3 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

                              
Signals          6  6  100.00 
Signal Bits      24 24 100.00 
Signal Bits 0->1 12 12 100.00 
Signal Bits 1->0 12 12 100.00 

Port Details
                         Toggle   Toggle 1->0 Toggle 0->1 Direction 
fdfx_powergood           Yes      Yes         Yes         INPUT     
fdfx_secure_policy[3:0]  Excluded Excluded    Excluded    INPUT     
fdfx_earlyboot_exit      Excluded Excluded    Excluded    INPUT     
fdfx_policy_update       Yes      Yes         Yes         INPUT     
dfxsecure_feature_en[0]  Yes      Yes         Yes         OUTPUT    
dfxsecure_feature_en[1]  Excluded Excluded    Excluded    OUTPUT    
dfxsecure_feature_en[2]  Yes      Yes         Yes         OUTPUT    
visa_all_dis             Excluded Excluded    Excluded    OUTPUT    
visa_customer_dis        Excluded Excluded    Excluded    OUTPUT    
sb_policy_ovr_value[4:0] Excluded Excluded    Excluded    INPUT     
oem_secure_policy[3:0]   Excluded Excluded    Excluded    INPUT     

Signal Details
                            Toggle   Toggle 1->0 Toggle 0->1 
dfxsecure_feature_int[1:0]  Excluded Excluded    Excluded    
dfxsecure_feature_int[2]    Yes      Yes         Yes         
dfxsecure_feature_int[3]    Excluded Excluded    Excluded    
dfxsecure_feature_int[4]    Yes      Yes         Yes         
dfxsecure_feature_lch[0]    Excluded Excluded    Excluded    
dfxsecure_feature_lch[1]    Yes      Yes         Yes         
dfxsecure_feature_lch[3:2]  Excluded Excluded    Excluded    
dfxsecure_feature_mux[1:0]  Excluded Excluded    Excluded    
dfxsecure_feature_mux[2]    Yes      Yes         Yes         
dfxsecure_feature_mux[3]    Excluded Excluded    Excluded    
dfxsecure_feature_mux[4]    Yes      Yes         Yes         
oem_dfx_compare             Yes      Yes         Yes         
oem_select                  Excluded Excluded    Excluded    
policy_name[2:0]            Yes      Yes         Yes         
policy_name[4:3]            Excluded Excluded    Excluded    
local_feature_en_value[1:0] Excluded Excluded    Excluded    
local_feature_en_value[4:2] Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)
         Line No. Total Covered Percent 
Branches          12    12      100.00  
TERNARY  153      1     1       100.00  
TERNARY  154      1     1       100.00  
TERNARY  155      1     1       100.00  
TERNARY  160      2     2       100.00  
TERNARY  162      1     1       100.00  
IF       169      3     3       100.00  
CASE     185      3     3       100.00  


153           assign visa_customer_dis    = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[0] : dfxsecure_feature_mux[0];
                                                                         -1-  
                                                                         ==> (Excluded)  
                                                                         ==>  

Branches:

-1- Status   
1   Excluded 
0   Covered  


154           assign visa_all_dis         = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[1] : dfxsecure_feature_mux[1]; 
                                                                         -1-  
                                                                         ==> (Excluded)  
                                                                         ==>  

Branches:

-1- Status   
1   Excluded 
0   Covered  


155           assign dfxsecure_feature_en = (fdfx_earlyboot_exit == LOW) ? DFX_EARLYBOOT_FEATURE_ENABLE[(SIZE_OF_EACH_FEATURE_GROUP - 1):2] : dfxsecure_feature_mux[(SIZE_OF_EACH_FEATURE_GROUP - 1):2];
                                                                         -1-  
                                                                         ==> (Excluded)  
                                                                         ==>  

Branches:

-1- Status   
1   Excluded 
0   Covered  


160           assign oem_dfx_compare       = (dfxsecure_feature_lch == oem_secure_policy) ? HIGH : LOW; 
                                                                                          -1-  
                                                                                          ==>  
                                                                                          ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


162           assign dfxsecure_feature_mux = (oem_select == HIGH) ? sb_policy_ovr_value : dfxsecure_feature_int;
                                                                  -1-  
                                                                  ==> (Excluded)  
                                                                  ==>  

Branches:

-1- Status   
1   Excluded 
0   Covered  


169              if (!fdfx_powergood)
                 -1-  
170              begin  
171                dfxsecure_feature_lch <= {DFX_SECURE_WIDTH{LOW}};
                   ==>
172              end  
173              else
174              begin
175                 if (fdfx_policy_update)
                    -2-  
176                 begin  
177                    dfxsecure_feature_lch <= fdfx_secure_policy;
                       ==>
178                 end   
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


185            case (dfxsecure_feature_lch)
               -1-  
186            POLICY0:
187            begin
188              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY0 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY0 * SIZE_OF_EACH_FEATURE_GROUP)]; 
                 ==>
189            end
190            POLICY1:
191            begin
192              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY1 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY1 * SIZE_OF_EACH_FEATURE_GROUP)]; 
                 ==> (Excluded)
193            end
194            POLICY2:
195            begin
196              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY2 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY2 * SIZE_OF_EACH_FEATURE_GROUP)];
                 ==>
197            end
198            POLICY3:
199            begin
200              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY3 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY3 * SIZE_OF_EACH_FEATURE_GROUP)];
                 ==> (Excluded)
201            end
202            POLICY4:
203            begin
204              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY4 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY4 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
205            end
206            POLICY5:
207            begin
208              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY5 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY5 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==>
209            end
210            POLICY6:
211            begin
212              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY6 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY6 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
213            end
214            POLICY7:
215            begin
216              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY7 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY7 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
217            end
218            POLICY8:
219            begin
220              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY8 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY8 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
221            end
222            POLICY9:
223            begin
224              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY9 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY9 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
225            end
226            POLICY10:
227            begin
228              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY10 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY10 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
229            end
230            POLICY11:
231            begin
232              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY11 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY11 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
233            end
234            POLICY12:
235            begin
236              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY12 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY12 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
237            end
238            POLICY13:
239            begin
240              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY13 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY13 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
241            end
242            POLICY14:
243            begin
244              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY14 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY14 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
245            end
246            POLICY15:
247            begin
248              dfxsecure_feature_int = DFX_SECURE_POLICY_MATRIX[(((POLICY15 * SIZE_OF_EACH_FEATURE_GROUP) + SIZE_OF_EACH_FEATURE_GROUP) - 1):(POLICY15 * SIZE_OF_EACH_FEATURE_GROUP)] ;
                 ==> (Excluded)
249            end
250            default:
251            begin
252              dfxsecure_feature_int = {SIZE_OF_EACH_FEATURE_GROUP{LOW}};
                 ==> (Excluded)

Branches:

-1-       Status   
POLICY0   Covered  
POLICY1   Excluded 
POLICY2   Covered  
POLICY3   Excluded 
POLICY4   Excluded 
POLICY5   Covered  
POLICY6   Excluded 
POLICY7   Excluded 
POLICY8   Excluded 
POLICY9   Excluded 
POLICY10  Excluded 
POLICY11  Excluded 
POLICY12  Excluded 
POLICY13  Excluded 
POLICY14  Excluded 
POLICY15  Excluded 
default   Excluded 


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_dfxsecure_plugin(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       5     5         100.00  5                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            5     5         100.00  5                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                                                                     Attempts Real Successes Failures Incomplete Exclusion 
CHK_DFX_SECURE_WIDTH_IS_FOUR                                                             16       16             0        0                    
CHK_OEM_SECURE_POLICY_IS_USER_DEFINED_POLICY_STATES_IF_USE_OVR_IS_HIGH                   16       16             0        0                    
CHK_OEM_SECURE_POLICY_IS_ZERO_IF_USE_OVR_IS_ZERO                                         16       16             0        0                    
CHK_SB_POLICY_OVR_VALUE_IS_ZERO_IF_USE_OVR_IS_ZERO                                       16       16             0        0                    
chk_check_output_eq_early_bootexit_val_when_early_bootexit_low                                                                       Excluded  
genblk2.chk_check_output_eq_plcy_matrix_val_when_use_sb_disabled_and_early_bootexit_high 3345     1675           0        0                    


===============================================================================
Module : vcs_paramclassrepository
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 85.71 --     --     --     --     --      85.71 

Module self-instances :

SCORE LINE COND TOGGLE FSM BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Assert Coverage for Module : vcs_paramclassrepository
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       7     6         85.71   6                 85.71   
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            7     6         85.71   6                 85.71   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                           Attempts Real Successes Failures Incomplete 
\DfxSecurePlugin_Driver#(3,4,0,64'h0000000000002710)::connect .unnamed$$_0     16       16             0        0          
\DfxSecurePlugin_InpMonitor#(3,4,0,64'h0000000000002710)::connect .unnamed$$_0 16       16             0        0          
\DfxSecurePlugin_OutMonitor#(3,4,0,64'h0000000000002710)::connect .unnamed$$_0 16       16             0        0          
\JtagBfmSoCTapNwSequences::SetCltapcNetworkSelOpcode .unnamed$$_0              0        0              0        0          
\JtagBfmTracker#(64'h0000000000002710,64'b0,64'b0)::connect .unnamed$$_0       16       16             0        0          
\Rd_tdr_isol_en_test::build .unnamed$$_0.unnamed$$_1                           1        1              0        0          
\STapEnv#(3,4,0,10000.000000000000)::connect .unnamed$$_0                      16       16             0        0          


===============================================================================
Module : STAP_RTL_LIB.stap_tapswcompreg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 87.83 100.00 100.00  51.34 --     100.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_tapswcompreg.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                  
--     --     --     --     --     --     --     top.stap_top_inst.generate_stap_swcomp_rtdr.i_stap_swcomp_rtdr.i_stap_tapswcompreg(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_tapswcompreg 

             Line No.   Total   Covered  Percent
TOTAL                       46       46   100.00
ALWAYS             99        4        4   100.00
ALWAYS            111        3        3   100.00
ALWAYS            122        4        4   100.00
ALWAYS            135        3        3   100.00
ALWAYS            154        7        7   100.00
ALWAYS            174        3        3   100.00
ALWAYS            191       22       22   100.00

98                         always_comb begin: serialdata_next_logic
99         1/1                unique case({shift_en,capture_en})
100        1/1                  2'b00 : serialdata_next = serialdata;  // retain
101        1/1                  2'b01 : serialdata_next = captdata_ctrl; // capture
102        1/1                  2'b10 : serialdata_next = {tdi,serialdata[CMP2-1:1]}; // shifting serial data from TDI / prev. flop
103                             //VCS coverage off
104        unreachable          default : serialdata_next = {(CMP2){1'bX}};
105                             //VCS coverage on
106                           endcase
107                        end
108                     
109                        
110                        always_ff @(posedge jtclk or negedge jpwrgood_rst_b) begin : serial_shiftreg_flops
111        1/1                if (jpwrgood_rst_b == 1'b0)
112        1/1                serialdata <= {(CMP2){1'b0}};
113                           else 
114        1/1                serialdata <= serialdata_next;
115                        end
116                     
117                       assign tdoctrl = serialdata[0];  // LSB of Serial stage is sent to TDO
118                     
119                     
120                     //Status Register Operations
121                        always_comb begin: statusdata_next_logic
122        1/1                unique case({shift_en,capture_en})
123        1/1                  2'b00 : statusdata_next = statusdata;  // retain
124        1/1                  2'b01 : statusdata_next = captdata_stat;    // capture
125        1/1                  2'b10 : statusdata_next =   {tdi,statusdata[CMP2-1:1]}; // shifting serial data from TDI / prev. flop
126                                    //VCS coverage off
127        unreachable          default : statusdata_next = {(CMP2){1'bX}};
128                                    //VCS coverage on
129                           endcase
130                        end
131                     
132                        
133                        // serial-only shift register does NOT require any reset.
134                        always_ff @(posedge jtclk or negedge jpwrgood_rst_b) begin : status_shiftreg_flops
135        1/1                if (jpwrgood_rst_b == 1'b0)
136        1/1                statusdata <= {(CMP2){1'b0}};
137                           else 
138        1/1                statusdata <= statusdata_next;
139                        end
140                     
141                     
142                        assign tdostat = statusdata[0];  // LSB of Serial stage is sent to TDO
143                     
144                     
145                     // Combo logic to determine what to load into the parallel stage
146                        // Take the write-enable bits into account, to prevent bit fields from being updated unless
147                        // the corresponding write-enable bit is set.
148                        // Reflects hard-coding of write-enable bits and the bits that they protect.
149                        assign update_en_cmplim  = update_en & serialdata[1]; 
150                        assign update_en_control = update_en & serialdata[12]; 
151                     
152                        always_comb begin : paralleldata_next_logic
153                           //  Bits from 2 to 11 are write-enabled by update_en_control
154        1/1                for( int j = 2; j <= 11; j++) begin // 10:2
155        1/1                   pre_data_regval[j] = update_en_control ? serialdata[j] : pdata_regval[j];
156                           end
157                           // Bits from 13 to CMP2 are write-enabled by update_en_cmplim
158        1/1                for( int j = 13; j <= (CMP2-1) ; j++) begin // CMP2-1 :13
159        1/1                   pre_data_regval[j] = update_en_cmplim ? serialdata[j] : pdata_regval[j];
160                           end
161                           //Bits 1 and 12 are not write-enabled . They are control bits. Bit 0 is reserved
162        1/1                   pre_data_regval[1]  = update_en ? serialdata[1] : pdata_regval[1];
163        1/1                   pre_data_regval[12] = update_en ? serialdata[12] : pdata_regval[12];
164        1/1                   pre_data_regval[0]  = update_en ? serialdata[0] : pdata_regval[0];
165                     
166                     // pre_data_regval[0]  = 1'b0;
167                     
168                        end
169                     
170                     
171                        // Update Parallel register stage register on the falling edge of jtclk
172                        // with the appropriate data. This is the parallel output stage. 
173                        always_ff @(negedge jtclk or negedge jpwrgood_rst_b) begin : parallel_stage_flops
174        1/1                if (jpwrgood_rst_b == 1'b0)
175        1/1                  pdata_regval <= {(CMP2){1'b0}};
176                             //pdata_regval <= {(WIDTH){1'b0}};
177                           else
178        1/1                  pdata_regval <= pre_data_regval;
179                        end
180                       
181                       
182                         assign cmplim_we = update_en_cmplim ;
183                         assign ctrl_bits_we = update_en_control; 
184                        
185                        //assign swcomp_pregdata = pdata_regval; // send out all but write-enables
186                        // ------------------------------
187                        // SWCOMP test data register bits
188                        // ------------------------------
189                        always_comb begin: tdr_assignments
190                          
191        1/1               cmplim_hi[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1:0]               = pdata_regval[CMP2-1:CMP1];
192        1/1               cmplim_lo[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1:0]               = pdata_regval[CMP1-1:CMP0] ;
193        1/1               cmplim_mask[STAP_SWCOMP_NUM_OF_COMPARE_BITS-1:0]             = pdata_regval[CMP0-1:13] ;
194                         // cmplim_we                                                  = pdata_regval[12];
195        1/1               nc_cmp_rsvd_1                                                = pdata_regval[11]; // no-connect / unused /reserved bits
196        1/1               cmpsel_signed                                                = pdata_regval[10];
197        1/1               cmpsel_sgnmag                                                = pdata_regval[9];
198        1/1               cmpen_blk_multi_fail                                         = pdata_regval[8];
199        1/1               cmp_mirror_sel                                               = pdata_regval[7];
200        1/1               cmp_tdo_sel                                                  = pdata_regval[6];
201        1/1               cmp_tdo_forcelo                                              = pdata_regval[5];
202        1/1               cmpen_main                                                   = pdata_regval[4];
203        1/1               cmpen_le_limhi                                               = pdata_regval[3];
204        1/1               cmpen_ge_limlo                                               = pdata_regval[2];
205                        //  ctrl_bits_we                                               = pdata_regval[1];
206        1/1               nc_cmp_rsvd_0                                                = pdata_regval[0]; // no-connect / unused /reserved bits
207                     
208                       //Capturing Control Register values
209                     
210        1/1              captdata_ctrl [CMP2-1 : 0]                                    = pdata_regval[CMP2-1 :0];
211                     
212                       //Capturing Status Register Values
213                     
214        1/1              captdata_stat[CMP2-1:13]                                      = pdata_regval[CMP2-1:13];
215        1/1              captdata_stat[12]                                             = cmplim_we;    
216        1/1              captdata_stat[11:4]                                           = cmp_firstfail_cnt[7:0];
217        1/1              captdata_stat[3]                                              = cmp_sticky_fail_hi;
218        1/1              captdata_stat[2]                                              = cmp_sticky_fail_lo;
219        1/1              captdata_stat[1]                                              = ctrl_bits_we ;
220        1/1              captdata_stat[0]                                              = nc_cmp_rsvd_0 ;

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_tapswcompreg 

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       162
 EXPRESSION (update_en ? serialdata[1] : pdata_regval[1])
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       163
 EXPRESSION (update_en ? serialdata[12] : pdata_regval[12])
             ----1----

-1- Status
 0  Covered
 1  Covered

 LINE       164
 EXPRESSION (update_en ? serialdata[0] : pdata_regval[0])
             ----1----

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_tapswcompreg 
                Total Covered Percent 
Totals          41    23      56.10   
Total Bits      822   422     51.34   
Total Bits 0->1 411   211     51.34   
Total Bits 1->0 411   211     51.34   

                             
Ports          24  12 50.00  
Port Bits      116 24 20.69  
Port Bits 0->1 58  12 20.69  
Port Bits 1->0 58  12 20.69  

                                
Signals          17  11  64.71  
Signal Bits      706 398 56.37  
Signal Bits 0->1 353 199 56.37  
Signal Bits 1->0 353 199 56.37  

Port Details
                       Toggle Toggle 1->0 Toggle 0->1 Direction 
jtclk                  Yes    Yes         Yes         INPUT     
jpwrgood_rst_b         Yes    Yes         Yes         INPUT     
tdi                    Yes    Yes         Yes         INPUT     
capture                Yes    Yes         Yes         INPUT     
shift                  Yes    Yes         Yes         INPUT     
update                 Yes    Yes         Yes         INPUT     
enable                 Yes    Yes         Yes         INPUT     
cmp_firstfail_cnt[7:0] No     No          No          INPUT     
cmp_sticky_fail_hi     No     No          No          INPUT     
cmp_sticky_fail_lo     No     No          No          INPUT     
cmplim_hi[9:0]         No     No          No          OUTPUT    
cmplim_lo[9:0]         No     No          No          OUTPUT    
cmplim_mask[9:0]       No     No          No          OUTPUT    
cmp_mirror_sel         Yes    Yes         Yes         OUTPUT    
cmp_tdo_sel            No     No          No          OUTPUT    
cmp_tdo_forcelo        No     No          No          OUTPUT    
cmpen_main             Yes    Yes         Yes         OUTPUT    
cmpsel_signed          No     No          No          OUTPUT    
cmpsel_sgnmag          No     No          No          OUTPUT    
cmpen_le_limhi         Yes    Yes         Yes         OUTPUT    
cmpen_ge_limlo         No     No          No          OUTPUT    
cmpen_blk_multi_fail   No     No          No          OUTPUT    
tdoctrl                Yes    Yes         Yes         OUTPUT    
tdostat                Yes    Yes         Yes         OUTPUT    

Signal Details
                       Toggle Toggle 1->0 Toggle 0->1 
cmplim_we              No     No          No          
ctrl_bits_we           Yes    Yes         Yes         
capture_en             Yes    Yes         Yes         
shift_en               Yes    Yes         Yes         
update_en              Yes    Yes         Yes         
update_en_control      Yes    Yes         Yes         
update_en_cmplim       No     No          No          
serialdata_next[42:0]  Yes    Yes         Yes         
serialdata[42:0]       Yes    Yes         Yes         
statusdata[42:0]       Yes    Yes         Yes         
statusdata_next[42:0]  Yes    Yes         Yes         
pre_data_regval[0]     Yes    Yes         Yes         
pre_data_regval[2:1]   No     No          No          
pre_data_regval[4:3]   Yes    Yes         Yes         
pre_data_regval[6:5]   No     No          No          
pre_data_regval[7]     Yes    Yes         Yes         
pre_data_regval[10:8]  No     No          No          
pre_data_regval[12:11] Yes    Yes         Yes         
pre_data_regval[42:13] No     No          No          
pdata_regval[0]        Yes    Yes         Yes         
pdata_regval[2:1]      No     No          No          
pdata_regval[4:3]      Yes    Yes         Yes         
pdata_regval[6:5]      No     No          No          
pdata_regval[7]        Yes    Yes         Yes         
pdata_regval[10:8]     No     No          No          
pdata_regval[12:11]    Yes    Yes         Yes         
pdata_regval[42:13]    No     No          No          
captdata_ctrl[0]       Yes    Yes         Yes         
captdata_ctrl[2:1]     No     No          No          
captdata_ctrl[4:3]     Yes    Yes         Yes         
captdata_ctrl[6:5]     No     No          No          
captdata_ctrl[7]       Yes    Yes         Yes         
captdata_ctrl[10:8]    No     No          No          
captdata_ctrl[12:11]   Yes    Yes         Yes         
captdata_ctrl[42:13]   No     No          No          
captdata_stat[1:0]     Yes    Yes         Yes         
captdata_stat[42:2]    No     No          No          
nc_cmp_rsvd_0          Yes    Yes         Yes         
nc_cmp_rsvd_1          Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_tapswcompreg 
         Line No. Total Covered Percent 
Branches          18    18      100.00  
CASE     99       3     3       100.00  
IF       111      2     2       100.00  
CASE     122      3     3       100.00  
IF       135      2     2       100.00  
TERNARY  162      2     2       100.00  
TERNARY  163      2     2       100.00  
TERNARY  164      2     2       100.00  
IF       174      2     2       100.00  


99               unique case({shift_en,capture_en})
                        -1-  
100                2'b00 : serialdata_next = serialdata;  // retain
                   ==>
101                2'b01 : serialdata_next = captdata_ctrl; // capture
                   ==>
102                2'b10 : serialdata_next = {tdi,serialdata[CMP2-1:1]}; // shifting serial data from TDI / prev. flop
                   ==>

Branches:

-1-    Status  
2'b00  Covered 
2'b01  Covered 
2'b10  Covered 


111              if (jpwrgood_rst_b == 1'b0)
                 -1-  
112              serialdata <= {(CMP2){1'b0}};
                 ==>
113              else 
114              serialdata <= serialdata_next;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


122              unique case({shift_en,capture_en})
                        -1-  
123                2'b00 : statusdata_next = statusdata;  // retain
                   ==>
124                2'b01 : statusdata_next = captdata_stat;    // capture
                   ==>
125                2'b10 : statusdata_next =   {tdi,statusdata[CMP2-1:1]}; // shifting serial data from TDI / prev. flop
                   ==>

Branches:

-1-    Status  
2'b00  Covered 
2'b01  Covered 
2'b10  Covered 


135              if (jpwrgood_rst_b == 1'b0)
                 -1-  
136              statusdata <= {(CMP2){1'b0}};
                 ==>
137              else 
138              statusdata <= statusdata_next;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


162                 pre_data_regval[1]  = update_en ? serialdata[1] : pdata_regval[1];
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


163                 pre_data_regval[12] = update_en ? serialdata[12] : pdata_regval[12];
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


164                 pre_data_regval[0]  = update_en ? serialdata[0] : pdata_regval[0];
                                                    -1-  
                                                    ==>  
                                                    ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


174              if (jpwrgood_rst_b == 1'b0)
                 -1-  
175                pdata_regval <= {(CMP2){1'b0}};
                   ==>
176                //pdata_regval <= {(WIDTH){1'b0}};
177              else
178                pdata_regval <= pre_data_regval;
                   ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


===============================================================================
Module : STAP_RTL_LIB.stap_tdomux
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 88.16  96.00 --      74.73 --      93.75 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_tdomux.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
100.00 100.00 --     100.00 --     100.00 --     top.stap_top_inst.i_stap_tdomux(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_tdomux 

             Line No.   Total   Covered  Percent
TOTAL                       25       24    96.00
ALWAYS            123        6        5    83.33
ALWAYS            155        6        6   100.00
ALWAYS            175        5        5   100.00
ALWAYS            197        3        3   100.00
ALWAYS            219        5        5   100.00

122                        begin
123        1/1                case (stap_fsm_shift_ir)
124                              HIGH:
125                              begin
126        1/1                      stap_mux_tdo_preflop = stap_irreg_serial_out;
127                              end
128                              LOW:
129                              begin
130        1/1                      if(tap_swcomp_active == 1'b0)
131                                 begin
132        1/1                          stap_mux_tdo_preflop = swcomp_stap_post_tdo ;  //Only when tap_swcomp_active is 0, stitch the comparator window between TDI and TDO. Else bypass it. //PCR 1604263740 for SWCOMP Integration
133                                 end
134                                 else
135                                 begin 
136        1/1                          stap_mux_tdo_preflop = tdo_dr ;
137                                 end
138                              end
139                              default:
140                              begin
141        0/1     ==>              stap_mux_tdo_preflop = ONE_BIT_UNKNOWN_VALUE;
142                              end
143                           endcase
144                        end
145                     
146                        // *********************************************************************
147                        // TDO flop
148                        // ----------------------------
149                        // https://vthsd.intel.com/hsd/seg_softip/pcr/default.aspx?pcr_id=57136
150                        // To implement this PCR, the register stap_mux_tdo_int should be HIGH in
151                        // all non shift states.
152                        // *********************************************************************
153                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
154                        begin
155        1/1                if (!powergood_rst_trst_b)
156                           begin
157        1/1                   stap_mux_tdo_int <= LOW;
158                           end
159        1/1                else if (stap_fsm_tlrs)
160                           begin
161        1/1                   stap_mux_tdo_int <= LOW;
162                           end
163        1/1                else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
164                           begin
165        1/1                   stap_mux_tdo_int <= stap_mux_tdo_preflop;
166                           end
                        MISSING_ELSE
167                        end
168                     
169                        // *********************************************************************
170                        // To qualify the preflop signal with powergood and fsm_tlrs, which is 
171                        // to be sent on posedge when the retime parameter is enabled
172                        // *********************************************************************
173                        always_comb
174                        begin
175        1/1                if (!powergood_rst_trst_b)
176                           begin
177        1/1                   stap_mux_tdo_preflop_int = LOW;
178                           end
179        1/1                else if (stap_fsm_tlrs)
180                           begin
181        1/1                   stap_mux_tdo_preflop_int = LOW;
182                           end
183                           //else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
184                           //begin
185                           //   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
186                           //end
187                           else 
188                           begin
189        1/1                   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
190                           end
191                        end
192                     
193                        // *********************************************************************
194                        // TDO to be sent on posedge when the retime parameter is enabled
195                        // *********************************************************************
196                        always_comb
197        1/1                if (STAP_ENABLE_TDO_POS_EDGE == 1)
198                           begin
199        1/1                   stap_en_tdo_posedge = HIGH;
200                           end
201                           else
202                           begin
203        1/1                   stap_en_tdo_posedge = LOW;
204                           end
205                     
206                     //   stap_ctech_lib_clk_mux_2to1 i_stap_ctech_lib_clk_mux_2to1_tdo_posedge (.clk1(stap_mux_tdo_preflop_int),
207                     //                                                                .clk2(stap_mux_tdo_int),
208                     //                                                                .s(stap_en_tdo_posedge),
209                     //                                                                .clkout(stap_mux_tdo)
210                     //                                                               );
211                       stap_ctech_lib_mux_2to1 i_stap_ctech_lib_mux_2to1_tdo_posedge (
212                        .d1(stap_mux_tdo_preflop_int ), .d2(stap_mux_tdo_int ), .s(stap_en_tdo_posedge ), .o(stap_mux_tdo ));
213                     
214                        // *********************************************************************
215                        // TDOen flop
216                        // *********************************************************************
217                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
218                        begin
219        1/1                if (!powergood_rst_trst_b)
220                           begin
221        1/1                   stap_tdomux_tdoen <= LOW;
222                           end
223        1/1                else if (stap_fsm_tlrs)
224                           begin
225        1/1                   stap_tdomux_tdoen <= LOW;
226                           end
227                           else
228                           begin
229        1/1                   stap_tdomux_tdoen <= (stap_fsm_shift_ir | stap_fsm_shift_dr);

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_tdomux 
                Total Covered Percent 
Totals          18    14      77.78   
Total Bits      186   139     74.73   
Total Bits 0->1 93    70      75.27   
Total Bits 1->0 93    69      74.19   

                              
Ports          13  11  84.62  
Port Bits      126 101 80.16  
Port Bits 0->1 63  51  80.95  
Port Bits 1->0 63  50  79.37  

                              
Signals          5  3  60.00  
Signal Bits      60 38 63.33  
Signal Bits 0->1 30 19 63.33  
Signal Bits 1->0 30 19 63.33  

Port Details
                               Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_drreg_tdo[0]              Yes    Yes         Yes         INPUT     
stap_drreg_tdo[3:1]            No     No          No          INPUT     
stap_drreg_tdo[4]              Yes    Yes         Yes         INPUT     
stap_drreg_tdo[6:5]            No     No          No          INPUT     
stap_drreg_tdo[7]              Yes    Yes         Yes         INPUT     
stap_drreg_tdo[12:8]           No     No          No          INPUT     
stap_drreg_tdo[14:13]          Yes    Yes         Yes         INPUT     
stap_drreg_tdo[15]             No     No          Yes         INPUT     
stap_drreg_tdo[25:16]          Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr              Yes    Yes         Yes         INPUT     
stap_fsm_shift_ir              Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[2]     No     No          No          INPUT     
stap_irdecoder_drselect[8:3]   Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[9]     No     No          No          INPUT     
stap_irdecoder_drselect[25:10] Yes    Yes         Yes         INPUT     
stap_irreg_serial_out          Yes    Yes         Yes         INPUT     
stap_fsm_tlrs                  Yes    Yes         Yes         INPUT     
ftap_tck                       Yes    Yes         Yes         INPUT     
powergood_rst_trst_b           Yes    Yes         Yes         INPUT     
swcomp_stap_post_tdo           Yes    Yes         Yes         INPUT     
tap_swcomp_active              Yes    Yes         Yes         INPUT     
stap_mux_tdo                   Yes    Yes         Yes         OUTPUT    
tdo_dr                         Yes    Yes         Yes         OUTPUT    
stap_tdomux_tdoen              Yes    Yes         Yes         OUTPUT    

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
stap_mux_tdo_preflop     Yes    Yes         Yes         
stap_mux_tdo_preflop_int Yes    Yes         Yes         
stap_en_tdo_posedge      No     No          No          
internal_mux_out[0]      Yes    Yes         Yes         
internal_mux_out[3:1]    No     No          No          
internal_mux_out[4]      Yes    Yes         Yes         
internal_mux_out[6:5]    No     No          No          
internal_mux_out[7]      Yes    Yes         Yes         
internal_mux_out[12:8]   No     No          No          
internal_mux_out[25:13]  Yes    Yes         Yes         
stap_mux_tdo_int         Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_tdomux 
         Line No. Total Covered Percent 
Branches          16    15      93.75   
CASE     123      4     3       75.00   
IF       155      4     4       100.00  
IF       175      3     3       100.00  
IF       197      2     2       100.00  
IF       219      3     3       100.00  


123              case (stap_fsm_shift_ir)
                 -1-  
124                 HIGH:
125                 begin
126                    stap_mux_tdo_preflop = stap_irreg_serial_out;
                       ==>
127                 end
128                 LOW:
129                 begin
130                    if(tap_swcomp_active == 1'b0)
                       -2-  
131                    begin
132                        stap_mux_tdo_preflop = swcomp_stap_post_tdo ;  //Only when tap_swcomp_active is 0, stitch the comparator window between TDI and TDO. Else bypass it. //PCR 1604263740 for SWCOMP Integration
                           ==>
133                    end
134                    else
135                    begin 
136                        stap_mux_tdo_preflop = tdo_dr ;
                           ==>
137                    end
138                 end
139                 default:
140                 begin
141                    stap_mux_tdo_preflop = ONE_BIT_UNKNOWN_VALUE;
                       ==>

Branches:

-1-     -2- Status      
HIGH    -   Covered     
LOW     1   Covered     
LOW     0   Covered     
default -   Not Covered 


155              if (!powergood_rst_trst_b)
                 -1-  
156              begin
157                 stap_mux_tdo_int <= LOW;
                    ==>
158              end
159              else if (stap_fsm_tlrs)
                      -2-  
160              begin
161                 stap_mux_tdo_int <= LOW;
                    ==>
162              end
163              else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
                      -3-                                   
164              begin
165                 stap_mux_tdo_int <= stap_mux_tdo_preflop;
                    ==>
166              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


175              if (!powergood_rst_trst_b)
                 -1-  
176              begin
177                 stap_mux_tdo_preflop_int = LOW;
                    ==>
178              end
179              else if (stap_fsm_tlrs)
                      -2-  
180              begin
181                 stap_mux_tdo_preflop_int = LOW;
                    ==>
182              end
183              //else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
184              //begin
185              //   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
186              //end
187              else 
188              begin
189                 stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


197              if (STAP_ENABLE_TDO_POS_EDGE == 1)
                 -1-  
198              begin
199                 stap_en_tdo_posedge = HIGH;
                    ==>
200              end
201              else
202              begin
203                 stap_en_tdo_posedge = LOW;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


219              if (!powergood_rst_trst_b)
                 -1-  
220              begin
221                 stap_tdomux_tdoen <= LOW;
                    ==>
222              end
223              else if (stap_fsm_tlrs)
                      -2-  
224              begin
225                 stap_tdomux_tdoen <= LOW;
                    ==>
226              end
227              else
228              begin
229                 stap_tdomux_tdoen <= (stap_fsm_shift_ir | stap_fsm_shift_dr);
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_tdomux(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                     
 88.16  96.00 --      74.73 --      93.75 --     STAP_RTL_LIB.stap_tdomux 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                     
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_mux_2to1_tdo_posedge(x) 



-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_tdomux(x)

             Line No.   Total   Covered  Percent
TOTAL                       22       22   100.00
ALWAYS            123        4        4   100.00
ALWAYS            155        6        6   100.00
ALWAYS            175        5        5   100.00
ALWAYS            197        2        2   100.00
ALWAYS            219        5        5   100.00

122                        begin
123        1/1                case (stap_fsm_shift_ir)
124                              HIGH:
125                              begin
126        1/1                      stap_mux_tdo_preflop = stap_irreg_serial_out;
127                              end
128                              LOW:
129                              begin
130        1/1                      if(tap_swcomp_active == 1'b0)
131                                 begin
132        excluded                     stap_mux_tdo_preflop = swcomp_stap_post_tdo ;  //Only when tap_swcomp_active is 0, stitch the comparator window between TDI and TDO. Else bypass it. //PCR 1604263740 for SWCOMP Integration
133                                 end
134                                 else
135                                 begin 
136        1/1                          stap_mux_tdo_preflop = tdo_dr ;
137                                 end
138                              end
139                              default:
140                              begin
141        excluded                 stap_mux_tdo_preflop = ONE_BIT_UNKNOWN_VALUE;
142                              end
143                           endcase
144                        end
145                     
146                        // *********************************************************************
147                        // TDO flop
148                        // ----------------------------
149                        // https://vthsd.intel.com/hsd/seg_softip/pcr/default.aspx?pcr_id=57136
150                        // To implement this PCR, the register stap_mux_tdo_int should be HIGH in
151                        // all non shift states.
152                        // *********************************************************************
153                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
154                        begin
155        1/1                if (!powergood_rst_trst_b)
156                           begin
157        1/1                   stap_mux_tdo_int <= LOW;
158                           end
159        1/1                else if (stap_fsm_tlrs)
160                           begin
161        1/1                   stap_mux_tdo_int <= LOW;
162                           end
163        1/1                else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
164                           begin
165        1/1                   stap_mux_tdo_int <= stap_mux_tdo_preflop;
166                           end
                        MISSING_ELSE
167                        end
168                     
169                        // *********************************************************************
170                        // To qualify the preflop signal with powergood and fsm_tlrs, which is 
171                        // to be sent on posedge when the retime parameter is enabled
172                        // *********************************************************************
173                        always_comb
174                        begin
175        1/1                if (!powergood_rst_trst_b)
176                           begin
177        1/1                   stap_mux_tdo_preflop_int = LOW;
178                           end
179        1/1                else if (stap_fsm_tlrs)
180                           begin
181        1/1                   stap_mux_tdo_preflop_int = LOW;
182                           end
183                           //else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
184                           //begin
185                           //   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
186                           //end
187                           else 
188                           begin
189        1/1                   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
190                           end
191                        end
192                     
193                        // *********************************************************************
194                        // TDO to be sent on posedge when the retime parameter is enabled
195                        // *********************************************************************
196                        always_comb
197        1/1                if (STAP_ENABLE_TDO_POS_EDGE == 1)
198                           begin
199        excluded              stap_en_tdo_posedge = HIGH;
200                           end
201                           else
202                           begin
203        1/1                   stap_en_tdo_posedge = LOW;
204                           end
205                     
206                     //   stap_ctech_lib_clk_mux_2to1 i_stap_ctech_lib_clk_mux_2to1_tdo_posedge (.clk1(stap_mux_tdo_preflop_int),
207                     //                                                                .clk2(stap_mux_tdo_int),
208                     //                                                                .s(stap_en_tdo_posedge),
209                     //                                                                .clkout(stap_mux_tdo)
210                     //                                                               );
211                       stap_ctech_lib_mux_2to1 i_stap_ctech_lib_mux_2to1_tdo_posedge (
212                        .d1(stap_mux_tdo_preflop_int ), .d2(stap_mux_tdo_int ), .s(stap_en_tdo_posedge ), .o(stap_mux_tdo ));
213                     
214                        // *********************************************************************
215                        // TDOen flop
216                        // *********************************************************************
217                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
218                        begin
219        1/1                if (!powergood_rst_trst_b)
220                           begin
221        1/1                   stap_tdomux_tdoen <= LOW;
222                           end
223        1/1                else if (stap_fsm_tlrs)
224                           begin
225        1/1                   stap_tdomux_tdoen <= LOW;
226                           end
227                           else
228                           begin
229        1/1                   stap_tdomux_tdoen <= (stap_fsm_shift_ir | stap_fsm_shift_dr);

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_tdomux(x)
                Total Covered Percent 
Totals          16    16      100.00  
Total Bits      108   108     100.00  
Total Bits 0->1 54    54      100.00  
Total Bits 1->0 54    54      100.00  

                            
Ports          12 12 100.00 
Port Bits      70 70 100.00 
Port Bits 0->1 35 35 100.00 
Port Bits 1->0 35 35 100.00 

                              
Signals          4  4  100.00 
Signal Bits      38 38 100.00 
Signal Bits 0->1 19 19 100.00 
Signal Bits 1->0 19 19 100.00 

Port Details
                               Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_drreg_tdo[25:0]           Excluded Excluded    Excluded    INPUT     
stap_fsm_shift_dr              Yes      Yes         Yes         INPUT     
stap_fsm_shift_ir              Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[2]     Excluded Excluded    Excluded    INPUT     
stap_irdecoder_drselect[8:3]   Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[9]     Excluded Excluded    Excluded    INPUT     
stap_irdecoder_drselect[25:10] Yes      Yes         Yes         INPUT     
stap_irreg_serial_out          Yes      Yes         Yes         INPUT     
stap_fsm_tlrs                  Yes      Yes         Yes         INPUT     
ftap_tck                       Yes      Yes         Yes         INPUT     
powergood_rst_trst_b           Yes      Yes         Yes         INPUT     
swcomp_stap_post_tdo           Yes      Yes         Yes         INPUT     
tap_swcomp_active              Yes      Yes         Yes         INPUT     
stap_mux_tdo                   Yes      Yes         Yes         OUTPUT    
tdo_dr                         Yes      Yes         Yes         OUTPUT    
stap_tdomux_tdoen              Yes      Yes         Yes         OUTPUT    

Signal Details
                         Toggle   Toggle 1->0 Toggle 0->1 
stap_mux_tdo_preflop     Yes      Yes         Yes         
stap_mux_tdo_preflop_int Yes      Yes         Yes         
stap_en_tdo_posedge      Excluded Excluded    Excluded    
internal_mux_out[0]      Yes      Yes         Yes         
internal_mux_out[3:1]    Excluded Excluded    Excluded    
internal_mux_out[4]      Yes      Yes         Yes         
internal_mux_out[6:5]    Excluded Excluded    Excluded    
internal_mux_out[7]      Yes      Yes         Yes         
internal_mux_out[12:8]   Excluded Excluded    Excluded    
internal_mux_out[25:13]  Yes      Yes         Yes         
stap_mux_tdo_int         Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_tdomux(x)
         Line No. Total Covered Percent 
Branches          13    13      100.00  
CASE     123      2     2       100.00  
IF       155      4     4       100.00  
IF       175      3     3       100.00  
IF       197      1     1       100.00  
IF       219      3     3       100.00  


123              case (stap_fsm_shift_ir)
                 -1-  
124                 HIGH:
125                 begin
126                    stap_mux_tdo_preflop = stap_irreg_serial_out;
                       ==>
127                 end
128                 LOW:
129                 begin
130                    if(tap_swcomp_active == 1'b0)
                       -2-  
131                    begin
132                        stap_mux_tdo_preflop = swcomp_stap_post_tdo ;  //Only when tap_swcomp_active is 0, stitch the comparator window between TDI and TDO. Else bypass it. //PCR 1604263740 for SWCOMP Integration
                           ==>
133                    end
134                    else
135                    begin 
136                        stap_mux_tdo_preflop = tdo_dr ;
                           ==> (Excluded)
137                    end
138                 end
139                 default:
140                 begin
141                    stap_mux_tdo_preflop = ONE_BIT_UNKNOWN_VALUE;
                       ==> (Excluded)

Branches:

-1-     -2- Status   
HIGH    -   Covered  
LOW     1   Covered  
LOW     0   Excluded 
default -   Excluded 


155              if (!powergood_rst_trst_b)
                 -1-  
156              begin
157                 stap_mux_tdo_int <= LOW;
                    ==>
158              end
159              else if (stap_fsm_tlrs)
                      -2-  
160              begin
161                 stap_mux_tdo_int <= LOW;
                    ==>
162              end
163              else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
                      -3-                                   
164              begin
165                 stap_mux_tdo_int <= stap_mux_tdo_preflop;
                    ==>
166              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


175              if (!powergood_rst_trst_b)
                 -1-  
176              begin
177                 stap_mux_tdo_preflop_int = LOW;
                    ==>
178              end
179              else if (stap_fsm_tlrs)
                      -2-  
180              begin
181                 stap_mux_tdo_preflop_int = LOW;
                    ==>
182              end
183              //else if (stap_fsm_shift_ir | stap_fsm_shift_dr)
184              //begin
185              //   stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
186              //end
187              else 
188              begin
189                 stap_mux_tdo_preflop_int = stap_mux_tdo_preflop;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


197              if (STAP_ENABLE_TDO_POS_EDGE == 1)
                 -1-  
198              begin
199                 stap_en_tdo_posedge = HIGH;
                    ==> (Excluded)
200              end
201              else
202              begin
203                 stap_en_tdo_posedge = LOW;
                    ==>

Branches:

-1- Status   
1   Excluded 
0   Covered  


219              if (!powergood_rst_trst_b)
                 -1-  
220              begin
221                 stap_tdomux_tdoen <= LOW;
                    ==>
222              end
223              else if (stap_fsm_tlrs)
                      -2-  
224              begin
225                 stap_tdomux_tdoen <= LOW;
                    ==>
226              end
227              else
228              begin
229                 stap_tdomux_tdoen <= (stap_fsm_shift_ir | stap_fsm_shift_dr);
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


===============================================================================
Module : STAP_RTL_LIB.stap_drreg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 88.37  73.50 100.00  94.77 --      73.56 100.00 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_drreg.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                              
100.00 100.00 100.00 100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_drreg 

             Line No.   Total   Covered  Percent
TOTAL                      117       86    73.50
ALWAYS            324        8        8   100.00
ALWAYS            394        5        5   100.00
ALWAYS            419       10       10   100.00
ALWAYS            525       11        4    36.36
ALWAYS            525       11        4    36.36
ALWAYS            525       11        4    36.36
ALWAYS            525       11        4    36.36
ALWAYS            735        6        4    66.67
ALWAYS            768        4        3    75.00
ALWAYS            804        3        3   100.00
ALWAYS            804        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            166        8        8   100.00
ALWAYS            166        8        8   100.00
ALWAYS            166        8        8   100.00
INITIAL           244        1        1   100.00

323                        begin
324        1/1                if (!powergood_rst_trst_b)
325                           begin
326        1/1                   bypass_reg <= LOW;
327                           end
328        1/1                else if (stap_fsm_tlrs)
329                           begin
330        1/1                   bypass_reg <= LOW;
331                           end
332        1/1                else if (stap_fsm_capture_dr & irdecoder_drselect)
333                           begin
334        1/1                   bypass_reg <= LOW;
335                           end
336        1/1                else if (stap_fsm_shift_dr & irdecoder_drselect)
337                           begin
338        1/1                   bypass_reg <= ftap_tdi;
339                           end
                        MISSING_ELSE
340                        end
341                     
342                        // *********************************************************************
343                        // stap_drreg_tdo implementation for bits all ones
344                        // *********************************************************************
345                        assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] =
346                           (stap_and_all_bits_irreg == HIGH) ? bypass_reg :
347                           (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW;
348                     
349                        // *********************************************************************
350                        // Dummy assignments to avoid lintra warnings
351                        // *********************************************************************
352                        generate
353                           if (DRREG_STAP_ENABLE_BSCAN == 1)
354                           begin:generate_bscan_regs
355                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_SAMPLE_PRELOAD] = LOW;
356                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_HIGHZ]          = LOW;
357                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST]         = LOW;
358                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_PULSE]   = LOW;
359                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_TRAIN]   = LOW;
360                     
361                              if (DRREG_STAP_NUMBER_OF_PRELOAD_REGISTERS > 0)
362                              begin:generate_bscan_regs_1
363                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_PRELOAD] = LOW;
364                              end
365                     
366                              if (DRREG_STAP_NUMBER_OF_CLAMP_REGISTERS > 0)
367                              begin:generate_bscan_regs_2
368                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_CLAMP] = LOW;
369                              end
370                     
371                              if (DRREG_STAP_NUMBER_OF_INTEST_REGISTERS > 0)
372                              begin:generate_bscan_regs_3
373                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_INTEST] = LOW;
374                              end
375                     
376                              if (DRREG_STAP_NUMBER_OF_RUNBIST_REGISTERS > 0)
377                              begin:generate_bscan_regs_4
378                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_RUNBIST] = LOW;
379                              end
380                     
381                              if (DRREG_STAP_NUMBER_OF_EXTEST_TOGGLE_REGISTERS > 0)
382                              begin:generate_bscan_regs_5
383                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_TOGGLE] = LOW;
384                              end
385                           end
386                        endgenerate
387                     
388                        // *********************************************************************
389                        // Reset pulse generation logic. To avoid lintra error which complains about
390                        // loading pin values during reset
391                        // *********************************************************************
392                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
393                        begin
394        1/1                if (!powergood_rst_trst_b)
395                           begin
396        1/1                   reset_pulse0 <= LOW;
397        1/1                   reset_pulse1 <= LOW;
398                           end
399                           else
400                           begin
401        1/1                   reset_pulse0 <= HIGH;
402        1/1                   reset_pulse1 <= reset_pulse0;
403                           end
404                        end
405                     
406                        assign reset_pulse = reset_pulse0 & (~reset_pulse1);
407                     
408                        // *********************************************************************
409                        // Generation of ftap_slvidcode reset value.
410                        // *********************************************************************
411                        assign slvidcode_reset_value = {ftap_slvidcode[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1], HIGH};
412                        assign ftap_slvidcode0_NC    = ftap_slvidcode[0];
413                     
414                        // *********************************************************************
415                        // IDCODE register implementation
416                        // *********************************************************************
417                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
418                        begin
419        1/1                if (!powergood_rst_trst_b)
420                           begin
421        1/1                   slvidcode_reg <= {{(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1){LOW}}, HIGH};
422                           end
423        1/1                else if (reset_pulse)
424                           begin
425        1/1                   slvidcode_reg <= slvidcode_reset_value;
426                           end
427        1/1                else if (stap_fsm_tlrs)
428                           begin
429        1/1                   slvidcode_reg <= slvidcode_reset_value;
430                           end
431        1/1                else if (stap_fsm_capture_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
432                           begin
433        1/1                   slvidcode_reg <= slvidcode_reset_value;
434                           end
435        1/1                else if (stap_fsm_shift_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
436                           begin
437        1/1                   slvidcode_reg <= {ftap_tdi, slvidcode_reg[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1]};
438                           end
                        MISSING_ELSE
439                        end
440                        // ---------------------------------------------------------------------
441                        // stap_drreg_tdo[DRREG_STAP_POSITION_OF_SLVIDCODE] is going to the TDOmux FUB.
442                        // ---------------------------------------------------------------------
443                        assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_SLVIDCODE] = slvidcode_reg[0];
444                     
445                        // *********************************************************************
446                        // sftapnw_ftap_secsel register implementation.
447                        // Module stap_data_reg is instantiated to create register sftapnw_ftap_secsel.
448                        // This register is generated only if tap nework is enabled and
449                        // secondary register is enabled.
450                        // *********************************************************************
451                        generate
452                           if (DRREG_STAP_ENABLE_TAP_NETWORK == 1)
453                           begin:generate_tapnw_sec_sel_tdr
454                              if (DRREG_STAP_ENABLE_TAPC_SEC_SEL == 1)
455                              begin:generate_tapnw_sec_sel_tdr_1
456                                 stap_data_reg #(
457                                                 .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_TAPS),
458                                                 .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_TAPS{LOW}})
459                                                )
460                                 i_stap_data_reg_tapc_sec_sel (
461                                                               .sync_reset              (LOW),
462                                                               .ftap_tck                (ftap_tck),
463                                                               .ftap_tdi                (ftap_tdi),
464                                                               .reset_b                 (fdfx_powergood),
465                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SEC_SEL]),
466                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
467                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
468                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
469                                                               .tdr_data_in             (sftapnw_ftap_secsel),
470                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_SEC_SEL]),
471                                                               .tdr_data_out            (sftapnw_ftap_secsel)
472                                                              );
473                              end
474                              else
475                              begin:generate_tapnw_sec_sel_tdr_1
476                                 assign sftapnw_ftap_secsel[(DRREG_STAP_NUMBER_OF_TAPS - 1):0] = {DRREG_STAP_NUMBER_OF_TAPS{LOW}};
477                              end
478                           end
479                           else
480                           begin:generate_tapnw_sec_sel_tdr
481                              assign sftapnw_ftap_secsel[(DRREG_STAP_NUMBER_OF_TAPS - 1):0] = {DRREG_STAP_NUMBER_OF_TAPS{LOW}};
482                           end
483                        endgenerate
484                     
485                        // *********************************************************************
486                        // tapc_select register implementation.
487                        // Module stap_data_reg is instantiated to create register tapc_select.
488                        // *********************************************************************
489                        generate
490                           if (DRREG_STAP_ENABLE_TAP_NETWORK == 1)
491                           begin:generate_tapc_sel_tdr
492                              stap_data_reg #(
493                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2),
494                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2{LOW}})
495                                             )
496                              i_stap_data_reg_tapc_select (
497                                                           .sync_reset              (LOW),
498                                                           .ftap_tck                (ftap_tck),
499                                                           .ftap_tdi                (ftap_tdi),
500                                                           .reset_b                 (fdfx_powergood),
501                                                           .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_SELECT]),
502                                                           .stap_fsm_capture_dr     (stap_fsm_capture_dr),
503                                                           .stap_fsm_shift_dr       (stap_fsm_shift_dr),
504                                                           .stap_fsm_update_dr      (stap_fsm_update_dr),
505                                                           .tdr_data_in             (tapc_select_int),
506                                                           .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_SELECT]),
507                                                           .tdr_data_out            (tapc_select_int)
508                                                          );
509                           end
510                           else
511                           begin:generate_tapc_sel_tdr
512                              assign tapc_select_int[(DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2 - 1):0] = TWO_BIT_ZERO;
513                           end
514                        endgenerate
515                     
516                        // *********************************************************************
517                        assign green_en   = (feature_green_en  | feature_orange_en | feature_red_en);
518                        assign orange_en  = (feature_orange_en | feature_red_en);
519                     
520                        generate
521                           for (genvar m = 0; m < DRREG_STAP_NUMBER_OF_TAPS; m = m + 1)
522                           begin:generate_taps_security
523                              always_comb
524                              begin
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        1/1                            if (feature_red_en)
529                                       begin
530        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        0/1     ==>                    if (orange_en)
540                                       begin
541        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        0/1     ==>                    if (green_en)
551                                       begin
552        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        0/1     ==>                    tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 1
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        1/1                            if (feature_red_en)
529                                       begin
530        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        0/1     ==>                    if (orange_en)
540                                       begin
541        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        0/1     ==>                    if (green_en)
551                                       begin
552        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        0/1     ==>                    tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 2
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        0/1     ==>                    if (feature_red_en)
529                                       begin
530        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        1/1                            if (orange_en)
540                                       begin
541        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        0/1     ==>                    if (green_en)
551                                       begin
552        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        0/1     ==>                    tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 3
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        0/1     ==>                    if (feature_red_en)
529                                       begin
530        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        1/1                            if (orange_en)
540                                       begin
541        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        1/1                               tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        0/1     ==>                    if (green_en)
551                                       begin
552        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        0/1     ==>                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        0/1     ==>                    tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
562                                    end
563                                 endcase
564                              end
565                           end
566                        endgenerate
567                     
568                        // *********************************************************************
569                     
570                        // *********************************************************************
571                        // tapc_wtap_sel register implementation.
572                        // Module stap_data_reg is instantiated to create register tapc_wtap_sel.
573                        // This register is generated only if wtap nework is enabled.
574                        // *********************************************************************
575                        generate
576                           if (DRREG_STAP_ENABLE_WTAP_NETWORK == 1)
577                           begin:generate_wtap_nw_tdr
578                              stap_data_reg #(
579                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_WTAPS),
580                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_WTAPS{DRREG_STAP_WTAPCTRL_RESET_VALUE}})
581                                             )
582                              i_stap_data_reg_tapc_wtap_sel (
583                                                             .sync_reset              (LOW),
584                                                             .ftap_tck                (ftap_tck),
585                                                             .ftap_tdi                (ftap_tdi),
586                                                             .reset_b                 (fdfx_powergood),
587                                                             .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_WTAPNW_SELECTWIR]),
588                                                             .stap_fsm_capture_dr     (stap_fsm_capture_dr),
589                                                             .stap_fsm_shift_dr       (stap_fsm_shift_dr),
590                                                             .stap_fsm_update_dr      (stap_fsm_update_dr),
591                                                             .tdr_data_in             (tapc_wtap_sel),
592                                                             .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_WTAPNW_SELECTWIR]),
593                                                             .tdr_data_out            (tapc_wtap_sel)
594                                                            );
595                           end
596                           else
597                           begin:generate_wtap_nw_tdr
598                              assign tapc_wtap_sel[0] = LOW;
599                           end
600                        endgenerate
601                     
602                        // *********************************************************************
603                        // tapc_remove register implementation.
604                        // Module stap_data_reg is instantiated to create register tapc_remove.
605                        // *********************************************************************
606                        generate
607                           if (DRREG_STAP_ENABLE_TAPC_REMOVE == 1)
608                           begin:generate_tapc_remove_tdr
609                              stap_data_reg #(
610                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_WIDTH_OF_TAPC_REMOVE),
611                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_WIDTH_OF_TAPC_REMOVE{LOW}})
612                                             )
613                              i_stap_data_reg_tapc_remove (
614                                                           .sync_reset              (LOW),
615                                                           .ftap_tck                (ftap_tck),
616                                                           .ftap_tdi                (ftap_tdi),
617                                                           .reset_b                 (fdfx_powergood),
618                                                           .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_REMOVE]),
619                                                           .stap_fsm_capture_dr     (stap_fsm_capture_dr),
620                                                           .stap_fsm_shift_dr       (stap_fsm_shift_dr),
621                                                           .stap_fsm_update_dr      (stap_fsm_update_dr),
622                                                           .tdr_data_in             (tapc_remove),
623                                                           .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_REMOVE]),
624                                                           .tdr_data_out            (tapc_remove)
625                                                          );
626                           end
627                           else
628                           begin:generate_tapc_remove_tdr
629                              assign tapc_remove = {DRREG_STAP_WIDTH_OF_TAPC_REMOVE{LOW}};
630                           end
631                        endgenerate
632                     //*************************************************************************
633                     // Programmable Reset Implementation for iTDRs and RTDRs.
634                     //*************************************************************************
635                        // *********************************************************************
636                        // TAPC_TDRRSTEN 'h15 register implementation.
637                        // Module stap_data_reg is instantiated to create register TAPC_TDRRSTEN.
638                        // *********************************************************************
639                        generate
640                           if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
641                           begin:generate_tapc_tdrrsten_tdr
642                              stap_data_reg #(
643                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_SIZE_OF_TDRRSTEN_REGISTER),
644                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_SIZE_OF_TDRRSTEN_REGISTER{LOW}})
645                                             )
646                              i_stap_data_reg_tapc_tdrrsten (
647                                                             .sync_reset              (LOW),
648                                                             .ftap_tck                (ftap_tck),
649                                                             .ftap_tdi                (ftap_tdi),
650                                                             .reset_b                 (fdfx_powergood),
651                                                             .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_TDRRSTEN]),
652                                                             .stap_fsm_capture_dr     (stap_fsm_capture_dr),
653                                                             .stap_fsm_shift_dr       (stap_fsm_shift_dr),
654                                                             .stap_fsm_update_dr      (stap_fsm_update_dr),
655                                                             .tdr_data_in             (tapc_tdrrsten_reg),
656                                                             .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_TDRRSTEN]),
657                                                             .tdr_data_out            (tapc_tdrrsten_reg)
658                                                            );
659                           end
660                           else
661                           begin:generate_tapc_tdrrsten_tdr
662                              assign tapc_tdrrsten_reg[(DRREG_SIZE_OF_TDRRSTEN_REGISTER - 1):0] = TWO_BIT_ZERO;
663                           end
664                        endgenerate
665                     
666                        // *********************************************************************
667                        // TAPC_ITDRRSTSEL 'h16 register implementation.
668                        // Module stap_data_reg is instantiated to create register TAPC_ITDRRSTSEL.
669                        // *********************************************************************
670                        generate
671                           if (DRREG_STAP_ENABLE_ITDR_PROG_RST == 1)
672                           begin:generate_tapc_itdrrstsel_tdr
673                              stap_data_reg #(
674                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ),
675                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{LOW}})
676                                             )
677                              i_stap_data_reg_tapc_itdrrstsel (
678                                                               .sync_reset              (LOW),
679                                                               .ftap_tck                (ftap_tck),
680                                                               .ftap_tdi                (ftap_tdi),
681                                                               .reset_b                 (fdfx_powergood),
682                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_ITDRRSTSEL]),
683                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
684                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
685                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
686                                                               .tdr_data_in             (tapc_itdrrstsel_reg),
687                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_ITDRRSTSEL]),
688                                                               .tdr_data_out            (tapc_itdrrstsel_reg)
689                                                              );
690                           end
691                           else
692                           begin:generate_tapc_itdrrstsel_tdr
693                              assign tapc_itdrrstsel_reg = {DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{LOW}};
694                           end
695                        endgenerate
696                     
697                        // *********************************************************************
698                        // TAPC_RTDRRSTSEL 'h17 register implementation.
699                        // Module stap_data_reg is instantiated to create register TAPC_RTDRRSTSEL.
700                        // *********************************************************************
701                        generate
702                           if (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1)
703                           begin:generate_tapc_rtdrrstsel_tdr
704                              stap_data_reg #(
705                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ),
706                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ{LOW}})
707                                             )
708                              i_stap_data_reg_tapc_rtdrrstsel (
709                                                               .sync_reset              (LOW),
710                                                               .ftap_tck                (ftap_tck),
711                                                               .ftap_tdi                (ftap_tdi),
712                                                               .reset_b                 (fdfx_powergood),
713                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_RTDRRSTSEL]),
714                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
715                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
716                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
717                                                               .tdr_data_in             (tapc_rtdrrstsel_reg),
718                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_RTDRRSTSEL]),
719                                                               .tdr_data_out            (tapc_rtdrrstsel_reg)
720                                                              );
721                           end
722                           else
723                           begin:generate_tapc_rtdrrstsel_tdr
724                              assign tapc_rtdrrstsel_reg = {DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ{LOW}};
725                           end
726                        endgenerate
727                     
728                        // *********************************************************************
729                        // Logic for selecting soft programmable reset option for ITDRs/RTDRs 
730                        // based on the regiseter TAPC_TDRRSTEN.
731                        // *********************************************************************
732                        generate
733                           always_comb
734                           begin
735        1/1                   if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
736                              begin:generate_soft_rst_mux
737        1/1                      case (tapc_tdrrsten_reg[1])
738                                 LOW:
739                                 begin
740        1/1                        prgm_soft_rst_mux = fdfx_powergood;
741                                 end
742                                 HIGH:
743                                 begin
744        1/1                        prgm_soft_rst_mux = (!tapc_tdrrsten_reg[1]);
745                                 end
746                                 default:
747                                 begin
748        0/1     ==>                prgm_soft_rst_mux = fdfx_powergood;
749                                 end
750                                 endcase
751                              end
752                              else
753                              begin
754        0/1     ==>              prgm_soft_rst_mux = fdfx_powergood;
755                              end
756                           end
757                        endgenerate
758                     
759                        // *********************************************************************
760                        // Logic for selecting ftap_trst_b programmable reset option for ITDRs/RTDRs 
761                        // based on the regiseter TAPC_TDRRSTEN.
762                        // *********************************************************************
763                        generate
764                           if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
765                           begin:generate_hard_rst_mux
766                              always_comb
767                              begin
768        1/1                      case (tapc_tdrrsten_reg[0])
769                                 LOW:
770                                 begin
771        1/1                        prgm_hard_rst_mux = prgm_soft_rst_mux;
772                                 end
773                                 HIGH:
774                                 begin
775                                   // Fix HSD 4903467
776                                   //prgm_hard_rst_mux = (ftap_trst_b); 
777        1/1                        prgm_hard_rst_mux = ((ftap_trst_b) & (!stap_fsm_tlrs));
778                                 end
779                                 default:
780                                 begin
781        0/1     ==>                prgm_hard_rst_mux = prgm_soft_rst_mux;
782                                 end
783                                 endcase
784                              end
785                           end
786                           else
787                           begin:generate_hard_rst_mux
788                              assign prgm_hard_rst_mux = prgm_soft_rst_mux;
789                           end
790                        endgenerate
791                     
792                        // *********************************************************************
793                        // Logic to check which ITDR bit in reg TAPC_ITDRRSTSEL is set to one 
794                        // for programmable reset option and pass the reset to respective ITDR
795                        // whose bit in TAPC_ITDRRSTSEL is set to one.
796                        // *********************************************************************
797                        generate
798                           if (DRREG_STAP_ENABLE_ITDR_PROG_RST == 1)
799                           begin:generate_prog_rst_itdr
800                              for (genvar y = 0; y < DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ; y = y + 1)
801                              begin:generate_async_rst_itdr_1
802                                 always_comb
803                                 begin
804        1/1                         if (tapc_itdrrstsel_reg[y] == 1)
805        1/1                            itdr_async_reset[y] = prgm_hard_rst_mux;
806                                    else
807        1/1                            itdr_async_reset[y] = fdfx_powergood;
***repeat 4
804        1/1                         if (tapc_itdrrstsel_reg[y] == 1)
805        1/1                            itdr_async_reset[y] = prgm_hard_rst_mux;
806                                    else
807        1/1                            itdr_async_reset[y] = fdfx_powergood;
808                                 end
809                              end
810                           end
811                           else
812                           begin:generate_prog_rst_itdr
813                              assign itdr_async_reset = {DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{fdfx_powergood}};
814                           end
815                        endgenerate
816                     
817                        // *********************************************************************
818                        // Logic to check which RTDR bit in reg TAPC_RTDRRSTSEL is set to one 
819                        // for programmable reset option and pass the reset to respective RTDR
820                        // whose bit in TAPC_RTDRRSTSEL is set to one.
821                        // *********************************************************************
822                        generate
823                           if (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1)
824                           begin:generate_prog_rst_rtdr
825                              for (genvar z = 0; z < DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ; z = z + 1)
826                              begin:generate_sync_rst_rtdr_1
827                                 always_comb
828                                 begin
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;
***repeat 5
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;
***repeat 6
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;

  FILE: /nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/include/assertions/stap_drreg_include.sv
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
***repeat 7
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
***repeat 8
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
205                     
206                                    end
207                                 end
208                              end
209                              else
210                              begin
211                                 always @(posedge ftap_tck)
212                                 begin
213                                    if (fdfx_powergood === HIGH)
214                                    begin
215                                       chk_rtdr_prog_rst_when_rtdr_disabled:
216                                       assert property (tap_rtdr_prog_rst_b[0] === HIGH)
217                                       else $error("The tap_rtdr_prog_rst_b is not HIGH when the RTDRs are disabled");
218                                    end
219                                 end
220                              end
221                           endgenerate
222                     
223                            // ====================================================================
224                            // Check at any given point of time only one bit of stap_irdecoder_drselect
225                            // should be high
226                            // ====================================================================
227                            check_irdec_only_one_bit_is_high:assert property ( @(posedge ftap_tck) $onehot0(stap_irdecoder_drselect) ) 
228                            else $error("Only one bit of stap_irdecoder_drselect is not one at a time"); 
229                     
230                        `endif
231                     `endif
232                     
233                     
234                     //-------------------------------------------------------------------------------------------
235                     `ifndef INTEL_SVA_OFF
236                        `ifdef DFX_PARAMETER_CHECKER
237                           `ifndef DFX_FPV_ENABLE
238                               initial
239                               begin
240                                  // ====================================================================
241                                  // To check the width of stap_irdecoder_drselect is equal to
242                                  // DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS
243                                  // ====================================================================
244                                  assert ($size(stap_irdecoder_drselect) === DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS)
245                                  else $fatal ("The width of the stap_irdecoder_drselect is not equal to DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS");
246        1/1                       $display ("stap_irdecoder_drselect_width     = %0d ", $size(stap_irdecoder_drselect));

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_drreg 

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       311
 EXPRESSION 
 Number  Term
      1  (stap_and_all_bits_irreg == HIGH) ? stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] : stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES])

-1- Status
 0  Covered
 1  Covered

 LINE       345
 EXPRESSION ((stap_and_all_bits_irreg == HIGH) ? bypass_reg : ((stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW))
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       345
 SUB-EXPRESSION ((stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW)
                 ------------------------------------1------------------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_drreg 
                Total Covered Percent 
Totals          58    48      82.76   
Total Bits      784   743     94.77   
Total Bits 0->1 392   373     95.15   
Total Bits 1->0 392   370     94.39   

                              
Ports          36  33  91.67  
Port Bits      538 512 95.17  
Port Bits 0->1 269 257 95.54  
Port Bits 1->0 269 255 94.80  

                                
Signals          22  15  68.18  
Signal Bits      246 231 93.90  
Signal Bits 0->1 123 116 94.31  
Signal Bits 1->0 123 115 93.50  

Port Details
                               Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_fsm_tlrs                  Yes    Yes         Yes         INPUT     
ftap_tdi                       Yes    Yes         Yes         INPUT     
ftap_tck                       Yes    Yes         Yes         INPUT     
ftap_trst_b                    Yes    Yes         Yes         INPUT     
fdfx_powergood                 Yes    Yes         Yes         INPUT     
powergood_rst_trst_b           Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr            Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr              Yes    Yes         Yes         INPUT     
stap_fsm_update_dr             Yes    Yes         Yes         INPUT     
stap_selectwir                 Yes    Yes         Yes         INPUT     
ftap_slvidcode[31:0]           Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[2]     No     No          No          INPUT     
stap_irdecoder_drselect[8:3]   Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[9]     No     No          No          INPUT     
stap_irdecoder_drselect[25:10] Yes    Yes         Yes         INPUT     
tdr_data_in[63:0]              Yes    Yes         Yes         INPUT     
tdr_data_out[63:0]             Yes    Yes         Yes         OUTPUT    
sftapnw_ftap_secsel[3:0]       Yes    Yes         Yes         OUTPUT    
tapc_select[7:0]               Yes    Yes         Yes         OUTPUT    
feature_green_en               Yes    Yes         Yes         INPUT     
feature_orange_en              Yes    Yes         Yes         INPUT     
feature_red_en                 Yes    Yes         Yes         INPUT     
tapc_wtap_sel[2:0]             Yes    Yes         Yes         OUTPUT    
tapc_remove                    No     No          Yes         OUTPUT    
stap_drreg_tdo[0]              Yes    Yes         Yes         OUTPUT    
stap_drreg_tdo[3:1]            No     No          No          OUTPUT    
stap_drreg_tdo[4]              Yes    Yes         Yes         OUTPUT    
stap_drreg_tdo[6:5]            No     No          No          OUTPUT    
stap_drreg_tdo[7]              Yes    Yes         Yes         OUTPUT    
stap_drreg_tdo[12:8]           No     No          No          OUTPUT    
stap_drreg_tdo[14:13]          Yes    Yes         Yes         OUTPUT    
stap_drreg_tdo[15]             No     No          Yes         OUTPUT    
stap_drreg_tdo[25:16]          Yes    Yes         Yes         OUTPUT    
swcompctrl_tdo                 Yes    Yes         Yes         INPUT     
swcompstat_tdo                 Yes    Yes         Yes         INPUT     
stap_and_all_bits_irreg        Yes    Yes         Yes         INPUT     
rtdr_tap_tdo[2:0]              Yes    Yes         Yes         INPUT     
tap_rtdr_tdi[2:0]              Yes    Yes         Yes         OUTPUT    
tap_rtdr_capture[2:0]          Yes    Yes         Yes         OUTPUT    
tap_rtdr_shift[2:0]            Yes    Yes         Yes         OUTPUT    
tap_rtdr_update[2:0]           Yes    Yes         Yes         OUTPUT    
tap_rtdr_irdec[2:0]            Yes    Yes         Yes         OUTPUT    
tap_rtdr_selectir              Yes    Yes         Yes         OUTPUT    
tap_rtdr_powergood             Yes    Yes         Yes         OUTPUT    
tap_rtdr_rti                   Yes    Yes         Yes         OUTPUT    
tap_rtdr_prog_rst_b[2:0]       Yes    Yes         Yes         OUTPUT    
stap_fsm_rti                   Yes    Yes         Yes         INPUT     

Signal Details
                               Toggle Toggle 1->0 Toggle 0->1 
slvidcode_reset_value[0]       No     No          No          
slvidcode_reset_value[31:1]    Yes    Yes         Yes         
reset_pulse                    Yes    Yes         Yes         
bypass_reg                     Yes    Yes         Yes         
slvidcode_reg[31:0]            Yes    Yes         Yes         
reset_pulse0                   Yes    Yes         Yes         
reset_pulse1                   Yes    Yes         Yes         
irdecoder_drselect             Yes    Yes         Yes         
stap_fsm_rti_NC                No     No          No          
stap_irdecoder_drsel_NC[1:0]   Yes    Yes         Yes         
stap_irdecoder_drsel_NC[2]     No     No          No          
stap_irdecoder_drsel_NC[8:3]   Yes    Yes         Yes         
stap_irdecoder_drsel_NC[9]     No     No          No          
stap_irdecoder_drsel_NC[25:10] Yes    Yes         Yes         
ftap_slvidcode0_NC             Yes    Yes         Yes         
stap_selectwir_NC              No     No          No          
rtdr_tap_tdo_NC                No     No          No          
green_en                       No     No          No          
orange_en                      Yes    Yes         Yes         
tapc_select_int[7:0]           Yes    Yes         Yes         
tapc_tdrrsten_reg[0]           No     No          Yes         
tapc_tdrrsten_reg[1]           Yes    Yes         Yes         
tapc_itdrrstsel_reg[1:0]       Yes    Yes         Yes         
tapc_rtdrrstsel_reg[2:0]       Yes    Yes         Yes         
prgm_soft_rst_mux              Yes    Yes         Yes         
prgm_hard_rst_mux              Yes    Yes         Yes         
itdr_async_reset[1:0]          Yes    Yes         Yes         
rtdr_sync_reset[2:0]           Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_drreg 
         Line No. Total Covered Percent 
Branches          87    64      73.56   
TERNARY  311      2     2       100.00  
TERNARY  345      3     3       100.00  
IF       324      5     5       100.00  
IF       394      2     2       100.00  
IF       419      6     6       100.00  
IF       735      4     2       50.00   
CASE     525      7     2       28.57   
CASE     525      7     2       28.57   
CASE     525      7     2       28.57   
CASE     525      7     2       28.57   
CASE     768      3     2       66.67   
IF       804      2     2       100.00  
IF       804      2     2       100.00  
IF       829      2     2       100.00  
IF       829      2     2       100.00  
IF       829      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  


311           assign irdecoder_drselect =
                                         
312              (stap_and_all_bits_irreg == HIGH) ? stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES]  :
                                                   -1-  
                                                   ==>  
                                                   ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


345           assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] =
                                                                             
346              (stap_and_all_bits_irreg == HIGH) ? bypass_reg :
                                                   -1-  
                                                   ==>  
347              (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW;
                                                                                           -2-  
                                                                                           ==>  
                                                                                           ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


324              if (!powergood_rst_trst_b)
                 -1-  
325              begin
326                 bypass_reg <= LOW;
                    ==>
327              end
328              else if (stap_fsm_tlrs)
                      -2-  
329              begin
330                 bypass_reg <= LOW;
                    ==>
331              end
332              else if (stap_fsm_capture_dr & irdecoder_drselect)
                      -3-  
333              begin
334                 bypass_reg <= LOW;
                    ==>
335              end
336              else if (stap_fsm_shift_dr & irdecoder_drselect)
                      -4-               
337              begin
338                 bypass_reg <= ftap_tdi;
                    ==>
339              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   -   -   -   Covered 
0   1   -   -   Covered 
0   0   1   -   Covered 
0   0   0   1   Covered 
0   0   0   0   Covered 


394              if (!powergood_rst_trst_b)
                 -1-  
395              begin
396                 reset_pulse0 <= LOW;
                    ==>
397                 reset_pulse1 <= LOW;
398              end
399              else
400              begin
401                 reset_pulse0 <= HIGH;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


419              if (!powergood_rst_trst_b)
                 -1-  
420              begin
421                 slvidcode_reg <= {{(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1){LOW}}, HIGH};
                    ==>
422              end
423              else if (reset_pulse)
                      -2-  
424              begin
425                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
426              end
427              else if (stap_fsm_tlrs)
                      -3-  
428              begin
429                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
430              end
431              else if (stap_fsm_capture_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
                      -4-  
432              begin
433                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
434              end
435              else if (stap_fsm_shift_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
                      -5-               
436              begin
437                 slvidcode_reg <= {ftap_tdi, slvidcode_reg[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1]};
                    ==>
438              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- -5- Status  
1   -   -   -   -   Covered 
0   1   -   -   -   Covered 
0   0   1   -   -   Covered 
0   0   0   1   -   Covered 
0   0   0   0   1   Covered 
0   0   0   0   0   Covered 


735                 if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
                    -1-  
736                 begin:generate_soft_rst_mux
737                    case (tapc_tdrrsten_reg[1])
                       -2-  
738                    LOW:
739                    begin
740                      prgm_soft_rst_mux = fdfx_powergood;
                         ==>
741                    end
742                    HIGH:
743                    begin
744                      prgm_soft_rst_mux = (!tapc_tdrrsten_reg[1]);
                         ==>
745                    end
746                    default:
747                    begin
748                      prgm_soft_rst_mux = fdfx_powergood;
                         ==>
749                    end
750                    endcase
751                 end
752                 else
753                 begin
754                    prgm_soft_rst_mux = fdfx_powergood;
                       ==>

Branches:

-1- -2-     Status      
1   LOW     Covered     
1   HIGH    Covered     
1   default Not Covered 
0   -       Not Covered 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==>

Branches:

-1-                       -2- -3- -4- Status      
DRREG_STAP_SECURE_RED     1   -   -   Covered     
DRREG_STAP_SECURE_RED     0   -   -   Covered     
DRREG_STAP_SECURE_ORANGE  -   1   -   Not Covered 
DRREG_STAP_SECURE_ORANGE  -   0   -   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   1   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   0   Not Covered 
default                   -   -   -   Not Covered 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==>

Branches:

-1-                       -2- -3- -4- Status      
DRREG_STAP_SECURE_RED     1   -   -   Covered     
DRREG_STAP_SECURE_RED     0   -   -   Covered     
DRREG_STAP_SECURE_ORANGE  -   1   -   Not Covered 
DRREG_STAP_SECURE_ORANGE  -   0   -   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   1   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   0   Not Covered 
default                   -   -   -   Not Covered 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==>

Branches:

-1-                       -2- -3- -4- Status      
DRREG_STAP_SECURE_RED     1   -   -   Not Covered 
DRREG_STAP_SECURE_RED     0   -   -   Not Covered 
DRREG_STAP_SECURE_ORANGE  -   1   -   Covered     
DRREG_STAP_SECURE_ORANGE  -   0   -   Covered     
DRREG_STAP_SECURE_GREEN   -   -   1   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   0   Not Covered 
default                   -   -   -   Not Covered 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==>

Branches:

-1-                       -2- -3- -4- Status      
DRREG_STAP_SECURE_RED     1   -   -   Not Covered 
DRREG_STAP_SECURE_RED     0   -   -   Not Covered 
DRREG_STAP_SECURE_ORANGE  -   1   -   Covered     
DRREG_STAP_SECURE_ORANGE  -   0   -   Covered     
DRREG_STAP_SECURE_GREEN   -   -   1   Not Covered 
DRREG_STAP_SECURE_GREEN   -   -   0   Not Covered 
default                   -   -   -   Not Covered 


768                    case (tapc_tdrrsten_reg[0])
                       -1-  
769                    LOW:
770                    begin
771                      prgm_hard_rst_mux = prgm_soft_rst_mux;
                         ==>
772                    end
773                    HIGH:
774                    begin
775                      // Fix HSD 4903467
776                      //prgm_hard_rst_mux = (ftap_trst_b); 
777                      prgm_hard_rst_mux = ((ftap_trst_b) & (!stap_fsm_tlrs));
                         ==>
778                    end
779                    default:
780                    begin
781                      prgm_hard_rst_mux = prgm_soft_rst_mux;
                         ==>

Branches:

-1-     Status      
LOW     Covered     
HIGH    Covered     
default Not Covered 


804                       if (tapc_itdrrstsel_reg[y] == 1)
                          -1-  
805                          itdr_async_reset[y] = prgm_hard_rst_mux;
                             ==>
806                       else
807                          itdr_async_reset[y] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


804                       if (tapc_itdrrstsel_reg[y] == 1)
                          -1-  
805                          itdr_async_reset[y] = prgm_hard_rst_mux;
                             ==>
806                       else
807                          itdr_async_reset[y] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_drreg 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       22    22        100.00  22                100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            22    22        100.00  22                100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                                                    Attempts Real Successes Failures Incomplete 
check_irdec_only_one_bit_is_high                                        88842    88842          0        0          
chk_stap_data_change_when_update_dr                                     88848    77400          0        5          
genblk16.chk_check_itdr_powergood_reset_option                          85370    1575           0        0          
genblk16.chk_chk_tdr_data_out_when_tdr_not_enabled                      3472     3359           0        0          
genblk16.genblk1[0].chk_check_itdr_softrst_option_enabled_for_this_itdr 85370    297            0        0          
genblk16.genblk1[0].chk_check_itdr_trst_b_option_enabled_for_this_itdr  85370    30             0        0          
genblk16.genblk1[1].chk_check_itdr_softrst_option_enabled_for_this_itdr 85370    297            0        0          
genblk16.genblk1[1].chk_check_itdr_trst_b_option_enabled_for_this_itdr  85370    30             0        0          
genblk17.chk_rtdr_prog_rst_when_rtdr_disabled                           3472     3359           0        0          
genblk17.genblk1[0].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
genblk17.genblk1[1].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
genblk17.genblk1[2].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
unnamed$$_0                                                             16       16             0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                    
 88.37  73.50 100.00  94.77 --      73.56 100.00 STAP_RTL_LIB.stap_drreg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                    
100.00 100.00 --     100.00 --     100.00 100.00 generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)                                    
100.00 100.00 --     100.00 --     100.00 100.00 generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)                                    
100.00 --     --     100.00 --     --     --     generate_rtdr.generate_rtdr_1[23].i_stap_remote_data_reg                                
100.00 --     --     100.00 --     --     --     generate_rtdr.generate_rtdr_1[24].i_stap_remote_data_reg                                
100.00 --     --     100.00 --     --     --     generate_rtdr.generate_rtdr_1[25].i_stap_remote_data_reg                                
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)                         
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)                                 
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)                         
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)                                    
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)                             
100.00 100.00 --     100.00 --     100.00 100.00 generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x) 
100.00 100.00 --     100.00 --     100.00 100.00 generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)                                   



-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg(x)

             Line No.   Total   Covered  Percent
TOTAL                       74       74   100.00
ALWAYS            324        8        8   100.00
ALWAYS            394        5        5   100.00
ALWAYS            419       10       10   100.00
ALWAYS            525        1        1   100.00
ALWAYS            525        1        1   100.00
ALWAYS            525        1        1   100.00
ALWAYS            525        1        1   100.00
ALWAYS            735        4        4   100.00
ALWAYS            768        3        3   100.00
ALWAYS            804        3        3   100.00
ALWAYS            804        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            829        3        3   100.00
ALWAYS            166        8        8   100.00
ALWAYS            166        8        8   100.00
ALWAYS            166        8        8   100.00
INITIAL           244        1        1   100.00

323                        begin
324        1/1                if (!powergood_rst_trst_b)
325                           begin
326        1/1                   bypass_reg <= LOW;
327                           end
328        1/1                else if (stap_fsm_tlrs)
329                           begin
330        1/1                   bypass_reg <= LOW;
331                           end
332        1/1                else if (stap_fsm_capture_dr & irdecoder_drselect)
333                           begin
334        1/1                   bypass_reg <= LOW;
335                           end
336        1/1                else if (stap_fsm_shift_dr & irdecoder_drselect)
337                           begin
338        1/1                   bypass_reg <= ftap_tdi;
339                           end
                        MISSING_ELSE
340                        end
341                     
342                        // *********************************************************************
343                        // stap_drreg_tdo implementation for bits all ones
344                        // *********************************************************************
345                        assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] =
346                           (stap_and_all_bits_irreg == HIGH) ? bypass_reg :
347                           (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW;
348                     
349                        // *********************************************************************
350                        // Dummy assignments to avoid lintra warnings
351                        // *********************************************************************
352                        generate
353                           if (DRREG_STAP_ENABLE_BSCAN == 1)
354                           begin:generate_bscan_regs
355                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_SAMPLE_PRELOAD] = LOW;
356                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_HIGHZ]          = LOW;
357                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST]         = LOW;
358                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_PULSE]   = LOW;
359                              assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_TRAIN]   = LOW;
360                     
361                              if (DRREG_STAP_NUMBER_OF_PRELOAD_REGISTERS > 0)
362                              begin:generate_bscan_regs_1
363                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_PRELOAD] = LOW;
364                              end
365                     
366                              if (DRREG_STAP_NUMBER_OF_CLAMP_REGISTERS > 0)
367                              begin:generate_bscan_regs_2
368                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_CLAMP] = LOW;
369                              end
370                     
371                              if (DRREG_STAP_NUMBER_OF_INTEST_REGISTERS > 0)
372                              begin:generate_bscan_regs_3
373                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_INTEST] = LOW;
374                              end
375                     
376                              if (DRREG_STAP_NUMBER_OF_RUNBIST_REGISTERS > 0)
377                              begin:generate_bscan_regs_4
378                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_RUNBIST] = LOW;
379                              end
380                     
381                              if (DRREG_STAP_NUMBER_OF_EXTEST_TOGGLE_REGISTERS > 0)
382                              begin:generate_bscan_regs_5
383                                 assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_EXTEST_TOGGLE] = LOW;
384                              end
385                           end
386                        endgenerate
387                     
388                        // *********************************************************************
389                        // Reset pulse generation logic. To avoid lintra error which complains about
390                        // loading pin values during reset
391                        // *********************************************************************
392                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
393                        begin
394        1/1                if (!powergood_rst_trst_b)
395                           begin
396        1/1                   reset_pulse0 <= LOW;
397        1/1                   reset_pulse1 <= LOW;
398                           end
399                           else
400                           begin
401        1/1                   reset_pulse0 <= HIGH;
402        1/1                   reset_pulse1 <= reset_pulse0;
403                           end
404                        end
405                     
406                        assign reset_pulse = reset_pulse0 & (~reset_pulse1);
407                     
408                        // *********************************************************************
409                        // Generation of ftap_slvidcode reset value.
410                        // *********************************************************************
411                        assign slvidcode_reset_value = {ftap_slvidcode[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1], HIGH};
412                        assign ftap_slvidcode0_NC    = ftap_slvidcode[0];
413                     
414                        // *********************************************************************
415                        // IDCODE register implementation
416                        // *********************************************************************
417                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
418                        begin
419        1/1                if (!powergood_rst_trst_b)
420                           begin
421        1/1                   slvidcode_reg <= {{(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1){LOW}}, HIGH};
422                           end
423        1/1                else if (reset_pulse)
424                           begin
425        1/1                   slvidcode_reg <= slvidcode_reset_value;
426                           end
427        1/1                else if (stap_fsm_tlrs)
428                           begin
429        1/1                   slvidcode_reg <= slvidcode_reset_value;
430                           end
431        1/1                else if (stap_fsm_capture_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
432                           begin
433        1/1                   slvidcode_reg <= slvidcode_reset_value;
434                           end
435        1/1                else if (stap_fsm_shift_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
436                           begin
437        1/1                   slvidcode_reg <= {ftap_tdi, slvidcode_reg[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1]};
438                           end
                        MISSING_ELSE
439                        end
440                        // ---------------------------------------------------------------------
441                        // stap_drreg_tdo[DRREG_STAP_POSITION_OF_SLVIDCODE] is going to the TDOmux FUB.
442                        // ---------------------------------------------------------------------
443                        assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_SLVIDCODE] = slvidcode_reg[0];
444                     
445                        // *********************************************************************
446                        // sftapnw_ftap_secsel register implementation.
447                        // Module stap_data_reg is instantiated to create register sftapnw_ftap_secsel.
448                        // This register is generated only if tap nework is enabled and
449                        // secondary register is enabled.
450                        // *********************************************************************
451                        generate
452                           if (DRREG_STAP_ENABLE_TAP_NETWORK == 1)
453                           begin:generate_tapnw_sec_sel_tdr
454                              if (DRREG_STAP_ENABLE_TAPC_SEC_SEL == 1)
455                              begin:generate_tapnw_sec_sel_tdr_1
456                                 stap_data_reg #(
457                                                 .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_TAPS),
458                                                 .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_TAPS{LOW}})
459                                                )
460                                 i_stap_data_reg_tapc_sec_sel (
461                                                               .sync_reset              (LOW),
462                                                               .ftap_tck                (ftap_tck),
463                                                               .ftap_tdi                (ftap_tdi),
464                                                               .reset_b                 (fdfx_powergood),
465                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SEC_SEL]),
466                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
467                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
468                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
469                                                               .tdr_data_in             (sftapnw_ftap_secsel),
470                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_SEC_SEL]),
471                                                               .tdr_data_out            (sftapnw_ftap_secsel)
472                                                              );
473                              end
474                              else
475                              begin:generate_tapnw_sec_sel_tdr_1
476                                 assign sftapnw_ftap_secsel[(DRREG_STAP_NUMBER_OF_TAPS - 1):0] = {DRREG_STAP_NUMBER_OF_TAPS{LOW}};
477                              end
478                           end
479                           else
480                           begin:generate_tapnw_sec_sel_tdr
481                              assign sftapnw_ftap_secsel[(DRREG_STAP_NUMBER_OF_TAPS - 1):0] = {DRREG_STAP_NUMBER_OF_TAPS{LOW}};
482                           end
483                        endgenerate
484                     
485                        // *********************************************************************
486                        // tapc_select register implementation.
487                        // Module stap_data_reg is instantiated to create register tapc_select.
488                        // *********************************************************************
489                        generate
490                           if (DRREG_STAP_ENABLE_TAP_NETWORK == 1)
491                           begin:generate_tapc_sel_tdr
492                              stap_data_reg #(
493                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2),
494                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2{LOW}})
495                                             )
496                              i_stap_data_reg_tapc_select (
497                                                           .sync_reset              (LOW),
498                                                           .ftap_tck                (ftap_tck),
499                                                           .ftap_tdi                (ftap_tdi),
500                                                           .reset_b                 (fdfx_powergood),
501                                                           .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_SELECT]),
502                                                           .stap_fsm_capture_dr     (stap_fsm_capture_dr),
503                                                           .stap_fsm_shift_dr       (stap_fsm_shift_dr),
504                                                           .stap_fsm_update_dr      (stap_fsm_update_dr),
505                                                           .tdr_data_in             (tapc_select_int),
506                                                           .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_SELECT]),
507                                                           .tdr_data_out            (tapc_select_int)
508                                                          );
509                           end
510                           else
511                           begin:generate_tapc_sel_tdr
512                              assign tapc_select_int[(DRREG_STAP_NUMBER_OF_TAPS_MULTIPLY_BY_2 - 1):0] = TWO_BIT_ZERO;
513                           end
514                        endgenerate
515                     
516                        // *********************************************************************
517                        assign green_en   = (feature_green_en  | feature_orange_en | feature_red_en);
518                        assign orange_en  = (feature_orange_en | feature_red_en);
519                     
520                        generate
521                           for (genvar m = 0; m < DRREG_STAP_NUMBER_OF_TAPS; m = m + 1)
522                           begin:generate_taps_security
523                              always_comb
524                              begin
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        excluded                       if (feature_red_en)
529                                       begin
530        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        excluded                       if (orange_en)
540                                       begin
541        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        excluded                       if (green_en)
551                                       begin
552        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        excluded                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 1
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        excluded                       if (feature_red_en)
529                                       begin
530        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        excluded                       if (orange_en)
540                                       begin
541        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        excluded                       if (green_en)
551                                       begin
552        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        excluded                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 2
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        excluded                       if (feature_red_en)
529                                       begin
530        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        excluded                       if (orange_en)
540                                       begin
541        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        excluded                       if (green_en)
551                                       begin
552        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        excluded                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
***repeat 3
525        1/1                      case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
526                                    DRREG_STAP_SECURE_RED:
527                                    begin
528        excluded                       if (feature_red_en)
529                                       begin
530        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
531                                       end
532                                       else
533                                       begin
534        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
535                                       end
536                                    end
537                                    DRREG_STAP_SECURE_ORANGE:
538                                    begin
539        excluded                       if (orange_en)
540                                       begin
541        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
542                                       end
543                                       else
544                                       begin
545        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
546                                       end
547                                    end
548                                    DRREG_STAP_SECURE_GREEN:
549                                    begin
550        excluded                       if (green_en)
551                                       begin
552        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
553                                       end
554                                       else
555                                       begin
556        excluded                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
557                                       end
558                                    end
559                                    default:
560                                    begin
561        excluded                       tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
562                                    end
563                                 endcase
564                              end
565                           end
566                        endgenerate
567                     
568                        // *********************************************************************
569                     
570                        // *********************************************************************
571                        // tapc_wtap_sel register implementation.
572                        // Module stap_data_reg is instantiated to create register tapc_wtap_sel.
573                        // This register is generated only if wtap nework is enabled.
574                        // *********************************************************************
575                        generate
576                           if (DRREG_STAP_ENABLE_WTAP_NETWORK == 1)
577                           begin:generate_wtap_nw_tdr
578                              stap_data_reg #(
579                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_NUMBER_OF_WTAPS),
580                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_NUMBER_OF_WTAPS{DRREG_STAP_WTAPCTRL_RESET_VALUE}})
581                                             )
582                              i_stap_data_reg_tapc_wtap_sel (
583                                                             .sync_reset              (LOW),
584                                                             .ftap_tck                (ftap_tck),
585                                                             .ftap_tdi                (ftap_tdi),
586                                                             .reset_b                 (fdfx_powergood),
587                                                             .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_WTAPNW_SELECTWIR]),
588                                                             .stap_fsm_capture_dr     (stap_fsm_capture_dr),
589                                                             .stap_fsm_shift_dr       (stap_fsm_shift_dr),
590                                                             .stap_fsm_update_dr      (stap_fsm_update_dr),
591                                                             .tdr_data_in             (tapc_wtap_sel),
592                                                             .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_WTAPNW_SELECTWIR]),
593                                                             .tdr_data_out            (tapc_wtap_sel)
594                                                            );
595                           end
596                           else
597                           begin:generate_wtap_nw_tdr
598                              assign tapc_wtap_sel[0] = LOW;
599                           end
600                        endgenerate
601                     
602                        // *********************************************************************
603                        // tapc_remove register implementation.
604                        // Module stap_data_reg is instantiated to create register tapc_remove.
605                        // *********************************************************************
606                        generate
607                           if (DRREG_STAP_ENABLE_TAPC_REMOVE == 1)
608                           begin:generate_tapc_remove_tdr
609                              stap_data_reg #(
610                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           (DRREG_STAP_WIDTH_OF_TAPC_REMOVE),
611                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({DRREG_STAP_WIDTH_OF_TAPC_REMOVE{LOW}})
612                                             )
613                              i_stap_data_reg_tapc_remove (
614                                                           .sync_reset              (LOW),
615                                                           .ftap_tck                (ftap_tck),
616                                                           .ftap_tdi                (ftap_tdi),
617                                                           .reset_b                 (fdfx_powergood),
618                                                           .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_REMOVE]),
619                                                           .stap_fsm_capture_dr     (stap_fsm_capture_dr),
620                                                           .stap_fsm_shift_dr       (stap_fsm_shift_dr),
621                                                           .stap_fsm_update_dr      (stap_fsm_update_dr),
622                                                           .tdr_data_in             (tapc_remove),
623                                                           .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_REMOVE]),
624                                                           .tdr_data_out            (tapc_remove)
625                                                          );
626                           end
627                           else
628                           begin:generate_tapc_remove_tdr
629                              assign tapc_remove = {DRREG_STAP_WIDTH_OF_TAPC_REMOVE{LOW}};
630                           end
631                        endgenerate
632                     //*************************************************************************
633                     // Programmable Reset Implementation for iTDRs and RTDRs.
634                     //*************************************************************************
635                        // *********************************************************************
636                        // TAPC_TDRRSTEN 'h15 register implementation.
637                        // Module stap_data_reg is instantiated to create register TAPC_TDRRSTEN.
638                        // *********************************************************************
639                        generate
640                           if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
641                           begin:generate_tapc_tdrrsten_tdr
642                              stap_data_reg #(
643                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_SIZE_OF_TDRRSTEN_REGISTER),
644                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_SIZE_OF_TDRRSTEN_REGISTER{LOW}})
645                                             )
646                              i_stap_data_reg_tapc_tdrrsten (
647                                                             .sync_reset              (LOW),
648                                                             .ftap_tck                (ftap_tck),
649                                                             .ftap_tdi                (ftap_tdi),
650                                                             .reset_b                 (fdfx_powergood),
651                                                             .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_TDRRSTEN]),
652                                                             .stap_fsm_capture_dr     (stap_fsm_capture_dr),
653                                                             .stap_fsm_shift_dr       (stap_fsm_shift_dr),
654                                                             .stap_fsm_update_dr      (stap_fsm_update_dr),
655                                                             .tdr_data_in             (tapc_tdrrsten_reg),
656                                                             .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_TDRRSTEN]),
657                                                             .tdr_data_out            (tapc_tdrrsten_reg)
658                                                            );
659                           end
660                           else
661                           begin:generate_tapc_tdrrsten_tdr
662                              assign tapc_tdrrsten_reg[(DRREG_SIZE_OF_TDRRSTEN_REGISTER - 1):0] = TWO_BIT_ZERO;
663                           end
664                        endgenerate
665                     
666                        // *********************************************************************
667                        // TAPC_ITDRRSTSEL 'h16 register implementation.
668                        // Module stap_data_reg is instantiated to create register TAPC_ITDRRSTSEL.
669                        // *********************************************************************
670                        generate
671                           if (DRREG_STAP_ENABLE_ITDR_PROG_RST == 1)
672                           begin:generate_tapc_itdrrstsel_tdr
673                              stap_data_reg #(
674                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ),
675                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{LOW}})
676                                             )
677                              i_stap_data_reg_tapc_itdrrstsel (
678                                                               .sync_reset              (LOW),
679                                                               .ftap_tck                (ftap_tck),
680                                                               .ftap_tdi                (ftap_tdi),
681                                                               .reset_b                 (fdfx_powergood),
682                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_ITDRRSTSEL]),
683                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
684                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
685                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
686                                                               .tdr_data_in             (tapc_itdrrstsel_reg),
687                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_ITDRRSTSEL]),
688                                                               .tdr_data_out            (tapc_itdrrstsel_reg)
689                                                              );
690                           end
691                           else
692                           begin:generate_tapc_itdrrstsel_tdr
693                              assign tapc_itdrrstsel_reg = {DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{LOW}};
694                           end
695                        endgenerate
696                     
697                        // *********************************************************************
698                        // TAPC_RTDRRSTSEL 'h17 register implementation.
699                        // Module stap_data_reg is instantiated to create register TAPC_RTDRRSTSEL.
700                        // *********************************************************************
701                        generate
702                           if (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1)
703                           begin:generate_tapc_rtdrrstsel_tdr
704                              stap_data_reg #(
705                                              .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER     (DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ),
706                                              .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ({DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ{LOW}})
707                                             )
708                              i_stap_data_reg_tapc_rtdrrstsel (
709                                                               .sync_reset              (LOW),
710                                                               .ftap_tck                (ftap_tck),
711                                                               .ftap_tdi                (ftap_tdi),
712                                                               .reset_b                 (fdfx_powergood),
713                                                               .stap_irdecoder_drselect (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_TAPC_RTDRRSTSEL]),
714                                                               .stap_fsm_capture_dr     (stap_fsm_capture_dr),
715                                                               .stap_fsm_shift_dr       (stap_fsm_shift_dr),
716                                                               .stap_fsm_update_dr      (stap_fsm_update_dr),
717                                                               .tdr_data_in             (tapc_rtdrrstsel_reg),
718                                                               .data_reg_tdo            (stap_drreg_tdo[DRREG_STAP_POSITION_OF_TAPC_RTDRRSTSEL]),
719                                                               .tdr_data_out            (tapc_rtdrrstsel_reg)
720                                                              );
721                           end
722                           else
723                           begin:generate_tapc_rtdrrstsel_tdr
724                              assign tapc_rtdrrstsel_reg = {DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ{LOW}};
725                           end
726                        endgenerate
727                     
728                        // *********************************************************************
729                        // Logic for selecting soft programmable reset option for ITDRs/RTDRs 
730                        // based on the regiseter TAPC_TDRRSTEN.
731                        // *********************************************************************
732                        generate
733                           always_comb
734                           begin
735        1/1                   if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
736                              begin:generate_soft_rst_mux
737        1/1                      case (tapc_tdrrsten_reg[1])
738                                 LOW:
739                                 begin
740        1/1                        prgm_soft_rst_mux = fdfx_powergood;
741                                 end
742                                 HIGH:
743                                 begin
744        1/1                        prgm_soft_rst_mux = (!tapc_tdrrsten_reg[1]);
745                                 end
746                                 default:
747                                 begin
748        excluded                   prgm_soft_rst_mux = fdfx_powergood;
749                                 end
750                                 endcase
751                              end
752                              else
753                              begin
754        excluded                 prgm_soft_rst_mux = fdfx_powergood;
755                              end
756                           end
757                        endgenerate
758                     
759                        // *********************************************************************
760                        // Logic for selecting ftap_trst_b programmable reset option for ITDRs/RTDRs 
761                        // based on the regiseter TAPC_TDRRSTEN.
762                        // *********************************************************************
763                        generate
764                           if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
765                           begin:generate_hard_rst_mux
766                              always_comb
767                              begin
768        1/1                      case (tapc_tdrrsten_reg[0])
769                                 LOW:
770                                 begin
771        1/1                        prgm_hard_rst_mux = prgm_soft_rst_mux;
772                                 end
773                                 HIGH:
774                                 begin
775                                   // Fix HSD 4903467
776                                   //prgm_hard_rst_mux = (ftap_trst_b); 
777        1/1                        prgm_hard_rst_mux = ((ftap_trst_b) & (!stap_fsm_tlrs));
778                                 end
779                                 default:
780                                 begin
781        excluded                   prgm_hard_rst_mux = prgm_soft_rst_mux;
782                                 end
783                                 endcase
784                              end
785                           end
786                           else
787                           begin:generate_hard_rst_mux
788                              assign prgm_hard_rst_mux = prgm_soft_rst_mux;
789                           end
790                        endgenerate
791                     
792                        // *********************************************************************
793                        // Logic to check which ITDR bit in reg TAPC_ITDRRSTSEL is set to one 
794                        // for programmable reset option and pass the reset to respective ITDR
795                        // whose bit in TAPC_ITDRRSTSEL is set to one.
796                        // *********************************************************************
797                        generate
798                           if (DRREG_STAP_ENABLE_ITDR_PROG_RST == 1)
799                           begin:generate_prog_rst_itdr
800                              for (genvar y = 0; y < DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ; y = y + 1)
801                              begin:generate_async_rst_itdr_1
802                                 always_comb
803                                 begin
804        1/1                         if (tapc_itdrrstsel_reg[y] == 1)
805        1/1                            itdr_async_reset[y] = prgm_hard_rst_mux;
806                                    else
807        1/1                            itdr_async_reset[y] = fdfx_powergood;
***repeat 4
804        1/1                         if (tapc_itdrrstsel_reg[y] == 1)
805        1/1                            itdr_async_reset[y] = prgm_hard_rst_mux;
806                                    else
807        1/1                            itdr_async_reset[y] = fdfx_powergood;
808                                 end
809                              end
810                           end
811                           else
812                           begin:generate_prog_rst_itdr
813                              assign itdr_async_reset = {DRREG_STAP_NUMBER_OF_TEST_DATA_REGISTERS_NZ{fdfx_powergood}};
814                           end
815                        endgenerate
816                     
817                        // *********************************************************************
818                        // Logic to check which RTDR bit in reg TAPC_RTDRRSTSEL is set to one 
819                        // for programmable reset option and pass the reset to respective RTDR
820                        // whose bit in TAPC_RTDRRSTSEL is set to one.
821                        // *********************************************************************
822                        generate
823                           if (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1)
824                           begin:generate_prog_rst_rtdr
825                              for (genvar z = 0; z < DRREG_STAP_NUMBER_OF_REMOTE_TEST_DATA_REGISTERS_NZ; z = z + 1)
826                              begin:generate_sync_rst_rtdr_1
827                                 always_comb
828                                 begin
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;
***repeat 5
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;
***repeat 6
829        1/1                         if (tapc_rtdrrstsel_reg[z] == 1)
830        1/1                            rtdr_sync_reset[z] = prgm_hard_rst_mux;
831                                    else
832        1/1                            rtdr_sync_reset[z] = fdfx_powergood;

  FILE: /nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/include/assertions/stap_drreg_include.sv
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
***repeat 7
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
***repeat 8
166        1/1                            if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
167                                       begin
168                                          chk_prog_rst_pwrgud:
169        1/1                               assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
170                                          else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                                       end
                        MISSING_ELSE
172                     
173                                       // =============================================================
174                                       // If the bits of 'h15 are 2'b01 or 2'b11 and the respective bit
175                                       // in the register 'h17 is high then that particular bit of
176                                       // tap_rtdr_prog_rst_b should follow ftap_trst_b.
177                                       // =============================================================
178        1/1                            if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
179                                            (tapc_rtdrrstsel_reg[x] === HIGH))
180                                       begin
181                                          // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                                          chk_prog_rtdr_rst_trst_b:
183        1/1                               assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
184                                          else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                                       end
                        MISSING_ELSE
186                     
187                                       // =============================================================
188                                       // If the bits of 'h15 are 2'b10 the respective bit
189                                       // in the register 'h17 is high then that particular bit of
190                                       // tap_rtdr_prog_rst_b should be Zero.
191                                       // =============================================================
192        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
193                                       begin
194                                          chk_prog_rtdr_rst_soft_when_17_is_high:
195        1/1                               assert property (tap_rtdr_prog_rst_b[x] === LOW)
196                                          else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                                       end
                        MISSING_ELSE
198                     
199        1/1                            if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
200                                       begin
201                                          chk_prog_rtdr_rst_soft_when_17_is_low:
202        1/1                               assert property (tap_rtdr_prog_rst_b[x] === HIGH)
203                                          else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                                       end
                        MISSING_ELSE
205                     
206                                    end
207                                 end
208                              end
209                              else
210                              begin
211                                 always @(posedge ftap_tck)
212                                 begin
213                                    if (fdfx_powergood === HIGH)
214                                    begin
215                                       chk_rtdr_prog_rst_when_rtdr_disabled:
216                                       assert property (tap_rtdr_prog_rst_b[0] === HIGH)
217                                       else $error("The tap_rtdr_prog_rst_b is not HIGH when the RTDRs are disabled");
218                                    end
219                                 end
220                              end
221                           endgenerate
222                     
223                            // ====================================================================
224                            // Check at any given point of time only one bit of stap_irdecoder_drselect
225                            // should be high
226                            // ====================================================================
227                            check_irdec_only_one_bit_is_high:assert property ( @(posedge ftap_tck) $onehot0(stap_irdecoder_drselect) ) 
228                            else $error("Only one bit of stap_irdecoder_drselect is not one at a time"); 
229                     
230                        `endif
231                     `endif
232                     
233                     
234                     //-------------------------------------------------------------------------------------------
235                     `ifndef INTEL_SVA_OFF
236                        `ifdef DFX_PARAMETER_CHECKER
237                           `ifndef DFX_FPV_ENABLE
238                               initial
239                               begin
240                                  // ====================================================================
241                                  // To check the width of stap_irdecoder_drselect is equal to
242                                  // DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS
243                                  // ====================================================================
244                                  assert ($size(stap_irdecoder_drselect) === DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS)
245                                  else $fatal ("The width of the stap_irdecoder_drselect is not equal to DRREG_STAP_NUMBER_OF_TOTAL_REGISTERS");
246        1/1                       $display ("stap_irdecoder_drselect_width     = %0d ", $size(stap_irdecoder_drselect));

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_drreg(x)

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       311
 EXPRESSION 
 Number  Term
      1  (stap_and_all_bits_irreg == HIGH) ? stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] : stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES])

-1- Status
 0  Covered
 1  Covered

 LINE       345
 EXPRESSION ((stap_and_all_bits_irreg == HIGH) ? bypass_reg : ((stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW))
             ----------------1----------------

-1- Status
 0  Covered
 1  Covered

 LINE       345
 SUB-EXPRESSION ((stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW)
                 ------------------------------------1------------------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg(x)
                Total Covered Percent 
Totals          50    50      100.00  
Total Bits      702   702     100.00  
Total Bits 0->1 351   351     100.00  
Total Bits 1->0 351   351     100.00  

                              
Ports          33  33  100.00 
Port Bits      474 474 100.00 
Port Bits 0->1 237 237 100.00 
Port Bits 1->0 237 237 100.00 

                                
Signals          17  17  100.00 
Signal Bits      228 228 100.00 
Signal Bits 0->1 114 114 100.00 
Signal Bits 1->0 114 114 100.00 

Port Details
                               Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_fsm_tlrs                  Yes      Yes         Yes         INPUT     
ftap_tdi                       Yes      Yes         Yes         INPUT     
ftap_tck                       Yes      Yes         Yes         INPUT     
ftap_trst_b                    Yes      Yes         Yes         INPUT     
fdfx_powergood                 Yes      Yes         Yes         INPUT     
powergood_rst_trst_b           Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr            Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr              Yes      Yes         Yes         INPUT     
stap_fsm_update_dr             Yes      Yes         Yes         INPUT     
stap_selectwir                 Yes      Yes         Yes         INPUT     
ftap_slvidcode[31:0]           Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[2]     Excluded Excluded    Excluded    INPUT     
stap_irdecoder_drselect[8:3]   Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[9]     Excluded Excluded    Excluded    INPUT     
stap_irdecoder_drselect[25:10] Yes      Yes         Yes         INPUT     
tdr_data_in[63:0]              Yes      Yes         Yes         INPUT     
tdr_data_out[63:0]             Yes      Yes         Yes         OUTPUT    
sftapnw_ftap_secsel[0]         Excluded Excluded    Excluded    OUTPUT    
sftapnw_ftap_secsel[1]         Yes      Yes         Yes         OUTPUT    
sftapnw_ftap_secsel[2]         Excluded Excluded    Excluded    OUTPUT    
sftapnw_ftap_secsel[3]         Yes      Yes         Yes         OUTPUT    
tapc_select[7:0]               Yes      Yes         Yes         OUTPUT    
feature_green_en               Yes      Yes         Yes         INPUT     
feature_orange_en              Excluded Excluded    Excluded    INPUT     
feature_red_en                 Yes      Yes         Yes         INPUT     
tapc_wtap_sel[2:0]             Yes      Yes         Yes         OUTPUT    
tapc_remove                    Excluded Excluded    Excluded    OUTPUT    
stap_drreg_tdo[25:0]           Excluded Excluded    Excluded    OUTPUT    
swcompctrl_tdo                 Yes      Yes         Yes         INPUT     
swcompstat_tdo                 Yes      Yes         Yes         INPUT     
stap_and_all_bits_irreg        Yes      Yes         Yes         INPUT     
rtdr_tap_tdo[2:0]              Yes      Yes         Yes         INPUT     
tap_rtdr_tdi[2:0]              Yes      Yes         Yes         OUTPUT    
tap_rtdr_capture[2:0]          Yes      Yes         Yes         OUTPUT    
tap_rtdr_shift[2:0]            Yes      Yes         Yes         OUTPUT    
tap_rtdr_update[2:0]           Yes      Yes         Yes         OUTPUT    
tap_rtdr_irdec[2:0]            Yes      Yes         Yes         OUTPUT    
tap_rtdr_selectir              Yes      Yes         Yes         OUTPUT    
tap_rtdr_powergood             Yes      Yes         Yes         OUTPUT    
tap_rtdr_rti                   Yes      Yes         Yes         OUTPUT    
tap_rtdr_prog_rst_b[2:0]       Yes      Yes         Yes         OUTPUT    
stap_fsm_rti                   Yes      Yes         Yes         INPUT     

Signal Details
                               Toggle   Toggle 1->0 Toggle 0->1 
slvidcode_reset_value[0]       Excluded Excluded    Excluded    
slvidcode_reset_value[31:1]    Yes      Yes         Yes         
reset_pulse                    Yes      Yes         Yes         
bypass_reg                     Yes      Yes         Yes         
slvidcode_reg[31:0]            Yes      Yes         Yes         
reset_pulse0                   Yes      Yes         Yes         
reset_pulse1                   Yes      Yes         Yes         
irdecoder_drselect             Yes      Yes         Yes         
stap_fsm_rti_NC                Excluded Excluded    Excluded    
stap_irdecoder_drsel_NC[1:0]   Yes      Yes         Yes         
stap_irdecoder_drsel_NC[2]     Excluded Excluded    Excluded    
stap_irdecoder_drsel_NC[8:3]   Yes      Yes         Yes         
stap_irdecoder_drsel_NC[9]     Excluded Excluded    Excluded    
stap_irdecoder_drsel_NC[25:10] Yes      Yes         Yes         
ftap_slvidcode0_NC             Yes      Yes         Yes         
stap_selectwir_NC              Excluded Excluded    Excluded    
rtdr_tap_tdo_NC                Excluded Excluded    Excluded    
green_en                       Excluded Excluded    Excluded    
orange_en                      Yes      Yes         Yes         
tapc_select_int[7:0]           Yes      Yes         Yes         
tapc_tdrrsten_reg[1:0]         Excluded Excluded    Excluded    
tapc_itdrrstsel_reg[1:0]       Yes      Yes         Yes         
tapc_rtdrrstsel_reg[2:0]       Yes      Yes         Yes         
prgm_soft_rst_mux              Yes      Yes         Yes         
prgm_hard_rst_mux              Yes      Yes         Yes         
itdr_async_reset[1:0]          Yes      Yes         Yes         
rtdr_sync_reset[2:0]           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg(x)
         Line No. Total Covered Percent 
Branches          64    64      100.00  
TERNARY  311      2     2       100.00  
TERNARY  345      3     3       100.00  
IF       324      5     5       100.00  
IF       394      2     2       100.00  
IF       419      6     6       100.00  
IF       735      2     2       100.00  
CASE     525      2     2       100.00  
CASE     525      2     2       100.00  
CASE     525      2     2       100.00  
CASE     525      2     2       100.00  
CASE     768      2     2       100.00  
IF       804      2     2       100.00  
IF       804      2     2       100.00  
IF       829      2     2       100.00  
IF       829      2     2       100.00  
IF       829      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  
IF       166      2     2       100.00  
IF       178      2     2       100.00  
IF       192      2     2       100.00  
IF       199      2     2       100.00  


311           assign irdecoder_drselect =
                                         
312              (stap_and_all_bits_irreg == HIGH) ? stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES]  :
                                                   -1-  
                                                   ==>  
                                                   ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


345           assign stap_drreg_tdo[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] =
                                                                             
346              (stap_and_all_bits_irreg == HIGH) ? bypass_reg :
                                                   -1-  
                                                   ==>  
347              (stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_BYPASS_ALL_ONES] == HIGH) ? bypass_reg : LOW;
                                                                                           -2-  
                                                                                           ==>  
                                                                                           ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


324              if (!powergood_rst_trst_b)
                 -1-  
325              begin
326                 bypass_reg <= LOW;
                    ==>
327              end
328              else if (stap_fsm_tlrs)
                      -2-  
329              begin
330                 bypass_reg <= LOW;
                    ==>
331              end
332              else if (stap_fsm_capture_dr & irdecoder_drselect)
                      -3-  
333              begin
334                 bypass_reg <= LOW;
                    ==>
335              end
336              else if (stap_fsm_shift_dr & irdecoder_drselect)
                      -4-               
337              begin
338                 bypass_reg <= ftap_tdi;
                    ==>
339              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   -   -   -   Covered 
0   1   -   -   Covered 
0   0   1   -   Covered 
0   0   0   1   Covered 
0   0   0   0   Covered 


394              if (!powergood_rst_trst_b)
                 -1-  
395              begin
396                 reset_pulse0 <= LOW;
                    ==>
397                 reset_pulse1 <= LOW;
398              end
399              else
400              begin
401                 reset_pulse0 <= HIGH;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


419              if (!powergood_rst_trst_b)
                 -1-  
420              begin
421                 slvidcode_reg <= {{(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1){LOW}}, HIGH};
                    ==>
422              end
423              else if (reset_pulse)
                      -2-  
424              begin
425                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
426              end
427              else if (stap_fsm_tlrs)
                      -3-  
428              begin
429                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
430              end
431              else if (stap_fsm_capture_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
                      -4-  
432              begin
433                 slvidcode_reg <= slvidcode_reset_value;
                    ==>
434              end
435              else if (stap_fsm_shift_dr & stap_irdecoder_drselect[DRREG_STAP_POSITION_OF_SLVIDCODE])
                      -5-               
436              begin
437                 slvidcode_reg <= {ftap_tdi, slvidcode_reg[(DRREG_STAP_WIDTH_OF_SLVIDCODE - 1):1]};
                    ==>
438              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- -5- Status  
1   -   -   -   -   Covered 
0   1   -   -   -   Covered 
0   0   1   -   -   Covered 
0   0   0   1   -   Covered 
0   0   0   0   1   Covered 
0   0   0   0   0   Covered 


735                 if ((DRREG_STAP_ENABLE_ITDR_PROG_RST == 1) || (DRREG_STAP_ENABLE_RTDR_PROG_RST == 1))
                    -1-  
736                 begin:generate_soft_rst_mux
737                    case (tapc_tdrrsten_reg[1])
                       -2-  
738                    LOW:
739                    begin
740                      prgm_soft_rst_mux = fdfx_powergood;
                         ==>
741                    end
742                    HIGH:
743                    begin
744                      prgm_soft_rst_mux = (!tapc_tdrrsten_reg[1]);
                         ==>
745                    end
746                    default:
747                    begin
748                      prgm_soft_rst_mux = fdfx_powergood;
                         ==> (Excluded)
749                    end
750                    endcase
751                 end
752                 else
753                 begin
754                    prgm_soft_rst_mux = fdfx_powergood;
                       ==> (Excluded)

Branches:

-1- -2-     Status   
1   LOW     Covered  
1   HIGH    Covered  
1   default Excluded 
0   -       Excluded 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==> (Excluded)

Branches:

-1-                       -2- -3- -4- Status   
DRREG_STAP_SECURE_RED     1   -   -   Covered  
DRREG_STAP_SECURE_RED     0   -   -   Covered  
DRREG_STAP_SECURE_ORANGE  -   1   -   Excluded 
DRREG_STAP_SECURE_ORANGE  -   0   -   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   1   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   0   Excluded 
default                   -   -   -   Excluded 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==> (Excluded)

Branches:

-1-                       -2- -3- -4- Status   
DRREG_STAP_SECURE_RED     1   -   -   Covered  
DRREG_STAP_SECURE_RED     0   -   -   Covered  
DRREG_STAP_SECURE_ORANGE  -   1   -   Excluded 
DRREG_STAP_SECURE_ORANGE  -   0   -   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   1   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   0   Excluded 
default                   -   -   -   Excluded 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==> (Excluded)

Branches:

-1-                       -2- -3- -4- Status   
DRREG_STAP_SECURE_RED     1   -   -   Excluded 
DRREG_STAP_SECURE_RED     0   -   -   Excluded 
DRREG_STAP_SECURE_ORANGE  -   1   -   Covered  
DRREG_STAP_SECURE_ORANGE  -   0   -   Covered  
DRREG_STAP_SECURE_GREEN   -   -   1   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   0   Excluded 
default                   -   -   -   Excluded 


525                    case (DRREG_STAP_DFX_SECURE_POLICY_SELECTREG[((m * TWO) + 1):(m * TWO)])
                       -1-  
526                       DRREG_STAP_SECURE_RED:
527                       begin
528                          if (feature_red_en)
                             -2-  
529                          begin
530                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
531                          end
532                          else
533                          begin
534                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
535                          end
536                       end
537                       DRREG_STAP_SECURE_ORANGE:
538                       begin
539                          if (orange_en)
                             -3-  
540                          begin
541                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==>
542                          end
543                          else
544                          begin
545                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==>
546                          end
547                       end
548                       DRREG_STAP_SECURE_GREEN:
549                       begin
550                          if (green_en)
                             -4-  
551                          begin
552                             tapc_select[((TWO * m) + 1):(TWO * m)] = tapc_select_int[((TWO * m) + 1):(TWO * m)];
                                ==> (Excluded)
553                          end
554                          else
555                          begin
556                             tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                                ==> (Excluded)
557                          end
558                       end
559                       default:
560                       begin
561                          tapc_select[((TWO * m) + 1):(TWO * m)] = TWO_BIT_ZERO;
                             ==> (Excluded)

Branches:

-1-                       -2- -3- -4- Status   
DRREG_STAP_SECURE_RED     1   -   -   Excluded 
DRREG_STAP_SECURE_RED     0   -   -   Excluded 
DRREG_STAP_SECURE_ORANGE  -   1   -   Covered  
DRREG_STAP_SECURE_ORANGE  -   0   -   Covered  
DRREG_STAP_SECURE_GREEN   -   -   1   Excluded 
DRREG_STAP_SECURE_GREEN   -   -   0   Excluded 
default                   -   -   -   Excluded 


768                    case (tapc_tdrrsten_reg[0])
                       -1-  
769                    LOW:
770                    begin
771                      prgm_hard_rst_mux = prgm_soft_rst_mux;
                         ==>
772                    end
773                    HIGH:
774                    begin
775                      // Fix HSD 4903467
776                      //prgm_hard_rst_mux = (ftap_trst_b); 
777                      prgm_hard_rst_mux = ((ftap_trst_b) & (!stap_fsm_tlrs));
                         ==>
778                    end
779                    default:
780                    begin
781                      prgm_hard_rst_mux = prgm_soft_rst_mux;
                         ==> (Excluded)

Branches:

-1-     Status   
LOW     Covered  
HIGH    Covered  
default Excluded 


804                       if (tapc_itdrrstsel_reg[y] == 1)
                          -1-  
805                          itdr_async_reset[y] = prgm_hard_rst_mux;
                             ==>
806                       else
807                          itdr_async_reset[y] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


804                       if (tapc_itdrrstsel_reg[y] == 1)
                          -1-  
805                          itdr_async_reset[y] = prgm_hard_rst_mux;
                             ==>
806                       else
807                          itdr_async_reset[y] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


829                       if (tapc_rtdrrstsel_reg[z] == 1)
                          -1-  
830                          rtdr_sync_reset[z] = prgm_hard_rst_mux;
                             ==>
831                       else
832                          rtdr_sync_reset[z] = fdfx_powergood;
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


166                          if ((tapc_tdrrsten_reg === 2'b00) && (fdfx_powergood === LOW))
                             -1-  
167                          begin
168                             chk_prog_rst_pwrgud:
169                             assert property (tap_rtdr_prog_rst_b[x] === fdfx_powergood)
                                ==>
170                             else $error("There is no reset for RTDR on fdfx_powergood when the programmable reset option is powergood");
171                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


178                          if (((tapc_tdrrsten_reg === 2'b01) || (tapc_tdrrsten_reg === 2'b11)) &&
                             -1-  
179                               (tapc_rtdrrstsel_reg[x] === HIGH))
180                          begin
181                             // If any of bits of 'h17 are high and '15 is programmed to trst_b ..
182                             chk_prog_rtdr_rst_trst_b:
183                             assert property (tap_rtdr_prog_rst_b[x] === (ftap_trst_b & !(stap_fsm_tlrs === HIGH)))
                                ==>
184                             else $error("There is no reset for RTDR on ftap_trst_b when the programmable reset option is ftap_trst_b");
185                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


192                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === HIGH))
                             -1-  
193                          begin
194                             chk_prog_rtdr_rst_soft_when_17_is_high:
195                             assert property (tap_rtdr_prog_rst_b[x] === LOW)
                                ==>
196                             else $error("There is no reset for RTDR on soft reset when the programmable reset option is enabled for soft reset");
197                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


199                          if ((tapc_tdrrsten_reg === 2'b10) && (tapc_rtdrrstsel_reg[x] === LOW))
                             -1-  
200                          begin
201                             chk_prog_rtdr_rst_soft_when_17_is_low:
202                             assert property (tap_rtdr_prog_rst_b[x] === HIGH)
                                ==>
203                             else $error("There is reset for RTDR on soft reset when the programmable reset option is disable for soft reset");
204                          end
                             MISSING_ELSE
                             ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       22    22        100.00  22                100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            22    22        100.00  22                100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                                                    Attempts Real Successes Failures Incomplete 
check_irdec_only_one_bit_is_high                                        88842    88842          0        0          
chk_stap_data_change_when_update_dr                                     88848    77400          0        5          
genblk16.chk_check_itdr_powergood_reset_option                          85370    1575           0        0          
genblk16.chk_chk_tdr_data_out_when_tdr_not_enabled                      3472     3359           0        0          
genblk16.genblk1[0].chk_check_itdr_softrst_option_enabled_for_this_itdr 85370    297            0        0          
genblk16.genblk1[0].chk_check_itdr_trst_b_option_enabled_for_this_itdr  85370    30             0        0          
genblk16.genblk1[1].chk_check_itdr_softrst_option_enabled_for_this_itdr 85370    297            0        0          
genblk16.genblk1[1].chk_check_itdr_trst_b_option_enabled_for_this_itdr  85370    30             0        0          
genblk17.chk_rtdr_prog_rst_when_rtdr_disabled                           3472     3359           0        0          
genblk17.genblk1[0].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[0].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
genblk17.genblk1[1].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[1].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
genblk17.genblk1[2].chk_prog_rst_pwrgud                                 85370    1575           0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_soft_when_17_is_high              85370    34             0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_soft_when_17_is_low               85370    4232           0        0          
genblk17.genblk1[2].chk_prog_rtdr_rst_trst_b                            85370    78             0        0          
unnamed$$_0                                                             16       16             0        0          


===============================================================================
Module : STAP_RTL_LIB.stap_data_reg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 88.96  85.71 --      92.34 --      77.78 100.00 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_data_reg.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                                                   
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x) 
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)                                    
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)                                   
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)                                 
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)                             
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)                         
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)                         
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)                                    
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)                                    



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=4,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=8,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=3,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=2,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=3,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=32,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ) 
Line Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg
----------------
SCORE  LINE   
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg
----------------
SCORE  LINE   
100.00 100.00 


             Line No.   Total   Covered  Percent
TOTAL                       14       12    85.71
ALWAYS            103        8        7    87.50
ALWAYS            156        6        5    83.33

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        0/1     ==>                 shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        0/1     ==>           tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=1,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Line Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove
----------------
SCORE  LINE   
100.00 100.00 


             Line No.   Total   Covered  Percent
TOTAL                       14       12    85.71
ALWAYS            125        8        7    87.50
ALWAYS            156        6        5    83.33

124                              begin
125        1/1                      if (!reset_b)
126                                 begin
127        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129        1/1                      else if (sync_reset)
130                                 begin
131        0/1     ==>                 shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135        1/1                         shift_register <= tdr_data_in;
136                                 end
137        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139        1/1                         shift_register <= ftap_tdi;
140                                 end
                        MISSING_ELSE
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        0/1     ==>           tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=8,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    11      91.67   
Total Bits      66    64      96.97   
Total Bits 0->1 33    32      96.97   
Total Bits 1->0 33    32      96.97   

                            
Ports          11 10 90.91  
Port Bits      50 48 96.00  
Port Bits 0->1 25 24 96.00  
Port Bits 1->0 25 24 96.00  

                              
Signals          1  1  100.00 
Signal Bits      16 16 100.00 
Signal Bits 0->1 8  8  100.00 
Signal Bits 1->0 8  8  100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in[7:0]        Yes    Yes         Yes         INPUT     
data_reg_tdo            Yes    Yes         Yes         OUTPUT    
tdr_data_out[7:0]       Yes    Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[7:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=1,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    7       58.33   
Total Bits      24    18      75.00   
Total Bits 0->1 12    11      91.67   
Total Bits 1->0 12    7       58.33   

                            
Ports          11 7  63.64  
Port Bits      22 17 77.27  
Port Bits 0->1 11 10 90.91  
Port Bits 1->0 11 7  63.64  

                            
Signals          1 0 0.00   
Signal Bits      2 1 50.00  
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 0 0.00   

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in             No     No          Yes         INPUT     
data_reg_tdo            No     No          Yes         OUTPUT    
tdr_data_out            No     No          Yes         OUTPUT    

Signal Details
               Toggle Toggle 1->0 Toggle 0->1 
shift_register No     No          Yes         


-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=4,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    11      91.67   
Total Bits      42    40      95.24   
Total Bits 0->1 21    20      95.24   
Total Bits 1->0 21    20      95.24   

                            
Ports          11 10 90.91  
Port Bits      34 32 94.12  
Port Bits 0->1 17 16 94.12  
Port Bits 1->0 17 16 94.12  

                            
Signals          1 1 100.00 
Signal Bits      8 8 100.00 
Signal Bits 0->1 4 4 100.00 
Signal Bits 1->0 4 4 100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in[3:0]        Yes    Yes         Yes         INPUT     
data_reg_tdo            Yes    Yes         Yes         OUTPUT    
tdr_data_out[3:0]       Yes    Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[3:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=3,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 + DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=3,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel
----------------
SCORE  TOGGLE 
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    11      91.67   
Total Bits      36    34      94.44   
Total Bits 0->1 18    17      94.44   
Total Bits 1->0 18    17      94.44   

                            
Ports          11 10 90.91  
Port Bits      30 28 93.33  
Port Bits 0->1 15 14 93.33  
Port Bits 1->0 15 14 93.33  

                            
Signals          1 1 100.00 
Signal Bits      6 6 100.00 
Signal Bits 0->1 3 3 100.00 
Signal Bits 1->0 3 3 100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in[2:0]        Yes    Yes         Yes         INPUT     
data_reg_tdo            Yes    Yes         Yes         OUTPUT    
tdr_data_out[2:0]       Yes    Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[2:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=2,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS=0 ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten
----------------
SCORE  TOGGLE 
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    11      91.67   
Total Bits      30    28      93.33   
Total Bits 0->1 15    14      93.33   
Total Bits 1->0 15    14      93.33   

                            
Ports          11 10 90.91  
Port Bits      26 24 92.31  
Port Bits 0->1 13 12 92.31  
Port Bits 1->0 13 12 92.31  

                            
Signals          1 1 100.00 
Signal Bits      4 4 100.00 
Signal Bits 0->1 2 2 100.00 
Signal Bits 1->0 2 2 100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in[1:0]        Yes    Yes         Yes         INPUT     
data_reg_tdo            Yes    Yes         Yes         OUTPUT    
tdr_data_out[1:0]       Yes    Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[1:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_data_reg  ( parameter DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER=32,DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS ) 
Toggle Coverage for Module self-instances : 
top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg
----------------
SCORE  TOGGLE 
100.00 100.00 

top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg
----------------
SCORE  TOGGLE 
100.00 100.00 

                Total Covered Percent 
Totals          12    11      91.67   
Total Bits      210   208     99.05   
Total Bits 0->1 105   104     99.05   
Total Bits 1->0 105   104     99.05   

                              
Ports          11  10  90.91  
Port Bits      146 144 98.63  
Port Bits 0->1 73  72  98.63  
Port Bits 1->0 73  72  98.63  

                              
Signals          1  1  100.00 
Signal Bits      64 64 100.00 
Signal Bits 0->1 32 32 100.00 
Signal Bits 1->0 32 32 100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
sync_reset              No     No          No          INPUT     
ftap_tck                Yes    Yes         Yes         INPUT     
ftap_tdi                Yes    Yes         Yes         INPUT     
reset_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
stap_fsm_update_dr      Yes    Yes         Yes         INPUT     
tdr_data_in[31:0]       Yes    Yes         Yes         INPUT     
data_reg_tdo            Yes    Yes         Yes         OUTPUT    
tdr_data_out[31:0]      Yes    Yes         Yes         OUTPUT    

Signal Details
                     Toggle Toggle 1->0 Toggle 0->1 
shift_register[31:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_data_reg 
         Line No. Total Covered Percent 
Branches          9     7       77.78   
IF       156      4     3       75.00   
IF       103      5     4       80.00   


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status      
1   -   -   Covered     
0   1   -   Not Covered 
0   0   1   Covered     
0   0   0   Covered     


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status      
1   -   -   -   Covered     
0   1   -   -   Not Covered 
0   0   1   -   Covered     
0   0   0   1   Covered     
0   0   0   0   Covered     


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_data_reg 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 768330   14829          0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      32    32      100.00  
Total Bits 0->1 16    16      100.00  
Total Bits 1->0 16    16      100.00  

                            
Ports          10 10 100.00 
Port Bits      24 24 100.00 
Port Bits 0->1 12 12 100.00 
Port Bits 1->0 12 12 100.00 

                            
Signals          1 1 100.00 
Signal Bits      8 8 100.00 
Signal Bits 0->1 4 4 100.00 
Signal Bits 1->0 4 4 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[0]          Excluded Excluded    Excluded    INPUT     
tdr_data_in[1]          Yes      Yes         Yes         INPUT     
tdr_data_in[2]          Excluded Excluded    Excluded    INPUT     
tdr_data_in[3]          Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[0]         Excluded Excluded    Excluded    OUTPUT    
tdr_data_out[1]         Yes      Yes         Yes         OUTPUT    
tdr_data_out[2]         Excluded Excluded    Excluded    OUTPUT    
tdr_data_out[3]         Yes      Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[3:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapnw_sec_sel_tdr.generate_tapnw_sec_sel_tdr_1.i_stap_data_reg_tapc_sec_sel(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      64    64      100.00  
Total Bits 0->1 32    32      100.00  
Total Bits 1->0 32    32      100.00  

                            
Ports          10 10 100.00 
Port Bits      48 48 100.00 
Port Bits 0->1 24 24 100.00 
Port Bits 1->0 24 24 100.00 

                              
Signals          1  1  100.00 
Signal Bits      16 16 100.00 
Signal Bits 0->1 8  8  100.00 
Signal Bits 1->0 8  8  100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[7:0]        Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[7:0]       Yes      Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[7:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_sel_tdr.i_stap_data_reg_tapc_select(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      34    34      100.00  
Total Bits 0->1 17    17      100.00  
Total Bits 1->0 17    17      100.00  

                            
Ports          10 10 100.00 
Port Bits      28 28 100.00 
Port Bits 0->1 14 14 100.00 
Port Bits 1->0 14 14 100.00 

                            
Signals          1 1 100.00 
Signal Bits      6 6 100.00 
Signal Bits 0->1 3 3 100.00 
Signal Bits 1->0 3 3 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[2:0]        Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[2:0]       Yes      Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[2:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_wtap_nw_tdr.i_stap_data_reg_tapc_wtap_sel(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            125        7        7   100.00
ALWAYS            156        5        5   100.00

124                              begin
125        1/1                      if (!reset_b)
126                                 begin
127        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129        1/1                      else if (sync_reset)
130                                 begin
131        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135        1/1                         shift_register <= tdr_data_in;
136                                 end
137        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139        1/1                         shift_register <= ftap_tdi;
140                                 end
                        MISSING_ELSE
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)
                Total Covered Percent 
Totals          7     7       100.00  
Total Bits      14    14      100.00  
Total Bits 0->1 7     7       100.00  
Total Bits 1->0 7     7       100.00  

                            
Ports          7  7  100.00 
Port Bits      14 14 100.00 
Port Bits 0->1 7  7  100.00 
Port Bits 1->0 7  7  100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in             Excluded Excluded    Excluded    INPUT     
data_reg_tdo            Excluded Excluded    Excluded    OUTPUT    
tdr_data_out            Excluded Excluded    Excluded    OUTPUT    

Signal Details
               Toggle   Toggle 1->0 Toggle 0->1 
shift_register Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_remove_tdr.i_stap_data_reg_tapc_remove(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)
                Total Covered Percent 
Totals          9     9       100.00  
Total Bits      20    20      100.00  
Total Bits 0->1 10    10      100.00  
Total Bits 1->0 10    10      100.00  

                            
Ports          8  8  100.00 
Port Bits      16 16 100.00 
Port Bits 0->1 8  8  100.00 
Port Bits 1->0 8  8  100.00 

                            
Signals          1 1 100.00 
Signal Bits      4 4 100.00 
Signal Bits 0->1 2 2 100.00 
Signal Bits 1->0 2 2 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[1:0]        Excluded Excluded    Excluded    INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[1:0]       Excluded Excluded    Excluded    OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[1:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_tdrrsten_tdr.i_stap_data_reg_tapc_tdrrsten(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      28    28      100.00  
Total Bits 0->1 14    14      100.00  
Total Bits 1->0 14    14      100.00  

                            
Ports          10 10 100.00 
Port Bits      24 24 100.00 
Port Bits 0->1 12 12 100.00 
Port Bits 1->0 12 12 100.00 

                            
Signals          1 1 100.00 
Signal Bits      4 4 100.00 
Signal Bits 0->1 2 2 100.00 
Signal Bits 1->0 2 2 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[1:0]        Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[1:0]       Yes      Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[1:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_itdrrstsel_tdr.i_stap_data_reg_tapc_itdrrstsel(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      34    34      100.00  
Total Bits 0->1 17    17      100.00  
Total Bits 1->0 17    17      100.00  

                            
Ports          10 10 100.00 
Port Bits      28 28 100.00 
Port Bits 0->1 14 14 100.00 
Port Bits 1->0 14 14 100.00 

                            
Signals          1 1 100.00 
Signal Bits      6 6 100.00 
Signal Bits 0->1 3 3 100.00 
Signal Bits 1->0 3 3 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[2:0]        Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[2:0]       Yes      Yes         Yes         OUTPUT    

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
shift_register[2:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_tapc_rtdrrstsel_tdr.i_stap_data_reg_tapc_rtdrrstsel(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1575           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      208   208     100.00  
Total Bits 0->1 104   104     100.00  
Total Bits 1->0 104   104     100.00  

                              
Ports          10  10  100.00 
Port Bits      144 144 100.00 
Port Bits 0->1 72  72  100.00 
Port Bits 1->0 72  72  100.00 

                              
Signals          1  1  100.00 
Signal Bits      64 64 100.00 
Signal Bits 0->1 32 32 100.00 
Signal Bits 1->0 32 32 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[31:0]       Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[31:0]      Yes      Yes         Yes         OUTPUT    

Signal Details
                     Toggle Toggle 1->0 Toggle 0->1 
shift_register[31:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[21].i_stap_data_reg(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1902           0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
 88.96  85.71 --      92.34 --      77.78 100.00 STAP_RTL_LIB.stap_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)

             Line No.   Total   Covered  Percent
TOTAL                       12       12   100.00
ALWAYS            103        7        7   100.00
ALWAYS            156        5        5   100.00

102                              begin
103        1/1                      if (!reset_b)
104                                 begin
105        1/1                         shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        1/1                      else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        1/1                      else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        1/1                         shift_register <= tdr_data_in;
114                                 end
115        1/1                      else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        1/1                         shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                        MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        1/1                if (!reset_b)
157                           begin
158        1/1                   tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        1/1                else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        1/1                else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        1/1                   tdr_data_out <= shift_register;
167                           end
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      208   208     100.00  
Total Bits 0->1 104   104     100.00  
Total Bits 1->0 104   104     100.00  

                              
Ports          10  10  100.00 
Port Bits      144 144 100.00 
Port Bits 0->1 72  72  100.00 
Port Bits 1->0 72  72  100.00 

                              
Signals          1  1  100.00 
Signal Bits      64 64 100.00 
Signal Bits 0->1 32 32 100.00 
Signal Bits 1->0 32 32 100.00 

Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Yes      Yes         Yes         INPUT     
ftap_tdi                Yes      Yes         Yes         INPUT     
reset_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect Yes      Yes         Yes         INPUT     
stap_fsm_capture_dr     Yes      Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes      Yes         Yes         INPUT     
stap_fsm_update_dr      Yes      Yes         Yes         INPUT     
tdr_data_in[31:0]       Yes      Yes         Yes         INPUT     
data_reg_tdo            Yes      Yes         Yes         OUTPUT    
tdr_data_out[31:0]      Yes      Yes         Yes         OUTPUT    

Signal Details
                     Toggle Toggle 1->0 Toggle 0->1 
shift_register[31:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)
         Line No. Total Covered Percent 
Branches          7     7       100.00  
IF       156      3     3       100.00  
IF       103      4     4       100.00  


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==>
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==>
167              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status   
1   -   -   Covered  
0   1   -   Excluded 
0   0   1   Covered  
0   0   0   Covered  


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==>
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==>
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==>
118                    end
                       MISSING_ELSE
                       ==>

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Covered  
0   1   -   -   Excluded 
0   0   1   -   Covered  
0   0   0   1   Covered  
0   0   0   0   Covered  


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_itdr.generate_itdr_1[22].i_stap_data_reg(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                           Attempts Real Successes Failures Incomplete 
chk_stap_dr_stable_during_trst 85370    1902           0        0          


===============================================================================
Module : STAP_RTL_LIB.stap_fsm
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 91.97  95.08 100.00  98.60  82.50  91.43  84.21 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_fsm.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                            
 97.37 100.00 100.00 100.00 100.00 100.00  84.21 top.stap_top_inst.i_stap_fsm(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_fsm 

             Line No.   Total   Covered  Percent
TOTAL                      122      116    95.08
ALWAYS            325       66       60    90.91
ALWAYS            646        5        5   100.00
ALWAYS            667        5        5   100.00
ALWAYS            697        3        3   100.00
ALWAYS            714        3        3   100.00
ALWAYS            721       11       11   100.00
ALWAYS            778        8        8   100.00
ALWAYS            850        2        2   100.00
ROUTINE           857       19       19   100.00

324                        begin
325        1/1                case (state_ps)
326                           TLRS:
327                           begin
328        1/1                   case (arc_tlrs_ruti)
329                              HIGH:
330                              begin
331        1/1                      state_ns = RUTI;
332                              end
333                              LOW:
334                              begin
335        1/1                      state_ns = TLRS;
336                              end
337                              default:
338                              begin
339        0/1     ==>              state_ns = TLRS;
340                              end
341                              endcase
342                           end
343                           RUTI:
344                           begin
345        1/1                   case (arc_ruti_sdrs)
346                              HIGH:
347                              begin
348        1/1                      state_ns = SDRS;
349                              end
350                              LOW:
351                              begin
352        1/1                      state_ns = RUTI;
353                              end
354                              default:
355                              begin
356        0/1     ==>              state_ns = RUTI;
357                              end
358                              endcase
359                           end
360                           SDRS:
361                           begin
362        1/1                   case (sdrs_cadr_or_sirs)
363                              2'b01:
364                              begin
365        1/1                      state_ns = SIRS;
366                              end
367                              2'b10:
368                              begin
369        1/1                      state_ns = CADR;
370                              end
371                              default:
372                              begin
373        1/1                      state_ns = SDRS;
374                              end
375                              endcase
376                           end
377                           SIRS:
378                           begin
379        1/1                   case (sirs_cair_or_tlrs)
380                              2'b01:
381                              begin
382        1/1                      state_ns = TLRS;
383                              end
384                              2'b10:
385                              begin
386        1/1                      state_ns = CAIR;
387                              end
388                              default:
389                              begin
390        1/1                      state_ns = SIRS;
391                              end
392                              endcase
393                           end
394                           CADR:
395                           begin
396        1/1                   case (cadr_shdr_or_e1dr)
397                              2'b01:
398                              begin
399        1/1                      state_ns = E1DR;
400                              end
401                              2'b10:
402                              begin
403        1/1                      state_ns = SHDR;
404                              end
405                              default:
406                              begin
407        1/1                      state_ns = CADR;
408                              end
409                              endcase
410                           end
411                           SHDR:
412                           begin
413        1/1                   case (arc_shdr_e1dr)
414                              HIGH:
415                              begin
416        1/1                      state_ns = E1DR;
417                              end
418                              LOW:
419                              begin
420        1/1                      state_ns = SHDR;
421                              end
422                              default:
423                              begin
424        0/1     ==>              state_ns = SHDR;
425                              end
426                              endcase
427                           end
428                           E1DR:
429                           begin
430        1/1                   case (e1dr_padr_or_updr)
431                              2'b01:
432                              begin
433        1/1                      state_ns = UPDR;
434                              end
435                              2'b10:
436                              begin
437        1/1                      state_ns = PADR;
438                              end
439                              default:
440                              begin
441        1/1                      state_ns = E1DR;
442                              end
443                              endcase
444                           end
445                           PADR:
446                           begin
447        1/1                   case (arc_padr_e2dr)
448                              HIGH:
449                              begin
450        1/1                      state_ns = E2DR;
451                              end
452                              LOW:
453                              begin
454        1/1                      state_ns = PADR;
455                              end
456                              default:
457                              begin
458        0/1     ==>              state_ns = PADR;
459                              end
460                              endcase
461                           end
462                           E2DR:
463                           begin
464        1/1                   case (e2dr_shdr_or_updr)
465                              2'b01:
466                              begin
467        1/1                      state_ns = UPDR;
468                              end
469                              2'b10:
470                              begin
471        1/1                      state_ns = SHDR;
472                              end
473                              default:
474                              begin
475        1/1                      state_ns = E2DR;
476                              end
477                              endcase
478                           end
479                           UPDR:
480                           begin
481        1/1                   case (updr_ruti_or_sdrs)
482                              2'b01:
483                              begin
484        1/1                      state_ns = SDRS;
485                              end
486                              2'b10:
487                              begin
488        1/1                      state_ns = RUTI;
489                              end
490                              default:
491                              begin
492        1/1                      state_ns = UPDR;
493                              end
494                              endcase
495                           end
496                           CAIR:
497                           begin
498        1/1                   case (cair_shir_or_e1ir)
499                              2'b01:
500                              begin
501        1/1                      state_ns = E1IR;
502                              end
503                              2'b10:
504                              begin
505        1/1                      state_ns = SHIR;
506                              end
507                              default:
508                              begin
509        1/1                      state_ns = CAIR;
510                              end
511                              endcase
512                           end
513                           SHIR:
514                           begin
515        1/1                   case (arc_shir_e1ir)
516                              HIGH:
517                              begin
518        1/1                      state_ns = E1IR;
519                              end
520                              LOW:
521                              begin
522        1/1                      state_ns = SHIR;
523                              end
524                              default:
525                              begin
526        0/1     ==>              state_ns = SHIR;
527                              end
528                              endcase
529                           end
530                           E1IR:
531                           begin
532        1/1                   case (e1ir_pair_or_upir)
533                              2'b01:
534                              begin
535        1/1                      state_ns = UPIR;
536                              end
537                              2'b10:
538                              begin
539        1/1                      state_ns = PAIR;
540                              end
541                              default:
542                              begin
543        1/1                      state_ns = E1IR;
544                              end
545                              endcase
546                           end
547                           PAIR:
548                           begin
549        1/1                   case (arc_pair_e2ir)
550                              HIGH:
551                              begin
552        1/1                      state_ns = E2IR;
553                              end
554                              LOW:
555                              begin
556        1/1                      state_ns = PAIR;
557                              end
558                              default
559                              begin
560        0/1     ==>              state_ns = PAIR;
561                              end
562                              endcase
563                           end
564                           E2IR:
565                           begin
566        1/1                   case (e2ir_shir_or_upir)
567                              2'b01:
568                              begin
569        1/1                      state_ns = UPIR;
570                              end
571                              2'b10:
572                              begin
573        1/1                      state_ns = SHIR;
574                              end
575                              default
576                              begin
577        1/1                      state_ns = E2IR;
578                              end
579                              endcase
580                           end
581                           UPIR:
582                           begin
583        1/1                   case (upir_ruti_or_sdrs)
584                              2'b01:
585                              begin
586        1/1                      state_ns = SDRS;
587                              end
588                              2'b10:
589                              begin
590        1/1                      state_ns = RUTI;
591                              end
592                              default:
593                              begin
594        1/1                      state_ns = UPIR;
595                              end
596                              endcase
597                           end
598                           default:
599                           begin
600        1/1                   state_ns = TLRS;
601                              //state_ns = SIXTEEN_BIT_UNKNOWN_VALUE;
602                           end
603                           endcase
604                        end
605                     
606                        // *********************************************************************
607                        // Remove bit-TMS Logic
608                        // *********************************************************************
609                        assign ftap_tms_internal = (tapc_remove == HIGH) ? HIGH : ftap_tms;
610                     
611                        // *********************************************************************
612                        // FSM arc assignment
613                        // *********************************************************************
614                        assign arc_tlrs_ruti = ~ftap_tms_internal & tlrs_present_state;
615                        assign arc_ruti_sdrs =  ftap_tms_internal & ruti_present_state;
616                        assign arc_sdrs_cadr = ~ftap_tms_internal & sdrs_present_state;
617                        assign arc_cadr_shdr = ~ftap_tms_internal & cadr_present_state;
618                        assign arc_shdr_e1dr =  ftap_tms_internal & shdr_present_state;
619                        assign arc_e1dr_padr = ~ftap_tms_internal & e1dr_present_state;
620                        assign arc_padr_e2dr =  ftap_tms_internal & padr_present_state;
621                        assign arc_e2dr_updr =  ftap_tms_internal & e2dr_present_state;
622                        assign arc_e1dr_updr =  ftap_tms_internal & e1dr_present_state;
623                        assign arc_e2dr_shdr = ~ftap_tms_internal & e2dr_present_state;
624                        assign arc_cadr_e1dr =  ftap_tms_internal & cadr_present_state;
625                        assign arc_updr_sdrs =  ftap_tms_internal & updr_present_state;
626                        assign arc_updr_ruti = ~ftap_tms_internal & updr_present_state;
627                        assign arc_sdrs_sirs =  ftap_tms_internal & sdrs_present_state;
628                        assign arc_sirs_cair = ~ftap_tms_internal & sirs_present_state;
629                        assign arc_cair_shir = ~ftap_tms_internal & cair_present_state;
630                        assign arc_shir_e1ir =  ftap_tms_internal & shir_present_state;
631                        assign arc_e1ir_pair = ~ftap_tms_internal & e1ir_present_state;
632                        assign arc_pair_e2ir =  ftap_tms_internal & pair_present_state;
633                        assign arc_e2ir_upir =  ftap_tms_internal & e2ir_present_state;
634                        assign arc_e1ir_upir =  ftap_tms_internal & e1ir_present_state;
635                        assign arc_e2ir_shir = ~ftap_tms_internal & e2ir_present_state;
636                        assign arc_cair_e1ir =  ftap_tms_internal & cair_present_state;
637                        assign arc_upir_sdrs =  ftap_tms_internal & upir_present_state;
638                        assign arc_upir_ruti = ~ftap_tms_internal & upir_present_state;
639                        assign arc_sirs_tlrs =  ftap_tms_internal & sirs_present_state;
640                     
641                        // *********************************************************************
642                        // Five consecutive TMS=1 causes soft reset
643                        // *********************************************************************
644                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
645                        begin
646        1/1                if (!powergood_rst_trst_b)
647                           begin
648        1/1                   tms_bit <= FOUR_BIT_LOW_VALUE;
649                           end
650        1/1                else if (stap_fsm_tlrs)
651                           begin
652        1/1                   tms_bit <= FOUR_BIT_LOW_VALUE;
653                           end
654                           else
655                           begin
656        1/1                   tms_bit <= {tms_bit[TWO:0], ftap_tms_internal};
657                           end
658                        end
659                     
660                        assign soft_reset = (&tms_bit) & ftap_tms_internal;
661                     
662                        // *********************************************************************
663                        // Present state logic
664                        // *********************************************************************
665                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
666                        begin
667        1/1                if (!powergood_rst_trst_b)
668                           begin
669        1/1                   state_ps <= TLRS;
670                           end
671        1/1                else if (soft_reset)
672                           begin
673        1/1                   state_ps <= TLRS;
674                           end
675                           else
676                           begin
677        1/1                   state_ps <= state_ns;
678                           end
679                        end
680                     
681                        // *********************************************************************
682                        // output port assignment - based on the FSM states
683                        // *********************************************************************
684                        assign stap_fsm_tlrs       = tlrs_present_state;
685                        assign stap_fsm_rti        = ruti_present_state;
686                        assign stap_fsm_e1dr       = e1dr_present_state;
687                        assign stap_fsm_e2dr       = e2dr_present_state;
688                        assign stap_fsm_capture_ir = cair_present_state;
689                        assign stap_fsm_shift_ir   = shir_present_state;
690                        assign stap_fsm_update_ir  = upir_present_state;
691                        assign stap_fsm_capture_dr = cadr_present_state;
692                     
693                        assign stap_fsm_shift_dr   = shdr_present_state;
694                        assign stap_fsm_update_dr  = updr_present_state;
695                     
696                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
697        1/1                if (!powergood_rst_trst_b)
698                           begin
699        1/1                   stap_fsm_shift_ir_neg <= LOW;
700                           end
701                           else
702                           begin
703        1/1                   stap_fsm_shift_ir_neg <= stap_fsm_shift_ir;
704                           end
705                     
706                        // *********************************************************************
707                        // Generation of scan IR (selectwir) signal
708                        // *********************************************************************
709                        generate
710                           if ((FSM_STAP_ENABLE_TAP_NETWORK == 1) || (FSM_STAP_WTAP_COMMON_LOGIC == 1) || (FSM_STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS == 1))
711                           begin:generate_irscan_sig
712                     //kbbhagwa posedge negedge signal merge
713                             always_ff @(negedge  ftap_tck or negedge powergood_rst_trst_b)
714        1/1                    if (!powergood_rst_trst_b)
715        1/1                      stap_selectwir_neg <= LOW;
716                               else
717        1/1                      stap_selectwir_neg <= stap_selectwir;
718                     
719                              always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
720                              begin
721        1/1                      if (!powergood_rst_trst_b)
722                                 begin
723        1/1                         stap_selectwir <= LOW;
724                                 end
725                                 else
726                                 begin
727        1/1                         if (tlrs_present_state)
728                                    begin
729        1/1                            stap_selectwir <= LOW;
730                                    end
731        1/1                         else if (tlrs_next_state)
732                                    begin
733        1/1                            stap_selectwir <= LOW;
734                                    end
735        1/1                         else if ( ruti_present_state | cadr_next_state)
736        1/1                            stap_selectwir <= LOW;
737        1/1                         else if (sirs_next_state)
738                                    begin
739        1/1                            stap_selectwir <= HIGH;
740                                    end
741                                    else
742                                    begin
743        1/1                            stap_selectwir <= stap_selectwir;
744                                    end
745                                 end
746                              end
747                           end
748                           else
749                           begin:generate_irscan_sig
750                              assign stap_selectwir     = LOW;
751                              assign stap_selectwir_neg = LOW; //kbbhagwa posedge negedge signal merge
752                           end
753                        endgenerate
754                     
755                        // *********************************************************************
756                        // code for Glue Logic requirement of stap_selectwir
757                        // *********************************************************************
758                        generate
759                           if (FSM_STAP_WTAP_COMMON_LOGIC == 1)
760                           begin:generate_selectwir_sig
761                              // ---------------------------------------------------------------
762                              // Generation of sn_fwtap_rti, sn_fwtap_capturewr, sn_fwtap_shiftwr and sn_fwtap_updatewr
763                              // ---------------------------------------------------------------
764                              assign sn_fwtap_rti       =  ruti_present_state;
765                              assign stap_capturewr_int = (cair_present_state | cadr_present_state);
766                              assign stap_shiftwr_int   = (shir_present_state | shdr_present_state);
767                              assign sn_fwtap_updatewr  = (upir_present_state | updr_present_state);
768                              // *********************************************************************
769                              // output reset signal generation
770                              // *********************************************************************
771                              assign sn_fwtap_wrst_b = ~stap_fsm_tlrs;
772                              // *********************************************************************
773                              // added negedge floping for capturewr and shiftwr. In accordance with
774                              //   1500 and SoC TAP HAS rev088_rc3
775                              // *********************************************************************
776                              always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
777                              begin
778        1/1                      if (!powergood_rst_trst_b)
779                                 begin
780        1/1                         sn_fwtap_capturewr_neg <= LOW;
781        1/1                         sn_fwtap_shiftwr_neg   <= LOW;
782                                 end
783        1/1                      else if (soft_reset)
784                                 begin
785        1/1                         sn_fwtap_capturewr_neg <= LOW;
786        1/1                         sn_fwtap_shiftwr_neg   <= LOW;
787                                 end
788                                 else
789                                 begin
790        1/1                         sn_fwtap_capturewr_neg <= stap_capturewr_int;
791        1/1                         sn_fwtap_shiftwr_neg   <= stap_shiftwr_int;
792                                 end
793                              end
794                           end
795                           else
796                           begin:generate_selectwir_sig
797                              assign sn_fwtap_rti           = LOW;
798                              assign sn_fwtap_capturewr_neg = LOW;
799                              assign sn_fwtap_shiftwr_neg   = LOW;
800                              assign sn_fwtap_updatewr      = LOW;
801                              assign sn_fwtap_wrst_b        = HIGH;
802                           end
803                        endgenerate
804                     
805                        //**********************************************************************
806                        //Pass posedge of sn_fwtap_capturewr and sn_fwtap_shiftwr cntrl signals
807                        //for WTAP if the parameter FSM_STAP_ENABLE_WTAP_CTRL_POS_EDGE is one
808                        //else pass negedge of the cntrl signals
809                        //**********************************************************************
810                        generate
811                           if (FSM_STAP_ENABLE_WTAP_CTRL_POS_EDGE == 1)
812                           begin:generate_posneg_cntrl_wtap
813                              assign sn_fwtap_capturewr = stap_capturewr_int;
814                              assign sn_fwtap_shiftwr   = stap_shiftwr_int;
815                           end
816                           else
817                           begin:generate_posneg_cntrl_wtap
818                              assign sn_fwtap_capturewr = sn_fwtap_capturewr_neg;
819                              assign sn_fwtap_shiftwr   = sn_fwtap_shiftwr_neg;
820                           end
821                        endgenerate
822                     
823                     
824                        // ====================================================================
825                        `ifdef INTEL_SIMONLY
826                        // ====================================================================
827                        typedef enum logic [15:0] {
828                           tlrs = 16'h0001,
829                           ruti = 16'h0002,
830                           sdrs = 16'h0004,
831                           cadr = 16'h0008,
832                           shdr = 16'h0010,
833                           e1dr = 16'h0020,
834                           padr = 16'h0040,
835                           e2dr = 16'h0080,
836                           updr = 16'h0100,
837                           sirs = 16'h0200,
838                           cair = 16'h0400,
839                           shir = 16'h0800,
840                           e1ir = 16'h1000,
841                           pair = 16'h2000,
842                           e2ir = 16'h4000,
843                           upir = 16'h8000} fsm_states_t;
844                     
845                        fsm_states_t present_state;
846                        fsm_states_t next_state;
847                     
848                        always_comb
849                        begin
850        1/1                present_state = state_str(state_ps);
851        1/1                next_state    = state_str(state_ns);
852                        end
853                     
854                        function automatic fsm_states_t state_str(logic [15:0] state);
855                           begin
856                              fsm_states_t str;
857        1/1                   case (state)
858        1/1                      TLRS:    begin str = tlrs; end
859        1/1                      RUTI:    begin str = ruti; end
860        1/1                      SDRS:    begin str = sdrs; end
861        1/1                      CADR:    begin str = cadr; end
862        1/1                      SHDR:    begin str = shdr; end
863        1/1                      E1DR:    begin str = e1dr; end
864        1/1                      PADR:    begin str = padr; end
865        1/1                      E2DR:    begin str = e2dr; end
866        1/1                      UPDR:    begin str = updr; end
867        1/1                      SIRS:    begin str = sirs; end
868        1/1                      CAIR:    begin str = cair; end
869        1/1                      SHIR:    begin str = shir; end
870        1/1                      E1IR:    begin str = e1ir; end
871        1/1                      PAIR:    begin str = pair; end
872        1/1                      E2IR:    begin str = e2ir; end
873        1/1                      UPIR:    begin str = upir; end
874        1/1                      default: begin str = tlrs; end
875                              endcase
876        1/1                   return str;

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_fsm 

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       609
 EXPRESSION ((tapc_remove == HIGH) ? HIGH : ftap_tms)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_fsm 
                Total Covered Percent 
Totals          105   102     97.14   
Total Bits      356   351     98.60   
Total Bits 0->1 178   176     98.88   
Total Bits 1->0 178   175     98.31   

                            
Ports          22 21 95.45  
Port Bits      44 43 97.73  
Port Bits 0->1 22 22 100.00 
Port Bits 1->0 22 21 95.45  

                                
Signals          83  81  97.59  
Signal Bits      312 308 98.72  
Signal Bits 0->1 156 154 98.72  
Signal Bits 1->0 156 154 98.72  

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tms              Yes    Yes         Yes         INPUT     
ftap_tck              Yes    Yes         Yes         INPUT     
powergood_rst_trst_b  Yes    Yes         Yes         INPUT     
tapc_remove           No     No          Yes         INPUT     
stap_fsm_tlrs         Yes    Yes         Yes         OUTPUT    
stap_fsm_rti          Yes    Yes         Yes         OUTPUT    
stap_fsm_e1dr         Yes    Yes         Yes         OUTPUT    
stap_fsm_e2dr         Yes    Yes         Yes         OUTPUT    
stap_selectwir        Yes    Yes         Yes         OUTPUT    
stap_selectwir_neg    Yes    Yes         Yes         OUTPUT    
sn_fwtap_capturewr    Yes    Yes         Yes         OUTPUT    
sn_fwtap_shiftwr      Yes    Yes         Yes         OUTPUT    
sn_fwtap_updatewr     Yes    Yes         Yes         OUTPUT    
sn_fwtap_rti          Yes    Yes         Yes         OUTPUT    
sn_fwtap_wrst_b       Yes    Yes         Yes         OUTPUT    
stap_fsm_capture_ir   Yes    Yes         Yes         OUTPUT    
stap_fsm_shift_ir     Yes    Yes         Yes         OUTPUT    
stap_fsm_shift_ir_neg Yes    Yes         Yes         OUTPUT    
stap_fsm_update_ir    Yes    Yes         Yes         OUTPUT    
stap_fsm_capture_dr   Yes    Yes         Yes         OUTPUT    
stap_fsm_shift_dr     Yes    Yes         Yes         OUTPUT    
stap_fsm_update_dr    Yes    Yes         Yes         OUTPUT    

Signal Details
                       Toggle Toggle 1->0 Toggle 0->1 
state_ps[15:0]         Yes    Yes         Yes         
state_ns[15:0]         Yes    Yes         Yes         
tms_bit[3:0]           Yes    Yes         Yes         
arc_tlrs_ruti          Yes    Yes         Yes         
arc_ruti_sdrs          Yes    Yes         Yes         
arc_sdrs_cadr          Yes    Yes         Yes         
arc_cadr_shdr          Yes    Yes         Yes         
arc_shdr_e1dr          Yes    Yes         Yes         
arc_e1dr_padr          Yes    Yes         Yes         
arc_padr_e2dr          Yes    Yes         Yes         
arc_e2dr_updr          Yes    Yes         Yes         
arc_e1dr_updr          Yes    Yes         Yes         
arc_e2dr_shdr          Yes    Yes         Yes         
arc_cadr_e1dr          Yes    Yes         Yes         
arc_updr_sdrs          Yes    Yes         Yes         
arc_updr_ruti          Yes    Yes         Yes         
arc_sdrs_sirs          Yes    Yes         Yes         
arc_sirs_cair          Yes    Yes         Yes         
arc_cair_shir          Yes    Yes         Yes         
arc_shir_e1ir          Yes    Yes         Yes         
arc_e1ir_pair          Yes    Yes         Yes         
arc_pair_e2ir          Yes    Yes         Yes         
arc_e2ir_upir          Yes    Yes         Yes         
arc_e1ir_upir          Yes    Yes         Yes         
arc_e2ir_shir          No     No          No          
arc_cair_e1ir          Yes    Yes         Yes         
arc_upir_sdrs          Yes    Yes         Yes         
arc_upir_ruti          Yes    Yes         Yes         
arc_sirs_tlrs          Yes    Yes         Yes         
tlrs_present_state     Yes    Yes         Yes         
ruti_present_state     Yes    Yes         Yes         
sdrs_present_state     Yes    Yes         Yes         
cadr_present_state     Yes    Yes         Yes         
cadr_next_state        Yes    Yes         Yes         
shdr_present_state     Yes    Yes         Yes         
e1dr_present_state     Yes    Yes         Yes         
padr_present_state     Yes    Yes         Yes         
e2dr_present_state     Yes    Yes         Yes         
updr_present_state     Yes    Yes         Yes         
updr_next_state        Yes    Yes         Yes         
sirs_present_state     Yes    Yes         Yes         
cair_present_state     Yes    Yes         Yes         
shir_present_state     Yes    Yes         Yes         
e1ir_present_state     Yes    Yes         Yes         
pair_present_state     Yes    Yes         Yes         
e2ir_present_state     Yes    Yes         Yes         
upir_present_state     Yes    Yes         Yes         
tlrs_next_state        Yes    Yes         Yes         
sirs_next_state        Yes    Yes         Yes         
sdrs_cadr_or_sirs[1:0] Yes    Yes         Yes         
sirs_cair_or_tlrs[1:0] Yes    Yes         Yes         
cadr_shdr_or_e1dr[1:0] Yes    Yes         Yes         
e1dr_padr_or_updr[1:0] Yes    Yes         Yes         
e2dr_shdr_or_updr[1:0] Yes    Yes         Yes         
updr_ruti_or_sdrs[1:0] Yes    Yes         Yes         
cair_shir_or_e1ir[1:0] Yes    Yes         Yes         
e1ir_pair_or_upir[1:0] Yes    Yes         Yes         
e2ir_shir_or_upir[0]   Yes    Yes         Yes         
e2ir_shir_or_upir[1]   No     No          No          
upir_ruti_or_sdrs[1:0] Yes    Yes         Yes         
soft_reset             Yes    Yes         Yes         
ftap_tms_internal      Yes    Yes         Yes         
stap_capturewr_int     Yes    Yes         Yes         
stap_shiftwr_int       Yes    Yes         Yes         
sn_fwtap_capturewr_neg Yes    Yes         Yes         
sn_fwtap_shiftwr_neg   Yes    Yes         Yes         
present_state[15:0]    Yes    Yes         Yes         
next_state[15:0]       Yes    Yes         Yes         
Tlrs                   Yes    Yes         Yes         
Ruti                   Yes    Yes         Yes         
Sdrs                   Yes    Yes         Yes         
Cadr                   Yes    Yes         Yes         
Shdr                   Yes    Yes         Yes         
E1dr                   Yes    Yes         Yes         
Padr                   Yes    Yes         Yes         
E2dr                   Yes    Yes         Yes         
Updr                   Yes    Yes         Yes         
Sirs                   Yes    Yes         Yes         
Cair                   Yes    Yes         Yes         
Shir                   Yes    Yes         Yes         
E1ir                   Yes    Yes         Yes         
Pair                   Yes    Yes         Yes         
E2ir                   Yes    Yes         Yes         
Upir                   Yes    Yes         Yes         


-------------------------------------------------------------------------------
FSM Coverage for Module : \STAP_RTL_LIB.stap_fsm 
Summary for FSM :: state_ps
            Total Covered Percent                         
States      16    16      100.00  (Not included in score) 
Transitions 40    33      82.50                           
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: state_ps
-------------------------------------------------------------------------------
states Line No. Covered 
TLRS   331      Covered 
RUTI   331      Covered 
SDRS   348      Covered 
CADR   369      Covered 
SHDR   403      Covered 
E1DR   399      Covered 
PADR   437      Covered 
E2DR   450      Covered 
UPDR   433      Covered 
SIRS   365      Covered 
CAIR   386      Covered 
SHIR   505      Covered 
E1IR   501      Covered 
PAIR   539      Covered 
E2IR   552      Covered 
UPIR   535      Covered 

transitions Line No. Covered     
TLRS->RUTI  331      Covered     
RUTI->TLRS  669      Covered     
RUTI->SDRS  348      Covered     
SDRS->TLRS  669      Covered     
SDRS->CADR  369      Covered     
SDRS->SIRS  365      Covered     
CADR->TLRS  669      Not Covered 
CADR->SHDR  403      Covered     
CADR->E1DR  399      Covered     
SHDR->TLRS  669      Covered     
SHDR->E1DR  416      Covered     
E1DR->TLRS  669      Not Covered 
E1DR->PADR  437      Covered     
E1DR->UPDR  433      Covered     
PADR->TLRS  669      Covered     
PADR->E2DR  450      Covered     
E2DR->TLRS  669      Not Covered 
E2DR->SHDR  471      Covered     
E2DR->UPDR  467      Covered     
UPDR->TLRS  669      Covered     
UPDR->RUTI  488      Covered     
UPDR->SDRS  484      Covered     
SIRS->TLRS  382      Covered     
SIRS->CAIR  386      Covered     
CAIR->TLRS  669      Not Covered 
CAIR->SHIR  505      Covered     
CAIR->E1IR  501      Covered     
SHIR->TLRS  669      Covered     
SHIR->E1IR  518      Covered     
E1IR->TLRS  669      Not Covered 
E1IR->PAIR  539      Covered     
E1IR->UPIR  535      Covered     
PAIR->TLRS  669      Covered     
PAIR->E2IR  552      Covered     
E2IR->TLRS  669      Not Covered 
E2IR->SHIR  573      Not Covered 
E2IR->UPIR  569      Covered     
UPIR->TLRS  669      Covered     
UPIR->RUTI  590      Covered     
UPIR->SDRS  586      Covered     

sequences Covered 


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_fsm 
         Line No. Total Covered Percent 
Branches          70    64      91.43   
TERNARY  609      2     2       100.00  
CASE     325      49    43      87.76   
IF       646      3     3       100.00  
IF       667      3     3       100.00  
IF       697      2     2       100.00  
IF       714      2     2       100.00  
IF       721      6     6       100.00  
IF       778      3     3       100.00  


609           assign ftap_tms_internal = (tapc_remove == HIGH) ? HIGH : ftap_tms;
                                                               -1-  
                                                               ==>  
                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


325              case (state_ps)
                 -1-  
326              TLRS:
327              begin
328                 case (arc_tlrs_ruti)
                    -2-  
329                 HIGH:
330                 begin
331                    state_ns = RUTI;
                       ==>
332                 end
333                 LOW:
334                 begin
335                    state_ns = TLRS;
                       ==>
336                 end
337                 default:
338                 begin
339                    state_ns = TLRS;
                       ==>
340                 end
341                 endcase
342              end
343              RUTI:
344              begin
345                 case (arc_ruti_sdrs)
                    -3-  
346                 HIGH:
347                 begin
348                    state_ns = SDRS;
                       ==>
349                 end
350                 LOW:
351                 begin
352                    state_ns = RUTI;
                       ==>
353                 end
354                 default:
355                 begin
356                    state_ns = RUTI;
                       ==>
357                 end
358                 endcase
359              end
360              SDRS:
361              begin
362                 case (sdrs_cadr_or_sirs)
                    -4-  
363                 2'b01:
364                 begin
365                    state_ns = SIRS;
                       ==>
366                 end
367                 2'b10:
368                 begin
369                    state_ns = CADR;
                       ==>
370                 end
371                 default:
372                 begin
373                    state_ns = SDRS;
                       ==>
374                 end
375                 endcase
376              end
377              SIRS:
378              begin
379                 case (sirs_cair_or_tlrs)
                    -5-  
380                 2'b01:
381                 begin
382                    state_ns = TLRS;
                       ==>
383                 end
384                 2'b10:
385                 begin
386                    state_ns = CAIR;
                       ==>
387                 end
388                 default:
389                 begin
390                    state_ns = SIRS;
                       ==>
391                 end
392                 endcase
393              end
394              CADR:
395              begin
396                 case (cadr_shdr_or_e1dr)
                    -6-  
397                 2'b01:
398                 begin
399                    state_ns = E1DR;
                       ==>
400                 end
401                 2'b10:
402                 begin
403                    state_ns = SHDR;
                       ==>
404                 end
405                 default:
406                 begin
407                    state_ns = CADR;
                       ==>
408                 end
409                 endcase
410              end
411              SHDR:
412              begin
413                 case (arc_shdr_e1dr)
                    -7-  
414                 HIGH:
415                 begin
416                    state_ns = E1DR;
                       ==>
417                 end
418                 LOW:
419                 begin
420                    state_ns = SHDR;
                       ==>
421                 end
422                 default:
423                 begin
424                    state_ns = SHDR;
                       ==>
425                 end
426                 endcase
427              end
428              E1DR:
429              begin
430                 case (e1dr_padr_or_updr)
                    -8-  
431                 2'b01:
432                 begin
433                    state_ns = UPDR;
                       ==>
434                 end
435                 2'b10:
436                 begin
437                    state_ns = PADR;
                       ==>
438                 end
439                 default:
440                 begin
441                    state_ns = E1DR;
                       ==>
442                 end
443                 endcase
444              end
445              PADR:
446              begin
447                 case (arc_padr_e2dr)
                    -9-  
448                 HIGH:
449                 begin
450                    state_ns = E2DR;
                       ==>
451                 end
452                 LOW:
453                 begin
454                    state_ns = PADR;
                       ==>
455                 end
456                 default:
457                 begin
458                    state_ns = PADR;
                       ==>
459                 end
460                 endcase
461              end
462              E2DR:
463              begin
464                 case (e2dr_shdr_or_updr)
                    -10-  
465                 2'b01:
466                 begin
467                    state_ns = UPDR;
                       ==>
468                 end
469                 2'b10:
470                 begin
471                    state_ns = SHDR;
                       ==>
472                 end
473                 default:
474                 begin
475                    state_ns = E2DR;
                       ==>
476                 end
477                 endcase
478              end
479              UPDR:
480              begin
481                 case (updr_ruti_or_sdrs)
                    -11-  
482                 2'b01:
483                 begin
484                    state_ns = SDRS;
                       ==>
485                 end
486                 2'b10:
487                 begin
488                    state_ns = RUTI;
                       ==>
489                 end
490                 default:
491                 begin
492                    state_ns = UPDR;
                       ==>
493                 end
494                 endcase
495              end
496              CAIR:
497              begin
498                 case (cair_shir_or_e1ir)
                    -12-  
499                 2'b01:
500                 begin
501                    state_ns = E1IR;
                       ==>
502                 end
503                 2'b10:
504                 begin
505                    state_ns = SHIR;
                       ==>
506                 end
507                 default:
508                 begin
509                    state_ns = CAIR;
                       ==>
510                 end
511                 endcase
512              end
513              SHIR:
514              begin
515                 case (arc_shir_e1ir)
                    -13-  
516                 HIGH:
517                 begin
518                    state_ns = E1IR;
                       ==>
519                 end
520                 LOW:
521                 begin
522                    state_ns = SHIR;
                       ==>
523                 end
524                 default:
525                 begin
526                    state_ns = SHIR;
                       ==>
527                 end
528                 endcase
529              end
530              E1IR:
531              begin
532                 case (e1ir_pair_or_upir)
                    -14-  
533                 2'b01:
534                 begin
535                    state_ns = UPIR;
                       ==>
536                 end
537                 2'b10:
538                 begin
539                    state_ns = PAIR;
                       ==>
540                 end
541                 default:
542                 begin
543                    state_ns = E1IR;
                       ==>
544                 end
545                 endcase
546              end
547              PAIR:
548              begin
549                 case (arc_pair_e2ir)
                    -15-  
550                 HIGH:
551                 begin
552                    state_ns = E2IR;
                       ==>
553                 end
554                 LOW:
555                 begin
556                    state_ns = PAIR;
                       ==>
557                 end
558                 default
559                 begin
560                    state_ns = PAIR;
                       ==>
561                 end
562                 endcase
563              end
564              E2IR:
565              begin
566                 case (e2ir_shir_or_upir)
                    -16-  
567                 2'b01:
568                 begin
569                    state_ns = UPIR;
                       ==>
570                 end
571                 2'b10:
572                 begin
573                    state_ns = SHIR;
                       ==>
574                 end
575                 default
576                 begin
577                    state_ns = E2IR;
                       ==>
578                 end
579                 endcase
580              end
581              UPIR:
582              begin
583                 case (upir_ruti_or_sdrs)
                    -17-  
584                 2'b01:
585                 begin
586                    state_ns = SDRS;
                       ==>
587                 end
588                 2'b10:
589                 begin
590                    state_ns = RUTI;
                       ==>
591                 end
592                 default:
593                 begin
594                    state_ns = UPIR;
                       ==>
595                 end
596                 endcase
597              end
598              default:
599              begin
600                 state_ns = TLRS;
                    ==>

Branches:

-1-     -2-     -3-     -4-     -5-     -6-     -7-     -8-     -9-     -10-    -11-    -12-    -13-    -14-    -15-    -16-    -17-    Status      
TLRS    HIGH    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
TLRS    LOW     -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
TLRS    default -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Not Covered 
RUTI    -       HIGH    -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
RUTI    -       LOW     -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
RUTI    -       default -       -       -       -       -       -       -       -       -       -       -       -       -       -       Not Covered 
SDRS    -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
SDRS    -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
SDRS    -       -       default -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     
SIRS    -       -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       -       Covered     
SIRS    -       -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       -       Covered     
SIRS    -       -       -       default -       -       -       -       -       -       -       -       -       -       -       -       Covered     
CADR    -       -       -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       Covered     
CADR    -       -       -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       Covered     
CADR    -       -       -       -       default -       -       -       -       -       -       -       -       -       -       -       Covered     
SHDR    -       -       -       -       -       HIGH    -       -       -       -       -       -       -       -       -       -       Covered     
SHDR    -       -       -       -       -       LOW     -       -       -       -       -       -       -       -       -       -       Covered     
SHDR    -       -       -       -       -       default -       -       -       -       -       -       -       -       -       -       Not Covered 
E1DR    -       -       -       -       -       -       2'b01   -       -       -       -       -       -       -       -       -       Covered     
E1DR    -       -       -       -       -       -       2'b10   -       -       -       -       -       -       -       -       -       Covered     
E1DR    -       -       -       -       -       -       default -       -       -       -       -       -       -       -       -       Covered     
PADR    -       -       -       -       -       -       -       HIGH    -       -       -       -       -       -       -       -       Covered     
PADR    -       -       -       -       -       -       -       LOW     -       -       -       -       -       -       -       -       Covered     
PADR    -       -       -       -       -       -       -       default -       -       -       -       -       -       -       -       Not Covered 
E2DR    -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       -       -       Covered     
E2DR    -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       -       -       Covered     
E2DR    -       -       -       -       -       -       -       -       default -       -       -       -       -       -       -       Covered     
UPDR    -       -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       -       Covered     
UPDR    -       -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       -       Covered     
UPDR    -       -       -       -       -       -       -       -       -       default -       -       -       -       -       -       Covered     
CAIR    -       -       -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       Covered     
CAIR    -       -       -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       Covered     
CAIR    -       -       -       -       -       -       -       -       -       -       default -       -       -       -       -       Covered     
SHIR    -       -       -       -       -       -       -       -       -       -       -       HIGH    -       -       -       -       Covered     
SHIR    -       -       -       -       -       -       -       -       -       -       -       LOW     -       -       -       -       Covered     
SHIR    -       -       -       -       -       -       -       -       -       -       -       default -       -       -       -       Not Covered 
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       2'b01   -       -       -       Covered     
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       2'b10   -       -       -       Covered     
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       default -       -       -       Covered     
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       HIGH    -       -       Covered     
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       LOW     -       -       Covered     
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       default -       -       Not Covered 
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b01   -       Covered     
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b10   -       Covered     
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       default -       Covered     
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b01   Covered     
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b10   Covered     
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       default Covered     
default -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered     


646              if (!powergood_rst_trst_b)
                 -1-  
647              begin
648                 tms_bit <= FOUR_BIT_LOW_VALUE;
                    ==>
649              end
650              else if (stap_fsm_tlrs)
                      -2-  
651              begin
652                 tms_bit <= FOUR_BIT_LOW_VALUE;
                    ==>
653              end
654              else
655              begin
656                 tms_bit <= {tms_bit[TWO:0], ftap_tms_internal};
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


667              if (!powergood_rst_trst_b)
                 -1-  
668              begin
669                 state_ps <= TLRS;
                    ==>
670              end
671              else if (soft_reset)
                      -2-  
672              begin
673                 state_ps <= TLRS;
                    ==>
674              end
675              else
676              begin
677                 state_ps <= state_ns;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


697              if (!powergood_rst_trst_b)
                 -1-  
698              begin
699                 stap_fsm_shift_ir_neg <= LOW;
                    ==>
700              end
701              else
702              begin
703                 stap_fsm_shift_ir_neg <= stap_fsm_shift_ir;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


714                  if (!powergood_rst_trst_b)
                     -1-  
715                    stap_selectwir_neg <= LOW;
                       ==>
716                  else
717                    stap_selectwir_neg <= stap_selectwir;
                       ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


721                    if (!powergood_rst_trst_b)
                       -1-  
722                    begin
723                       stap_selectwir <= LOW;
                          ==>
724                    end
725                    else
726                    begin
727                       if (tlrs_present_state)
                          -2-  
728                       begin
729                          stap_selectwir <= LOW;
                             ==>
730                       end
731                       else if (tlrs_next_state)
                               -3-  
732                       begin
733                          stap_selectwir <= LOW;
                             ==>
734                       end
735                       else if ( ruti_present_state | cadr_next_state)
                               -4-  
736                          stap_selectwir <= LOW;
                             ==>
737                       else if (sirs_next_state)
                               -5-  
738                       begin
739                          stap_selectwir <= HIGH;
                             ==>
740                       end
741                       else
742                       begin
743                          stap_selectwir <= stap_selectwir;
                             ==>

Branches:

-1- -2- -3- -4- -5- Status  
1   -   -   -   -   Covered 
0   1   -   -   -   Covered 
0   0   1   -   -   Covered 
0   0   0   1   -   Covered 
0   0   0   0   1   Covered 
0   0   0   0   0   Covered 


778                    if (!powergood_rst_trst_b)
                       -1-  
779                    begin
780                       sn_fwtap_capturewr_neg <= LOW;
                          ==>
781                       sn_fwtap_shiftwr_neg   <= LOW;
782                    end
783                    else if (soft_reset)
                            -2-  
784                    begin
785                       sn_fwtap_capturewr_neg <= LOW;
                          ==>
786                       sn_fwtap_shiftwr_neg   <= LOW;
787                    end
788                    else
789                    begin
790                       sn_fwtap_capturewr_neg <= stap_capturewr_int;
                          ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_fsm 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       3     3         100.00  3                 100.00  
Cover properties 16    16        100.00  13                81.25   
Cover sequences  0     0                 0                         
Total            19    19        100.00  16                84.21   



-------------------------------------------------------------------------------

Assertion Details

Name                                                      Attempts Real Successes Failures Incomplete 
chk_stap_shift_dr_low_when_pause_dr_0                     88842    300            0        0          
chk_stap_shift_ir_low_when_pause_ir_0                     88842    137            0        0          
generate_chk_irscan_glitch.chk_scanir_glitch_free_pulse_0 85370    25315          0        0          


-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                                           Attempts Matches Incomplete 
cov_cap_exit1_pause_exit2_shift                88842    0       0          
cov_cap_exit1_pause_exit2_shift_ir             88842    0       0          
cov_cap_exit1_update                           88842    1       0          
cov_cap_exit1_update_ir                        88842    1       0          
cov_prop_stay_in_padr_for_more_than_one_clk_01 88842    230     0          
cov_prop_stay_in_pair_for_more_than_one_clk_01 88842    90      0          
cov_prop_stay_in_ruti_for_more_than_one_clk_01 88842    4849    0          
cov_prop_stay_in_shdr_for_more_than_one_clk_01 88842    36942   0          
cov_prop_stay_in_shir_for_more_than_one_clk_01 88842    19187   0          
cov_prop_stay_in_tlrs_for_more_than_one_clk_01 88842    8165    8          
cov_prop_transition_from_cadr_to_e1dr_01       88842    18      0          
cov_prop_transition_from_cair_to_e1ir_01       88842    5       0          
cov_prop_transition_from_e1dr_to_updr_01       88842    1266    2          
cov_prop_transition_from_e1ir_to_upir_01       88842    1264    0          
cov_prop_transition_from_e2dr_to_shdr_01       88842    13      0          
cov_prop_transition_from_e2ir_to_shir_01       88842    0       0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_fsm(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 97.37 100.00 100.00 100.00 100.00 100.00  84.21 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 97.37 100.00 100.00 100.00 100.00 100.00  84.21 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                  
 91.97  95.08 100.00  98.60  82.50  91.43  84.21 STAP_RTL_LIB.stap_fsm 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)

             Line No.   Total   Covered  Percent
TOTAL                      116      116   100.00
ALWAYS            325       60       60   100.00
ALWAYS            646        5        5   100.00
ALWAYS            667        5        5   100.00
ALWAYS            697        3        3   100.00
ALWAYS            714        3        3   100.00
ALWAYS            721       11       11   100.00
ALWAYS            778        8        8   100.00
ALWAYS            850        2        2   100.00
ROUTINE           857       19       19   100.00

324                        begin
325        1/1                case (state_ps)
326                           TLRS:
327                           begin
328        1/1                   case (arc_tlrs_ruti)
329                              HIGH:
330                              begin
331        1/1                      state_ns = RUTI;
332                              end
333                              LOW:
334                              begin
335        1/1                      state_ns = TLRS;
336                              end
337                              default:
338                              begin
339        excluded                 state_ns = TLRS;
340                              end
341                              endcase
342                           end
343                           RUTI:
344                           begin
345        1/1                   case (arc_ruti_sdrs)
346                              HIGH:
347                              begin
348        1/1                      state_ns = SDRS;
349                              end
350                              LOW:
351                              begin
352        1/1                      state_ns = RUTI;
353                              end
354                              default:
355                              begin
356        excluded                 state_ns = RUTI;
357                              end
358                              endcase
359                           end
360                           SDRS:
361                           begin
362        1/1                   case (sdrs_cadr_or_sirs)
363                              2'b01:
364                              begin
365        1/1                      state_ns = SIRS;
366                              end
367                              2'b10:
368                              begin
369        1/1                      state_ns = CADR;
370                              end
371                              default:
372                              begin
373        1/1                      state_ns = SDRS;
374                              end
375                              endcase
376                           end
377                           SIRS:
378                           begin
379        1/1                   case (sirs_cair_or_tlrs)
380                              2'b01:
381                              begin
382        1/1                      state_ns = TLRS;
383                              end
384                              2'b10:
385                              begin
386        1/1                      state_ns = CAIR;
387                              end
388                              default:
389                              begin
390        1/1                      state_ns = SIRS;
391                              end
392                              endcase
393                           end
394                           CADR:
395                           begin
396        1/1                   case (cadr_shdr_or_e1dr)
397                              2'b01:
398                              begin
399        1/1                      state_ns = E1DR;
400                              end
401                              2'b10:
402                              begin
403        1/1                      state_ns = SHDR;
404                              end
405                              default:
406                              begin
407        1/1                      state_ns = CADR;
408                              end
409                              endcase
410                           end
411                           SHDR:
412                           begin
413        1/1                   case (arc_shdr_e1dr)
414                              HIGH:
415                              begin
416        1/1                      state_ns = E1DR;
417                              end
418                              LOW:
419                              begin
420        1/1                      state_ns = SHDR;
421                              end
422                              default:
423                              begin
424        excluded                 state_ns = SHDR;
425                              end
426                              endcase
427                           end
428                           E1DR:
429                           begin
430        1/1                   case (e1dr_padr_or_updr)
431                              2'b01:
432                              begin
433        1/1                      state_ns = UPDR;
434                              end
435                              2'b10:
436                              begin
437        1/1                      state_ns = PADR;
438                              end
439                              default:
440                              begin
441        1/1                      state_ns = E1DR;
442                              end
443                              endcase
444                           end
445                           PADR:
446                           begin
447        1/1                   case (arc_padr_e2dr)
448                              HIGH:
449                              begin
450        1/1                      state_ns = E2DR;
451                              end
452                              LOW:
453                              begin
454        1/1                      state_ns = PADR;
455                              end
456                              default:
457                              begin
458        excluded                 state_ns = PADR;
459                              end
460                              endcase
461                           end
462                           E2DR:
463                           begin
464        1/1                   case (e2dr_shdr_or_updr)
465                              2'b01:
466                              begin
467        1/1                      state_ns = UPDR;
468                              end
469                              2'b10:
470                              begin
471        1/1                      state_ns = SHDR;
472                              end
473                              default:
474                              begin
475        1/1                      state_ns = E2DR;
476                              end
477                              endcase
478                           end
479                           UPDR:
480                           begin
481        1/1                   case (updr_ruti_or_sdrs)
482                              2'b01:
483                              begin
484        1/1                      state_ns = SDRS;
485                              end
486                              2'b10:
487                              begin
488        1/1                      state_ns = RUTI;
489                              end
490                              default:
491                              begin
492        1/1                      state_ns = UPDR;
493                              end
494                              endcase
495                           end
496                           CAIR:
497                           begin
498        1/1                   case (cair_shir_or_e1ir)
499                              2'b01:
500                              begin
501        1/1                      state_ns = E1IR;
502                              end
503                              2'b10:
504                              begin
505        1/1                      state_ns = SHIR;
506                              end
507                              default:
508                              begin
509        1/1                      state_ns = CAIR;
510                              end
511                              endcase
512                           end
513                           SHIR:
514                           begin
515        1/1                   case (arc_shir_e1ir)
516                              HIGH:
517                              begin
518        1/1                      state_ns = E1IR;
519                              end
520                              LOW:
521                              begin
522        1/1                      state_ns = SHIR;
523                              end
524                              default:
525                              begin
526        excluded                 state_ns = SHIR;
527                              end
528                              endcase
529                           end
530                           E1IR:
531                           begin
532        1/1                   case (e1ir_pair_or_upir)
533                              2'b01:
534                              begin
535        1/1                      state_ns = UPIR;
536                              end
537                              2'b10:
538                              begin
539        1/1                      state_ns = PAIR;
540                              end
541                              default:
542                              begin
543        1/1                      state_ns = E1IR;
544                              end
545                              endcase
546                           end
547                           PAIR:
548                           begin
549        1/1                   case (arc_pair_e2ir)
550                              HIGH:
551                              begin
552        1/1                      state_ns = E2IR;
553                              end
554                              LOW:
555                              begin
556        1/1                      state_ns = PAIR;
557                              end
558                              default
559                              begin
560        excluded                 state_ns = PAIR;
561                              end
562                              endcase
563                           end
564                           E2IR:
565                           begin
566        1/1                   case (e2ir_shir_or_upir)
567                              2'b01:
568                              begin
569        1/1                      state_ns = UPIR;
570                              end
571                              2'b10:
572                              begin
573        1/1                      state_ns = SHIR;
574                              end
575                              default
576                              begin
577        1/1                      state_ns = E2IR;
578                              end
579                              endcase
580                           end
581                           UPIR:
582                           begin
583        1/1                   case (upir_ruti_or_sdrs)
584                              2'b01:
585                              begin
586        1/1                      state_ns = SDRS;
587                              end
588                              2'b10:
589                              begin
590        1/1                      state_ns = RUTI;
591                              end
592                              default:
593                              begin
594        1/1                      state_ns = UPIR;
595                              end
596                              endcase
597                           end
598                           default:
599                           begin
600        1/1                   state_ns = TLRS;
601                              //state_ns = SIXTEEN_BIT_UNKNOWN_VALUE;
602                           end
603                           endcase
604                        end
605                     
606                        // *********************************************************************
607                        // Remove bit-TMS Logic
608                        // *********************************************************************
609                        assign ftap_tms_internal = (tapc_remove == HIGH) ? HIGH : ftap_tms;
610                     
611                        // *********************************************************************
612                        // FSM arc assignment
613                        // *********************************************************************
614                        assign arc_tlrs_ruti = ~ftap_tms_internal & tlrs_present_state;
615                        assign arc_ruti_sdrs =  ftap_tms_internal & ruti_present_state;
616                        assign arc_sdrs_cadr = ~ftap_tms_internal & sdrs_present_state;
617                        assign arc_cadr_shdr = ~ftap_tms_internal & cadr_present_state;
618                        assign arc_shdr_e1dr =  ftap_tms_internal & shdr_present_state;
619                        assign arc_e1dr_padr = ~ftap_tms_internal & e1dr_present_state;
620                        assign arc_padr_e2dr =  ftap_tms_internal & padr_present_state;
621                        assign arc_e2dr_updr =  ftap_tms_internal & e2dr_present_state;
622                        assign arc_e1dr_updr =  ftap_tms_internal & e1dr_present_state;
623                        assign arc_e2dr_shdr = ~ftap_tms_internal & e2dr_present_state;
624                        assign arc_cadr_e1dr =  ftap_tms_internal & cadr_present_state;
625                        assign arc_updr_sdrs =  ftap_tms_internal & updr_present_state;
626                        assign arc_updr_ruti = ~ftap_tms_internal & updr_present_state;
627                        assign arc_sdrs_sirs =  ftap_tms_internal & sdrs_present_state;
628                        assign arc_sirs_cair = ~ftap_tms_internal & sirs_present_state;
629                        assign arc_cair_shir = ~ftap_tms_internal & cair_present_state;
630                        assign arc_shir_e1ir =  ftap_tms_internal & shir_present_state;
631                        assign arc_e1ir_pair = ~ftap_tms_internal & e1ir_present_state;
632                        assign arc_pair_e2ir =  ftap_tms_internal & pair_present_state;
633                        assign arc_e2ir_upir =  ftap_tms_internal & e2ir_present_state;
634                        assign arc_e1ir_upir =  ftap_tms_internal & e1ir_present_state;
635                        assign arc_e2ir_shir = ~ftap_tms_internal & e2ir_present_state;
636                        assign arc_cair_e1ir =  ftap_tms_internal & cair_present_state;
637                        assign arc_upir_sdrs =  ftap_tms_internal & upir_present_state;
638                        assign arc_upir_ruti = ~ftap_tms_internal & upir_present_state;
639                        assign arc_sirs_tlrs =  ftap_tms_internal & sirs_present_state;
640                     
641                        // *********************************************************************
642                        // Five consecutive TMS=1 causes soft reset
643                        // *********************************************************************
644                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
645                        begin
646        1/1                if (!powergood_rst_trst_b)
647                           begin
648        1/1                   tms_bit <= FOUR_BIT_LOW_VALUE;
649                           end
650        1/1                else if (stap_fsm_tlrs)
651                           begin
652        1/1                   tms_bit <= FOUR_BIT_LOW_VALUE;
653                           end
654                           else
655                           begin
656        1/1                   tms_bit <= {tms_bit[TWO:0], ftap_tms_internal};
657                           end
658                        end
659                     
660                        assign soft_reset = (&tms_bit) & ftap_tms_internal;
661                     
662                        // *********************************************************************
663                        // Present state logic
664                        // *********************************************************************
665                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
666                        begin
667        1/1                if (!powergood_rst_trst_b)
668                           begin
669        1/1                   state_ps <= TLRS;
670                           end
671        1/1                else if (soft_reset)
672                           begin
673        1/1                   state_ps <= TLRS;
674                           end
675                           else
676                           begin
677        1/1                   state_ps <= state_ns;
678                           end
679                        end
680                     
681                        // *********************************************************************
682                        // output port assignment - based on the FSM states
683                        // *********************************************************************
684                        assign stap_fsm_tlrs       = tlrs_present_state;
685                        assign stap_fsm_rti        = ruti_present_state;
686                        assign stap_fsm_e1dr       = e1dr_present_state;
687                        assign stap_fsm_e2dr       = e2dr_present_state;
688                        assign stap_fsm_capture_ir = cair_present_state;
689                        assign stap_fsm_shift_ir   = shir_present_state;
690                        assign stap_fsm_update_ir  = upir_present_state;
691                        assign stap_fsm_capture_dr = cadr_present_state;
692                     
693                        assign stap_fsm_shift_dr   = shdr_present_state;
694                        assign stap_fsm_update_dr  = updr_present_state;
695                     
696                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
697        1/1                if (!powergood_rst_trst_b)
698                           begin
699        1/1                   stap_fsm_shift_ir_neg <= LOW;
700                           end
701                           else
702                           begin
703        1/1                   stap_fsm_shift_ir_neg <= stap_fsm_shift_ir;
704                           end
705                     
706                        // *********************************************************************
707                        // Generation of scan IR (selectwir) signal
708                        // *********************************************************************
709                        generate
710                           if ((FSM_STAP_ENABLE_TAP_NETWORK == 1) || (FSM_STAP_WTAP_COMMON_LOGIC == 1) || (FSM_STAP_ENABLE_REMOTE_TEST_DATA_REGISTERS == 1))
711                           begin:generate_irscan_sig
712                     //kbbhagwa posedge negedge signal merge
713                             always_ff @(negedge  ftap_tck or negedge powergood_rst_trst_b)
714        1/1                    if (!powergood_rst_trst_b)
715        1/1                      stap_selectwir_neg <= LOW;
716                               else
717        1/1                      stap_selectwir_neg <= stap_selectwir;
718                     
719                              always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
720                              begin
721        1/1                      if (!powergood_rst_trst_b)
722                                 begin
723        1/1                         stap_selectwir <= LOW;
724                                 end
725                                 else
726                                 begin
727        1/1                         if (tlrs_present_state)
728                                    begin
729        1/1                            stap_selectwir <= LOW;
730                                    end
731        1/1                         else if (tlrs_next_state)
732                                    begin
733        1/1                            stap_selectwir <= LOW;
734                                    end
735        1/1                         else if ( ruti_present_state | cadr_next_state)
736        1/1                            stap_selectwir <= LOW;
737        1/1                         else if (sirs_next_state)
738                                    begin
739        1/1                            stap_selectwir <= HIGH;
740                                    end
741                                    else
742                                    begin
743        1/1                            stap_selectwir <= stap_selectwir;
744                                    end
745                                 end
746                              end
747                           end
748                           else
749                           begin:generate_irscan_sig
750                              assign stap_selectwir     = LOW;
751                              assign stap_selectwir_neg = LOW; //kbbhagwa posedge negedge signal merge
752                           end
753                        endgenerate
754                     
755                        // *********************************************************************
756                        // code for Glue Logic requirement of stap_selectwir
757                        // *********************************************************************
758                        generate
759                           if (FSM_STAP_WTAP_COMMON_LOGIC == 1)
760                           begin:generate_selectwir_sig
761                              // ---------------------------------------------------------------
762                              // Generation of sn_fwtap_rti, sn_fwtap_capturewr, sn_fwtap_shiftwr and sn_fwtap_updatewr
763                              // ---------------------------------------------------------------
764                              assign sn_fwtap_rti       =  ruti_present_state;
765                              assign stap_capturewr_int = (cair_present_state | cadr_present_state);
766                              assign stap_shiftwr_int   = (shir_present_state | shdr_present_state);
767                              assign sn_fwtap_updatewr  = (upir_present_state | updr_present_state);
768                              // *********************************************************************
769                              // output reset signal generation
770                              // *********************************************************************
771                              assign sn_fwtap_wrst_b = ~stap_fsm_tlrs;
772                              // *********************************************************************
773                              // added negedge floping for capturewr and shiftwr. In accordance with
774                              //   1500 and SoC TAP HAS rev088_rc3
775                              // *********************************************************************
776                              always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
777                              begin
778        1/1                      if (!powergood_rst_trst_b)
779                                 begin
780        1/1                         sn_fwtap_capturewr_neg <= LOW;
781        1/1                         sn_fwtap_shiftwr_neg   <= LOW;
782                                 end
783        1/1                      else if (soft_reset)
784                                 begin
785        1/1                         sn_fwtap_capturewr_neg <= LOW;
786        1/1                         sn_fwtap_shiftwr_neg   <= LOW;
787                                 end
788                                 else
789                                 begin
790        1/1                         sn_fwtap_capturewr_neg <= stap_capturewr_int;
791        1/1                         sn_fwtap_shiftwr_neg   <= stap_shiftwr_int;
792                                 end
793                              end
794                           end
795                           else
796                           begin:generate_selectwir_sig
797                              assign sn_fwtap_rti           = LOW;
798                              assign sn_fwtap_capturewr_neg = LOW;
799                              assign sn_fwtap_shiftwr_neg   = LOW;
800                              assign sn_fwtap_updatewr      = LOW;
801                              assign sn_fwtap_wrst_b        = HIGH;
802                           end
803                        endgenerate
804                     
805                        //**********************************************************************
806                        //Pass posedge of sn_fwtap_capturewr and sn_fwtap_shiftwr cntrl signals
807                        //for WTAP if the parameter FSM_STAP_ENABLE_WTAP_CTRL_POS_EDGE is one
808                        //else pass negedge of the cntrl signals
809                        //**********************************************************************
810                        generate
811                           if (FSM_STAP_ENABLE_WTAP_CTRL_POS_EDGE == 1)
812                           begin:generate_posneg_cntrl_wtap
813                              assign sn_fwtap_capturewr = stap_capturewr_int;
814                              assign sn_fwtap_shiftwr   = stap_shiftwr_int;
815                           end
816                           else
817                           begin:generate_posneg_cntrl_wtap
818                              assign sn_fwtap_capturewr = sn_fwtap_capturewr_neg;
819                              assign sn_fwtap_shiftwr   = sn_fwtap_shiftwr_neg;
820                           end
821                        endgenerate
822                     
823                     
824                        // ====================================================================
825                        `ifdef INTEL_SIMONLY
826                        // ====================================================================
827                        typedef enum logic [15:0] {
828                           tlrs = 16'h0001,
829                           ruti = 16'h0002,
830                           sdrs = 16'h0004,
831                           cadr = 16'h0008,
832                           shdr = 16'h0010,
833                           e1dr = 16'h0020,
834                           padr = 16'h0040,
835                           e2dr = 16'h0080,
836                           updr = 16'h0100,
837                           sirs = 16'h0200,
838                           cair = 16'h0400,
839                           shir = 16'h0800,
840                           e1ir = 16'h1000,
841                           pair = 16'h2000,
842                           e2ir = 16'h4000,
843                           upir = 16'h8000} fsm_states_t;
844                     
845                        fsm_states_t present_state;
846                        fsm_states_t next_state;
847                     
848                        always_comb
849                        begin
850        1/1                present_state = state_str(state_ps);
851        1/1                next_state    = state_str(state_ns);
852                        end
853                     
854                        function automatic fsm_states_t state_str(logic [15:0] state);
855                           begin
856                              fsm_states_t str;
857        1/1                   case (state)
858        1/1                      TLRS:    begin str = tlrs; end
859        1/1                      RUTI:    begin str = ruti; end
860        1/1                      SDRS:    begin str = sdrs; end
861        1/1                      CADR:    begin str = cadr; end
862        1/1                      SHDR:    begin str = shdr; end
863        1/1                      E1DR:    begin str = e1dr; end
864        1/1                      PADR:    begin str = padr; end
865        1/1                      E2DR:    begin str = e2dr; end
866        1/1                      UPDR:    begin str = updr; end
867        1/1                      SIRS:    begin str = sirs; end
868        1/1                      CAIR:    begin str = cair; end
869        1/1                      SHIR:    begin str = shir; end
870        1/1                      E1IR:    begin str = e1ir; end
871        1/1                      PAIR:    begin str = pair; end
872        1/1                      E2IR:    begin str = e2ir; end
873        1/1                      UPIR:    begin str = upir; end
874        1/1                      default: begin str = tlrs; end
875                              endcase
876        1/1                   return str;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       609
 EXPRESSION ((tapc_remove == HIGH) ? HIGH : ftap_tms)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)
                Total Covered Percent 
Totals          102   102     100.00  
Total Bits      348   348     100.00  
Total Bits 0->1 174   174     100.00  
Total Bits 1->0 174   174     100.00  

                            
Ports          21 21 100.00 
Port Bits      42 42 100.00 
Port Bits 0->1 21 21 100.00 
Port Bits 1->0 21 21 100.00 

                                
Signals          81  81  100.00 
Signal Bits      306 306 100.00 
Signal Bits 0->1 153 153 100.00 
Signal Bits 1->0 153 153 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
ftap_tms              Yes      Yes         Yes         INPUT     
ftap_tck              Yes      Yes         Yes         INPUT     
powergood_rst_trst_b  Yes      Yes         Yes         INPUT     
tapc_remove           Excluded Excluded    Excluded    INPUT     
stap_fsm_tlrs         Yes      Yes         Yes         OUTPUT    
stap_fsm_rti          Yes      Yes         Yes         OUTPUT    
stap_fsm_e1dr         Yes      Yes         Yes         OUTPUT    
stap_fsm_e2dr         Yes      Yes         Yes         OUTPUT    
stap_selectwir        Yes      Yes         Yes         OUTPUT    
stap_selectwir_neg    Yes      Yes         Yes         OUTPUT    
sn_fwtap_capturewr    Yes      Yes         Yes         OUTPUT    
sn_fwtap_shiftwr      Yes      Yes         Yes         OUTPUT    
sn_fwtap_updatewr     Yes      Yes         Yes         OUTPUT    
sn_fwtap_rti          Yes      Yes         Yes         OUTPUT    
sn_fwtap_wrst_b       Yes      Yes         Yes         OUTPUT    
stap_fsm_capture_ir   Yes      Yes         Yes         OUTPUT    
stap_fsm_shift_ir     Yes      Yes         Yes         OUTPUT    
stap_fsm_shift_ir_neg Yes      Yes         Yes         OUTPUT    
stap_fsm_update_ir    Yes      Yes         Yes         OUTPUT    
stap_fsm_capture_dr   Yes      Yes         Yes         OUTPUT    
stap_fsm_shift_dr     Yes      Yes         Yes         OUTPUT    
stap_fsm_update_dr    Yes      Yes         Yes         OUTPUT    

Signal Details
                       Toggle   Toggle 1->0 Toggle 0->1 
state_ps[15:0]         Yes      Yes         Yes         
state_ns[15:0]         Yes      Yes         Yes         
tms_bit[3:0]           Yes      Yes         Yes         
arc_tlrs_ruti          Yes      Yes         Yes         
arc_ruti_sdrs          Yes      Yes         Yes         
arc_sdrs_cadr          Yes      Yes         Yes         
arc_cadr_shdr          Yes      Yes         Yes         
arc_shdr_e1dr          Yes      Yes         Yes         
arc_e1dr_padr          Yes      Yes         Yes         
arc_padr_e2dr          Yes      Yes         Yes         
arc_e2dr_updr          Yes      Yes         Yes         
arc_e1dr_updr          Yes      Yes         Yes         
arc_e2dr_shdr          Yes      Yes         Yes         
arc_cadr_e1dr          Yes      Yes         Yes         
arc_updr_sdrs          Yes      Yes         Yes         
arc_updr_ruti          Yes      Yes         Yes         
arc_sdrs_sirs          Yes      Yes         Yes         
arc_sirs_cair          Yes      Yes         Yes         
arc_cair_shir          Yes      Yes         Yes         
arc_shir_e1ir          Yes      Yes         Yes         
arc_e1ir_pair          Yes      Yes         Yes         
arc_pair_e2ir          Yes      Yes         Yes         
arc_e2ir_upir          Yes      Yes         Yes         
arc_e1ir_upir          Yes      Yes         Yes         
arc_e2ir_shir          Excluded Excluded    Excluded    
arc_cair_e1ir          Yes      Yes         Yes         
arc_upir_sdrs          Yes      Yes         Yes         
arc_upir_ruti          Yes      Yes         Yes         
arc_sirs_tlrs          Yes      Yes         Yes         
tlrs_present_state     Yes      Yes         Yes         
ruti_present_state     Yes      Yes         Yes         
sdrs_present_state     Yes      Yes         Yes         
cadr_present_state     Yes      Yes         Yes         
cadr_next_state        Yes      Yes         Yes         
shdr_present_state     Yes      Yes         Yes         
e1dr_present_state     Yes      Yes         Yes         
padr_present_state     Yes      Yes         Yes         
e2dr_present_state     Yes      Yes         Yes         
updr_present_state     Yes      Yes         Yes         
updr_next_state        Yes      Yes         Yes         
sirs_present_state     Yes      Yes         Yes         
cair_present_state     Yes      Yes         Yes         
shir_present_state     Yes      Yes         Yes         
e1ir_present_state     Yes      Yes         Yes         
pair_present_state     Yes      Yes         Yes         
e2ir_present_state     Yes      Yes         Yes         
upir_present_state     Yes      Yes         Yes         
tlrs_next_state        Yes      Yes         Yes         
sirs_next_state        Yes      Yes         Yes         
sdrs_cadr_or_sirs[1:0] Yes      Yes         Yes         
sirs_cair_or_tlrs[1:0] Yes      Yes         Yes         
cadr_shdr_or_e1dr[1:0] Yes      Yes         Yes         
e1dr_padr_or_updr[1:0] Yes      Yes         Yes         
e2dr_shdr_or_updr[1:0] Yes      Yes         Yes         
updr_ruti_or_sdrs[1:0] Yes      Yes         Yes         
cair_shir_or_e1ir[1:0] Yes      Yes         Yes         
e1ir_pair_or_upir[1:0] Yes      Yes         Yes         
e2ir_shir_or_upir[1:0] Excluded Excluded    Excluded    
upir_ruti_or_sdrs[1:0] Yes      Yes         Yes         
soft_reset             Yes      Yes         Yes         
ftap_tms_internal      Yes      Yes         Yes         
stap_capturewr_int     Yes      Yes         Yes         
stap_shiftwr_int       Yes      Yes         Yes         
sn_fwtap_capturewr_neg Yes      Yes         Yes         
sn_fwtap_shiftwr_neg   Yes      Yes         Yes         
present_state[15:0]    Yes      Yes         Yes         
next_state[15:0]       Yes      Yes         Yes         
Tlrs                   Yes      Yes         Yes         
Ruti                   Yes      Yes         Yes         
Sdrs                   Yes      Yes         Yes         
Cadr                   Yes      Yes         Yes         
Shdr                   Yes      Yes         Yes         
E1dr                   Yes      Yes         Yes         
Padr                   Yes      Yes         Yes         
E2dr                   Yes      Yes         Yes         
Updr                   Yes      Yes         Yes         
Sirs                   Yes      Yes         Yes         
Cair                   Yes      Yes         Yes         
Shir                   Yes      Yes         Yes         
E1ir                   Yes      Yes         Yes         
Pair                   Yes      Yes         Yes         
E2ir                   Yes      Yes         Yes         
Upir                   Yes      Yes         Yes         


-------------------------------------------------------------------------------
FSM Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)
Summary for FSM :: state_ps
            Total Covered Percent                         
States      16    16      100.00  (Not included in score) 
Transitions 25    25      100.00                          
Sequences   0     0                                       

State, Transition and Sequence Details for FSM :: state_ps
-------------------------------------------------------------------------------
states Line No. Covered 
TLRS   331      Covered 
RUTI   331      Covered 
SDRS   348      Covered 
CADR   369      Covered 
SHDR   403      Covered 
E1DR   399      Covered 
PADR   437      Covered 
E2DR   450      Covered 
UPDR   433      Covered 
SIRS   365      Covered 
CAIR   386      Covered 
SHIR   505      Covered 
E1IR   501      Covered 
PAIR   539      Covered 
E2IR   552      Covered 
UPIR   535      Covered 

transitions Line No. Covered  
TLRS->RUTI  331      Covered  
RUTI->TLRS  669      Excluded 
RUTI->SDRS  348      Covered  
SDRS->TLRS  669      Excluded 
SDRS->CADR  369      Covered  
SDRS->SIRS  365      Covered  
CADR->TLRS  669      Excluded 
CADR->SHDR  403      Covered  
CADR->E1DR  399      Covered  
SHDR->TLRS  669      Excluded 
SHDR->E1DR  416      Covered  
E1DR->TLRS  669      Excluded 
E1DR->PADR  437      Covered  
E1DR->UPDR  433      Covered  
PADR->TLRS  669      Excluded 
PADR->E2DR  450      Covered  
E2DR->TLRS  669      Excluded 
E2DR->SHDR  471      Covered  
E2DR->UPDR  467      Covered  
UPDR->TLRS  669      Excluded 
UPDR->RUTI  488      Covered  
UPDR->SDRS  484      Covered  
SIRS->TLRS  382      Covered  
SIRS->CAIR  386      Covered  
CAIR->TLRS  669      Excluded 
CAIR->SHIR  505      Covered  
CAIR->E1IR  501      Covered  
SHIR->TLRS  669      Excluded 
SHIR->E1IR  518      Covered  
E1IR->TLRS  669      Excluded 
E1IR->PAIR  539      Covered  
E1IR->UPIR  535      Covered  
PAIR->TLRS  669      Excluded 
PAIR->E2IR  552      Covered  
E2IR->TLRS  669      Excluded 
E2IR->SHIR  573      Excluded 
E2IR->UPIR  569      Covered  
UPIR->TLRS  669      Excluded 
UPIR->RUTI  590      Covered  
UPIR->SDRS  586      Covered  

sequences Covered 


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)
         Line No. Total Covered Percent 
Branches          64    64      100.00  
TERNARY  609      2     2       100.00  
CASE     325      43    43      100.00  
IF       646      3     3       100.00  
IF       667      3     3       100.00  
IF       697      2     2       100.00  
IF       714      2     2       100.00  
IF       721      6     6       100.00  
IF       778      3     3       100.00  


609           assign ftap_tms_internal = (tapc_remove == HIGH) ? HIGH : ftap_tms;
                                                               -1-  
                                                               ==>  
                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


325              case (state_ps)
                 -1-  
326              TLRS:
327              begin
328                 case (arc_tlrs_ruti)
                    -2-  
329                 HIGH:
330                 begin
331                    state_ns = RUTI;
                       ==>
332                 end
333                 LOW:
334                 begin
335                    state_ns = TLRS;
                       ==>
336                 end
337                 default:
338                 begin
339                    state_ns = TLRS;
                       ==> (Excluded)
340                 end
341                 endcase
342              end
343              RUTI:
344              begin
345                 case (arc_ruti_sdrs)
                    -3-  
346                 HIGH:
347                 begin
348                    state_ns = SDRS;
                       ==>
349                 end
350                 LOW:
351                 begin
352                    state_ns = RUTI;
                       ==>
353                 end
354                 default:
355                 begin
356                    state_ns = RUTI;
                       ==> (Excluded)
357                 end
358                 endcase
359              end
360              SDRS:
361              begin
362                 case (sdrs_cadr_or_sirs)
                    -4-  
363                 2'b01:
364                 begin
365                    state_ns = SIRS;
                       ==>
366                 end
367                 2'b10:
368                 begin
369                    state_ns = CADR;
                       ==>
370                 end
371                 default:
372                 begin
373                    state_ns = SDRS;
                       ==>
374                 end
375                 endcase
376              end
377              SIRS:
378              begin
379                 case (sirs_cair_or_tlrs)
                    -5-  
380                 2'b01:
381                 begin
382                    state_ns = TLRS;
                       ==>
383                 end
384                 2'b10:
385                 begin
386                    state_ns = CAIR;
                       ==>
387                 end
388                 default:
389                 begin
390                    state_ns = SIRS;
                       ==>
391                 end
392                 endcase
393              end
394              CADR:
395              begin
396                 case (cadr_shdr_or_e1dr)
                    -6-  
397                 2'b01:
398                 begin
399                    state_ns = E1DR;
                       ==>
400                 end
401                 2'b10:
402                 begin
403                    state_ns = SHDR;
                       ==>
404                 end
405                 default:
406                 begin
407                    state_ns = CADR;
                       ==>
408                 end
409                 endcase
410              end
411              SHDR:
412              begin
413                 case (arc_shdr_e1dr)
                    -7-  
414                 HIGH:
415                 begin
416                    state_ns = E1DR;
                       ==>
417                 end
418                 LOW:
419                 begin
420                    state_ns = SHDR;
                       ==>
421                 end
422                 default:
423                 begin
424                    state_ns = SHDR;
                       ==> (Excluded)
425                 end
426                 endcase
427              end
428              E1DR:
429              begin
430                 case (e1dr_padr_or_updr)
                    -8-  
431                 2'b01:
432                 begin
433                    state_ns = UPDR;
                       ==>
434                 end
435                 2'b10:
436                 begin
437                    state_ns = PADR;
                       ==>
438                 end
439                 default:
440                 begin
441                    state_ns = E1DR;
                       ==>
442                 end
443                 endcase
444              end
445              PADR:
446              begin
447                 case (arc_padr_e2dr)
                    -9-  
448                 HIGH:
449                 begin
450                    state_ns = E2DR;
                       ==>
451                 end
452                 LOW:
453                 begin
454                    state_ns = PADR;
                       ==>
455                 end
456                 default:
457                 begin
458                    state_ns = PADR;
                       ==> (Excluded)
459                 end
460                 endcase
461              end
462              E2DR:
463              begin
464                 case (e2dr_shdr_or_updr)
                    -10-  
465                 2'b01:
466                 begin
467                    state_ns = UPDR;
                       ==>
468                 end
469                 2'b10:
470                 begin
471                    state_ns = SHDR;
                       ==>
472                 end
473                 default:
474                 begin
475                    state_ns = E2DR;
                       ==>
476                 end
477                 endcase
478              end
479              UPDR:
480              begin
481                 case (updr_ruti_or_sdrs)
                    -11-  
482                 2'b01:
483                 begin
484                    state_ns = SDRS;
                       ==>
485                 end
486                 2'b10:
487                 begin
488                    state_ns = RUTI;
                       ==>
489                 end
490                 default:
491                 begin
492                    state_ns = UPDR;
                       ==>
493                 end
494                 endcase
495              end
496              CAIR:
497              begin
498                 case (cair_shir_or_e1ir)
                    -12-  
499                 2'b01:
500                 begin
501                    state_ns = E1IR;
                       ==>
502                 end
503                 2'b10:
504                 begin
505                    state_ns = SHIR;
                       ==>
506                 end
507                 default:
508                 begin
509                    state_ns = CAIR;
                       ==>
510                 end
511                 endcase
512              end
513              SHIR:
514              begin
515                 case (arc_shir_e1ir)
                    -13-  
516                 HIGH:
517                 begin
518                    state_ns = E1IR;
                       ==>
519                 end
520                 LOW:
521                 begin
522                    state_ns = SHIR;
                       ==>
523                 end
524                 default:
525                 begin
526                    state_ns = SHIR;
                       ==> (Excluded)
527                 end
528                 endcase
529              end
530              E1IR:
531              begin
532                 case (e1ir_pair_or_upir)
                    -14-  
533                 2'b01:
534                 begin
535                    state_ns = UPIR;
                       ==>
536                 end
537                 2'b10:
538                 begin
539                    state_ns = PAIR;
                       ==>
540                 end
541                 default:
542                 begin
543                    state_ns = E1IR;
                       ==>
544                 end
545                 endcase
546              end
547              PAIR:
548              begin
549                 case (arc_pair_e2ir)
                    -15-  
550                 HIGH:
551                 begin
552                    state_ns = E2IR;
                       ==>
553                 end
554                 LOW:
555                 begin
556                    state_ns = PAIR;
                       ==>
557                 end
558                 default
559                 begin
560                    state_ns = PAIR;
                       ==> (Excluded)
561                 end
562                 endcase
563              end
564              E2IR:
565              begin
566                 case (e2ir_shir_or_upir)
                    -16-  
567                 2'b01:
568                 begin
569                    state_ns = UPIR;
                       ==>
570                 end
571                 2'b10:
572                 begin
573                    state_ns = SHIR;
                       ==>
574                 end
575                 default
576                 begin
577                    state_ns = E2IR;
                       ==>
578                 end
579                 endcase
580              end
581              UPIR:
582              begin
583                 case (upir_ruti_or_sdrs)
                    -17-  
584                 2'b01:
585                 begin
586                    state_ns = SDRS;
                       ==>
587                 end
588                 2'b10:
589                 begin
590                    state_ns = RUTI;
                       ==>
591                 end
592                 default:
593                 begin
594                    state_ns = UPIR;
                       ==>
595                 end
596                 endcase
597              end
598              default:
599              begin
600                 state_ns = TLRS;
                    ==>

Branches:

-1-     -2-     -3-     -4-     -5-     -6-     -7-     -8-     -9-     -10-    -11-    -12-    -13-    -14-    -15-    -16-    -17-    Status   
TLRS    HIGH    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
TLRS    LOW     -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
TLRS    default -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Excluded 
RUTI    -       HIGH    -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
RUTI    -       LOW     -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
RUTI    -       default -       -       -       -       -       -       -       -       -       -       -       -       -       -       Excluded 
SDRS    -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
SDRS    -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
SDRS    -       -       default -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  
SIRS    -       -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       -       Covered  
SIRS    -       -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       -       Covered  
SIRS    -       -       -       default -       -       -       -       -       -       -       -       -       -       -       -       Covered  
CADR    -       -       -       -       2'b01   -       -       -       -       -       -       -       -       -       -       -       Covered  
CADR    -       -       -       -       2'b10   -       -       -       -       -       -       -       -       -       -       -       Covered  
CADR    -       -       -       -       default -       -       -       -       -       -       -       -       -       -       -       Covered  
SHDR    -       -       -       -       -       HIGH    -       -       -       -       -       -       -       -       -       -       Covered  
SHDR    -       -       -       -       -       LOW     -       -       -       -       -       -       -       -       -       -       Covered  
SHDR    -       -       -       -       -       default -       -       -       -       -       -       -       -       -       -       Excluded 
E1DR    -       -       -       -       -       -       2'b01   -       -       -       -       -       -       -       -       -       Covered  
E1DR    -       -       -       -       -       -       2'b10   -       -       -       -       -       -       -       -       -       Covered  
E1DR    -       -       -       -       -       -       default -       -       -       -       -       -       -       -       -       Covered  
PADR    -       -       -       -       -       -       -       HIGH    -       -       -       -       -       -       -       -       Covered  
PADR    -       -       -       -       -       -       -       LOW     -       -       -       -       -       -       -       -       Covered  
PADR    -       -       -       -       -       -       -       default -       -       -       -       -       -       -       -       Excluded 
E2DR    -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       -       -       Covered  
E2DR    -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       -       -       Covered  
E2DR    -       -       -       -       -       -       -       -       default -       -       -       -       -       -       -       Covered  
UPDR    -       -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       -       Covered  
UPDR    -       -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       -       Covered  
UPDR    -       -       -       -       -       -       -       -       -       default -       -       -       -       -       -       Covered  
CAIR    -       -       -       -       -       -       -       -       -       -       2'b01   -       -       -       -       -       Covered  
CAIR    -       -       -       -       -       -       -       -       -       -       2'b10   -       -       -       -       -       Covered  
CAIR    -       -       -       -       -       -       -       -       -       -       default -       -       -       -       -       Covered  
SHIR    -       -       -       -       -       -       -       -       -       -       -       HIGH    -       -       -       -       Covered  
SHIR    -       -       -       -       -       -       -       -       -       -       -       LOW     -       -       -       -       Covered  
SHIR    -       -       -       -       -       -       -       -       -       -       -       default -       -       -       -       Excluded 
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       2'b01   -       -       -       Covered  
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       2'b10   -       -       -       Covered  
E1IR    -       -       -       -       -       -       -       -       -       -       -       -       default -       -       -       Covered  
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       HIGH    -       -       Covered  
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       LOW     -       -       Covered  
PAIR    -       -       -       -       -       -       -       -       -       -       -       -       -       default -       -       Excluded 
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b01   -       Covered  
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b10   -       Covered  
E2IR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       default -       Covered  
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b01   Covered  
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       2'b10   Covered  
UPIR    -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       default Covered  
default -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       -       Covered  


646              if (!powergood_rst_trst_b)
                 -1-  
647              begin
648                 tms_bit <= FOUR_BIT_LOW_VALUE;
                    ==>
649              end
650              else if (stap_fsm_tlrs)
                      -2-  
651              begin
652                 tms_bit <= FOUR_BIT_LOW_VALUE;
                    ==>
653              end
654              else
655              begin
656                 tms_bit <= {tms_bit[TWO:0], ftap_tms_internal};
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


667              if (!powergood_rst_trst_b)
                 -1-  
668              begin
669                 state_ps <= TLRS;
                    ==>
670              end
671              else if (soft_reset)
                      -2-  
672              begin
673                 state_ps <= TLRS;
                    ==>
674              end
675              else
676              begin
677                 state_ps <= state_ns;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


697              if (!powergood_rst_trst_b)
                 -1-  
698              begin
699                 stap_fsm_shift_ir_neg <= LOW;
                    ==>
700              end
701              else
702              begin
703                 stap_fsm_shift_ir_neg <= stap_fsm_shift_ir;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


714                  if (!powergood_rst_trst_b)
                     -1-  
715                    stap_selectwir_neg <= LOW;
                       ==>
716                  else
717                    stap_selectwir_neg <= stap_selectwir;
                       ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


721                    if (!powergood_rst_trst_b)
                       -1-  
722                    begin
723                       stap_selectwir <= LOW;
                          ==>
724                    end
725                    else
726                    begin
727                       if (tlrs_present_state)
                          -2-  
728                       begin
729                          stap_selectwir <= LOW;
                             ==>
730                       end
731                       else if (tlrs_next_state)
                               -3-  
732                       begin
733                          stap_selectwir <= LOW;
                             ==>
734                       end
735                       else if ( ruti_present_state | cadr_next_state)
                               -4-  
736                          stap_selectwir <= LOW;
                             ==>
737                       else if (sirs_next_state)
                               -5-  
738                       begin
739                          stap_selectwir <= HIGH;
                             ==>
740                       end
741                       else
742                       begin
743                          stap_selectwir <= stap_selectwir;
                             ==>

Branches:

-1- -2- -3- -4- -5- Status  
1   -   -   -   -   Covered 
0   1   -   -   -   Covered 
0   0   1   -   -   Covered 
0   0   0   1   -   Covered 
0   0   0   0   1   Covered 
0   0   0   0   0   Covered 


778                    if (!powergood_rst_trst_b)
                       -1-  
779                    begin
780                       sn_fwtap_capturewr_neg <= LOW;
                          ==>
781                       sn_fwtap_shiftwr_neg   <= LOW;
782                    end
783                    else if (soft_reset)
                            -2-  
784                    begin
785                       sn_fwtap_capturewr_neg <= LOW;
                          ==>
786                       sn_fwtap_shiftwr_neg   <= LOW;
787                    end
788                    else
789                    begin
790                       sn_fwtap_capturewr_neg <= stap_capturewr_int;
                          ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.i_stap_fsm(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       3     3         100.00  3                 100.00  
Cover properties 16    16        100.00  13                81.25   
Cover sequences  0     0                 0                         
Total            19    19        100.00  16                84.21   



-------------------------------------------------------------------------------

Assertion Details

Name                                                      Attempts Real Successes Failures Incomplete 
chk_stap_shift_dr_low_when_pause_dr_0                     88842    300            0        0          
chk_stap_shift_ir_low_when_pause_ir_0                     88842    137            0        0          
generate_chk_irscan_glitch.chk_scanir_glitch_free_pulse_0 85370    25315          0        0          


-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                                           Attempts Matches Incomplete 
cov_cap_exit1_pause_exit2_shift                88842    0       0          
cov_cap_exit1_pause_exit2_shift_ir             88842    0       0          
cov_cap_exit1_update                           88842    1       0          
cov_cap_exit1_update_ir                        88842    1       0          
cov_prop_stay_in_padr_for_more_than_one_clk_01 88842    230     0          
cov_prop_stay_in_pair_for_more_than_one_clk_01 88842    90      0          
cov_prop_stay_in_ruti_for_more_than_one_clk_01 88842    4849    0          
cov_prop_stay_in_shdr_for_more_than_one_clk_01 88842    36942   0          
cov_prop_stay_in_shir_for_more_than_one_clk_01 88842    19187   0          
cov_prop_stay_in_tlrs_for_more_than_one_clk_01 88842    8165    8          
cov_prop_transition_from_cadr_to_e1dr_01       88842    18      0          
cov_prop_transition_from_cair_to_e1ir_01       88842    5       0          
cov_prop_transition_from_e1dr_to_updr_01       88842    1266    2          
cov_prop_transition_from_e1ir_to_upir_01       88842    1264    0          
cov_prop_transition_from_e2dr_to_shdr_01       88842    13      0          
cov_prop_transition_from_e2ir_to_shir_01       88842    0       0          


===============================================================================
Module : STAP_RTL_LIB.stap_decoder
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 92.10  90.91 100.00  87.50 --      90.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_decoder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                      
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x) 
100.00 100.00 --     100.00 --     --     --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x) 
100.00 100.00 --     100.00 --     --     --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x) 
--     --     --     --     --     --     --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[24].i_stap_decoder(X) 
--     --     --     --     --     --     --     top.stap_top_inst.i_stap_irdecoder.generate_decoder[25].i_stap_decoder(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_decoder 

             Line No.   Total   Covered  Percent
TOTAL                       11       10    90.91
ALWAYS            112       11       10    90.91

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        1/1                if (feature_red_en)
116        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        1/1                  decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        1/1                if (ornage_en)
123        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        1/1                  decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        0/1     ==>        decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_decoder 

               Total   Covered  Percent
Conditions          6        6   100.00
Logical             6        6   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_decoder 
                Total Covered Percent 
Totals          8     6       75.00   
Total Bits      48    42      87.50   
Total Bits 0->1 24    21      87.50   
Total Bits 1->0 24    21      87.50   

                            
Ports          5  5  100.00 
Port Bits      40 40 100.00 
Port Bits 0->1 20 20 100.00 
Port Bits 1->0 20 20 100.00 

                            
Signals          3 1 33.33  
Signal Bits      8 2 25.00  
Signal Bits 0->1 4 1 25.00  
Signal Bits 1->0 4 1 25.00  

Port Details
                      Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes    Yes         Yes         INPUT     
decoder_drselect      Yes    Yes         Yes         OUTPUT    
feature_green_en      Yes    Yes         Yes         INPUT     
feature_orange_en     Yes    Yes         Yes         INPUT     
feature_red_en        Yes    Yes         Yes         INPUT     

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
security_level[1:0] No     No          No          
green_en            No     No          No          
ornage_en           Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_decoder 
         Line No. Total Covered Percent 
Branches          10    9       90.00   
CASE     112      10    9       90.00   


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==>  
                                                                                         ==>  
117              else
118                decoder_drselect = LOW;
                   ==>
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==>  
                                                                                         ==>  
124              else
125                decoder_drselect = LOW;
                   ==>
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==>

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status      
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Covered     
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Covered     
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Covered     
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Covered     
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Covered     
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Covered     
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered     
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered     
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered     
default                     -   -   -   -   -   -   Not Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[0].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[1].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[2].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[3].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[4].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[5].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[6].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[7].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[8].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[9].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[10].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[11].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[12].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        1/1                if (ornage_en)
123        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        1/1                  decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[13].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==>  
                                                                                         ==>  
124              else
125                decoder_drselect = LOW;
                   ==>
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        1/1                if (ornage_en)
123        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        1/1                  decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[14].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==>  
                                                                                         ==>  
124              else
125                decoder_drselect = LOW;
                   ==>
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[15].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[16].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[17].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        1/1                if (green_en)
130        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        1/1                   decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[18].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==>  
                                                                                         ==>  
131              else
132                 decoder_drselect = LOW;
                    ==>
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Covered  
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Covered  
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        1        1   100.00
ALWAYS            112        1        1   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          0        0
Logical             0        0
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[19].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          0     0               
CASE     112      0     0               


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        1        1   100.00
ALWAYS            112        1        1   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        excluded           if (feature_red_en)
116        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        excluded             decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          0        0
Logical             0        0
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[20].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          0     0               
CASE     112      0     0               


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
117              else
118                decoder_drselect = LOW;
                   ==> (Excluded)
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Excluded 
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        1/1                if (feature_red_en)
116        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        1/1                  decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[21].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==>  
                                                                                         ==>  
117              else
118                decoder_drselect = LOW;
                   ==>
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        1/1                if (feature_red_en)
116        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        1/1                  decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[22].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==>  
                                                                                         ==>  
117              else
118                decoder_drselect = LOW;
                   ==>
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
 92.10  90.91 100.00  87.50 --      90.00 --     STAP_RTL_LIB.stap_decoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x)

             Line No.   Total   Covered  Percent
TOTAL                        4        4   100.00
ALWAYS            112        4        4   100.00

111                       begin
112        1/1              case (security_level)
113                         DECODER_STAP_SECURE_RED:
114                         begin
115        1/1                if (feature_red_en)
116        1/1                  decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
117                           else
118        1/1                  decoder_drselect = LOW;
119                         end
120                         DECODER_STAP_SECURE_ORANGE:
121                         begin
122        excluded           if (ornage_en)
123        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
124                           else
125        excluded             decoder_drselect = LOW;
126                         end
127                         DECODER_STAP_SECURE_GREEN:
128                         begin
129        excluded           if (green_en)
130        excluded             decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
131                           else
132        excluded              decoder_drselect = LOW;
133                         end
134                         default:
135                         begin
136        excluded           decoder_drselect = LOW;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x)

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       116
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       123
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

 LINE       130
 EXPRESSION ((stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x)
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      40    40      100.00  
Total Bits 0->1 20    20      100.00  
Total Bits 1->0 20    20      100.00  

                            
Ports          4  4  100.00 
Port Bits      38 38 100.00 
Port Bits 0->1 19 19 100.00 
Port Bits 1->0 19 19 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                      Toggle   Toggle 1->0 Toggle 0->1 Direction 
stap_irreg_ireg[15:0] Yes      Yes         Yes         INPUT     
decoder_drselect      Yes      Yes         Yes         OUTPUT    
feature_green_en      Yes      Yes         Yes         INPUT     
feature_orange_en     Excluded Excluded    Excluded    INPUT     
feature_red_en        Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle   Toggle 1->0 Toggle 0->1 
security_level[1:0] Excluded Excluded    Excluded    
green_en            Excluded Excluded    Excluded    
ornage_en           Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder.generate_decoder[23].i_stap_decoder(x)
         Line No. Total Covered Percent 
Branches          3     3       100.00  
CASE     112      3     3       100.00  


112            case (security_level)
               -1-  
113            DECODER_STAP_SECURE_RED:
114            begin
115              if (feature_red_en)
                 -2-  
116                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -3-  
                                                                                         ==>  
                                                                                         ==>  
117              else
118                decoder_drselect = LOW;
                   ==>
119            end
120            DECODER_STAP_SECURE_ORANGE:
121            begin
122              if (ornage_en)
                 -4-  
123                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -5-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
124              else
125                decoder_drselect = LOW;
                   ==> (Excluded)
126            end
127            DECODER_STAP_SECURE_GREEN:
128            begin
129              if (green_en)
                 -6-  
130                decoder_drselect = (stap_irreg_ireg == DECODER_INSTRUCTION_TO_DECODE) ? HIGH : LOW;
                                                                                         -7-  
                                                                                         ==> (Excluded)  
                                                                                         ==> (Excluded)  
131              else
132                 decoder_drselect = LOW;
                    ==> (Excluded)
133            end
134            default:
135            begin
136              decoder_drselect = LOW;
                 ==> (Excluded)

Branches:

-1-                         -2- -3- -4- -5- -6- -7- Status   
DECODER_STAP_SECURE_RED     1   1   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     1   0   -   -   -   -   Covered  
DECODER_STAP_SECURE_RED     0   -   -   -   -   -   Covered  
DECODER_STAP_SECURE_ORANGE  -   -   1   1   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   1   0   -   -   Excluded 
DECODER_STAP_SECURE_ORANGE  -   -   0   -   -   -   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   1   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   1   0   Excluded 
DECODER_STAP_SECURE_GREEN   -   -   -   -   0   -   Excluded 
default                     -   -   -   -   -   -   Excluded 


===============================================================================
Module : STAP_RTL_LIB.ctech_lib_clk_gate_te
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 93.33 100.00 --      80.00 --     100.00 --     

Source File(s) : 

/p/hdk/cad/ctech/c2v16ww47e_hdk141/source/v/ctech_lib_clk_gate_te.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                                                  
100.00 100.00 --     100.00 --     100.00 --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse.i_ctech_lib_clk_gate_te(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_gate_te 

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ALWAYS             22        2        2   100.00

21                        always_latch
22         1/1               if (~clk)
23         1/1                  q <= en|te;
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_gate_te 
                Total Covered Percent 
Totals          5     4       80.00   
Total Bits      10    8       80.00   
Total Bits 0->1 5     4       80.00   
Total Bits 1->0 5     4       80.00   

                          
Ports          4 3 75.00  
Port Bits      8 6 75.00  
Port Bits 0->1 4 3 75.00  
Port Bits 1->0 4 3 75.00  

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clkout Yes    Yes         Yes         OUTPUT    
clk    Yes    Yes         Yes         INPUT     
en     Yes    Yes         Yes         INPUT     
te     No     No          No          INPUT     

Signal Details
  Toggle Toggle 1->0 Toggle 0->1 
q Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_gate_te 
         Line No. Total Covered Percent 
Branches          2     2       100.00  
IF       22       2     2       100.00  


22              if (~clk)
                -1-  
23                 q <= en|te;
                   ==>
                   MISSING_ELSE
                   ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse.i_ctech_lib_clk_gate_te(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
 93.33 100.00 --      80.00 --     100.00 --     STAP_RTL_LIB.ctech_lib_clk_gate_te 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                       
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_gate_te_trainpulse(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse.i_ctech_lib_clk_gate_te(x)

             Line No.   Total   Covered  Percent
TOTAL                        2        2   100.00
ALWAYS             22        2        2   100.00

21                        always_latch
22         1/1               if (~clk)
23         1/1                  q <= en|te;
                        MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse.i_ctech_lib_clk_gate_te(x)
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
       Toggle   Toggle 1->0 Toggle 0->1 Direction 
clkout Yes      Yes         Yes         OUTPUT    
clk    Yes      Yes         Yes         INPUT     
en     Yes      Yes         Yes         INPUT     
te     Excluded Excluded    Excluded    INPUT     

Signal Details
  Toggle Toggle 1->0 Toggle 0->1 
q Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_gate_te_trainpulse.i_ctech_lib_clk_gate_te(x)
         Line No. Total Covered Percent 
Branches          2     2       100.00  
IF       22       2     2       100.00  


22              if (~clk)
                -1-  
23                 q <= en|te;
                   ==>
                   MISSING_ELSE
                   ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


===============================================================================
Module : STAP_RTL_LIB.stap
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 96.23 --     --      96.23 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                 
 99.88 --     --      99.88 --     --     --     top.stap_top_inst(x) 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap 
                Total Covered Percent 
Totals          110   104     94.55   
Total Bits      848   816     96.23   
Total Bits 0->1 424   409     96.46   
Total Bits 1->0 424   407     95.99   

                              
Ports          73  72  98.63  
Port Bits      532 530 99.62  
Port Bits 0->1 266 265 99.62  
Port Bits 1->0 266 265 99.62  

                                
Signals          37  32  86.49  
Signal Bits      316 286 90.51  
Signal Bits 0->1 158 144 91.14  
Signal Bits 1->0 158 142 89.87  

Port Details
                            Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                    Yes    Yes         Yes         INPUT     
ftap_tms                    Yes    Yes         Yes         INPUT     
ftap_trst_b                 Yes    Yes         Yes         INPUT     
ftap_tdi                    Yes    Yes         Yes         INPUT     
ftap_slvidcode[31:0]        Yes    Yes         Yes         INPUT     
atap_tdo                    Yes    Yes         Yes         OUTPUT    
atap_tdoen                  Yes    Yes         Yes         OUTPUT    
fdfx_powergood              Yes    Yes         Yes         INPUT     
tdr_data_out[63:0]          Yes    Yes         Yes         OUTPUT    
tdr_data_in[63:0]           Yes    Yes         Yes         INPUT     
fdfx_secure_policy[2:0]     Yes    Yes         Yes         INPUT     
fdfx_secure_policy[3]       No     No          No          INPUT     
fdfx_earlyboot_exit         Yes    Yes         Yes         INPUT     
fdfx_policy_update          Yes    Yes         Yes         INPUT     
sftapnw_ftap_secsel[3:0]    Yes    Yes         Yes         OUTPUT    
sftapnw_ftap_enabletdo[3:0] Yes    Yes         Yes         OUTPUT    
sftapnw_ftap_enabletap[3:0] Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tck            Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tms            Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_trst_b         Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tdi            Yes    Yes         Yes         OUTPUT    
sntapnw_atap_tdo            Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo_en[3:0]    Yes    Yes         Yes         INPUT     
ftapsslv_tck                Yes    Yes         Yes         INPUT     
ftapsslv_tms                Yes    Yes         Yes         INPUT     
ftapsslv_trst_b             Yes    Yes         Yes         INPUT     
ftapsslv_tdi                Yes    Yes         Yes         INPUT     
atapsslv_tdo                Yes    Yes         Yes         OUTPUT    
atapsslv_tdoen              Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tck2           Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tms2           Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_trst2_b        Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tdi2           Yes    Yes         Yes         OUTPUT    
sntapnw_atap_tdo2           Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo2_en[3:0]   Yes    Yes         Yes         INPUT     
sn_fwtap_wrck               Yes    Yes         Yes         OUTPUT    
sn_fwtap_wrst_b             Yes    Yes         Yes         OUTPUT    
sn_fwtap_capturewr          Yes    Yes         Yes         OUTPUT    
sn_fwtap_shiftwr            Yes    Yes         Yes         OUTPUT    
sn_fwtap_updatewr           Yes    Yes         Yes         OUTPUT    
sn_fwtap_rti                Yes    Yes         Yes         OUTPUT    
sn_fwtap_selectwir          Yes    Yes         Yes         OUTPUT    
sn_awtap_wso[2:0]           Yes    Yes         Yes         INPUT     
sn_fwtap_wsi[2:0]           Yes    Yes         Yes         OUTPUT    
stap_fbscan_tck             Yes    Yes         Yes         OUTPUT    
stap_abscan_tdo             Yes    Yes         Yes         INPUT     
stap_fbscan_capturedr       Yes    Yes         Yes         OUTPUT    
stap_fbscan_shiftdr         Yes    Yes         Yes         OUTPUT    
stap_fbscan_updatedr        Yes    Yes         Yes         OUTPUT    
stap_fbscan_updatedr_clk    Yes    Yes         Yes         OUTPUT    
stap_fbscan_runbist_en      Yes    Yes         Yes         OUTPUT    
stap_fbscan_highz           Yes    Yes         Yes         OUTPUT    
stap_fbscan_extogen         Yes    Yes         Yes         OUTPUT    
stap_fbscan_intest_mode     Yes    Yes         Yes         OUTPUT    
stap_fbscan_chainen         Yes    Yes         Yes         OUTPUT    
stap_fbscan_mode            Yes    Yes         Yes         OUTPUT    
stap_fbscan_extogsig_b      Yes    Yes         Yes         OUTPUT    
stap_fsm_tlrs               Yes    Yes         Yes         OUTPUT    
ftap_pwrdomain_rst_b        Yes    Yes         Yes         INPUT     
stap_fbscan_d6init          Yes    Yes         Yes         OUTPUT    
stap_fbscan_d6actestsig_b   Yes    Yes         Yes         OUTPUT    
stap_fbscan_d6select        Yes    Yes         Yes         OUTPUT    
rtdr_tap_tdo[2:0]           Yes    Yes         Yes         INPUT     
tap_rtdr_irdec[2:0]         Yes    Yes         Yes         OUTPUT    
tap_rtdr_prog_rst_b[2:0]    Yes    Yes         Yes         OUTPUT    
tap_rtdr_tdi[2:0]           Yes    Yes         Yes         OUTPUT    
tap_rtdr_capture[2:0]       Yes    Yes         Yes         OUTPUT    
tap_rtdr_shift[2:0]         Yes    Yes         Yes         OUTPUT    
tap_rtdr_update[2:0]        Yes    Yes         Yes         OUTPUT    
tap_rtdr_tck                Yes    Yes         Yes         OUTPUT    
tap_rtdr_powergood          Yes    Yes         Yes         OUTPUT    
tap_rtdr_selectir           Yes    Yes         Yes         OUTPUT    
tap_rtdr_rti                Yes    Yes         Yes         OUTPUT    
stap_isol_en_b              Yes    Yes         Yes         INPUT     

Signal Details
                                 Toggle Toggle 1->0 Toggle 0->1 
stap_selectwir_neg               Yes    Yes         Yes         
stap_fsm_shift_ir_neg            Yes    Yes         Yes         
tdo_dr                           Yes    Yes         Yes         
swcomp_stap_post_tdo             Yes    Yes         Yes         
swcompctrl_tdo                   Yes    Yes         Yes         
swcompstat_tdo                   Yes    Yes         Yes         
stap_fsm_rti                     Yes    Yes         Yes         
stap_fsm_e1dr                    Yes    Yes         Yes         
stap_fsm_e2dr                    Yes    Yes         Yes         
stap_fsm_capture_ir              Yes    Yes         Yes         
stap_fsm_shift_ir                Yes    Yes         Yes         
stap_fsm_update_ir               Yes    Yes         Yes         
stap_fsm_capture_dr              Yes    Yes         Yes         
stap_fsm_shift_dr                Yes    Yes         Yes         
stap_fsm_update_dr               Yes    Yes         Yes         
stap_irreg_ireg[15:0]            Yes    Yes         Yes         
stap_irreg_ireg_nxt[15:0]        Yes    Yes         Yes         
stap_irreg_serial_out            Yes    Yes         Yes         
stap_drreg_tdo[0]                Yes    Yes         Yes         
stap_drreg_tdo[3:1]              No     No          No          
stap_drreg_tdo[4]                Yes    Yes         Yes         
stap_drreg_tdo[6:5]              No     No          No          
stap_drreg_tdo[7]                Yes    Yes         Yes         
stap_drreg_tdo[12:8]             No     No          No          
stap_drreg_tdo[14:13]            Yes    Yes         Yes         
stap_drreg_tdo[15]               No     No          Yes         
stap_drreg_tdo[25:16]            Yes    Yes         Yes         
stap_irdecoder_drselect[1:0]     Yes    Yes         Yes         
stap_irdecoder_drselect[2]       No     No          No          
stap_irdecoder_drselect[8:3]     Yes    Yes         Yes         
stap_irdecoder_drselect[9]       No     No          No          
stap_irdecoder_drselect[25:10]   Yes    Yes         Yes         
stap_and_all_bits_irreg          Yes    Yes         Yes         
tapc_select[7:0]                 Yes    Yes         Yes         
tapc_wtap_sel[2:0]               Yes    Yes         Yes         
tapc_remove                      No     No          Yes         
stap_mux_tdo                     Yes    Yes         Yes         
pre_tdo                          Yes    Yes         Yes         
stap_wtapnw_tdo                  Yes    Yes         Yes         
powergood_rst_trst_b             Yes    Yes         Yes         
stap_tdomux_tdoen                Yes    Yes         Yes         
stap_irreg_shift_reg[15:0]       Yes    Yes         Yes         
stap_selectwir                   Yes    Yes         Yes         
visa_all_dis                     No     No          No          
visa_customer_dis                No     No          No          
dfxsecure_feature_en[2:0]        Yes    Yes         Yes         
tap_swcomp_active                Yes    Yes         Yes         
stap_fsm_state_ps[15:0]          Yes    Yes         Yes         
stap_bscan_select_bscan_internal Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.88 --     --      99.88 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.57 100.00 100.00  99.98 100.00 100.00  97.47 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME              
 96.23 --     --      96.23 --     --     --     STAP_RTL_LIB.stap 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME   
--     --     --     --     --     --     --     top(X) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
 99.80 100.00 100.00 100.00 --     100.00  99.00 generate_stap_bscan.i_stap_bscan   
100.00 --     --     100.00 --     --     --     generate_stap_tapnw.i_stap_tapnw   
100.00 --     100.00 100.00 --     100.00 --     generate_stap_wtapnw.i_stap_wtapnw 
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_rtdr      
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_dfxsecure_plugin(x)         
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x)                    
 97.37 100.00 100.00 100.00 100.00 100.00  84.21 i_stap_fsm(x)                      
100.00 --     100.00 100.00 --     100.00 --     i_stap_glue(x)                     
100.00 100.00 100.00 100.00 --     100.00 --     i_stap_irdecoder(x)                
100.00 100.00 --     100.00 --     100.00 100.00 i_stap_irreg                       
100.00 100.00 --     100.00 --     100.00 --     i_stap_tdomux(x)                   



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst(x)
                Total Covered Percent 
Totals          106   105     99.06   
Total Bits      810   809     99.88   
Total Bits 0->1 405   405     100.00  
Total Bits 1->0 405   404     99.75   

                              
Ports          73  73  100.00 
Port Bits      526 526 100.00 
Port Bits 0->1 263 263 100.00 
Port Bits 1->0 263 263 100.00 

                                
Signals          33  32  96.97  
Signal Bits      284 283 99.65  
Signal Bits 0->1 142 142 100.00 
Signal Bits 1->0 142 141 99.30  

Port Details
                            Toggle   Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                    Yes      Yes         Yes         INPUT     
ftap_tms                    Yes      Yes         Yes         INPUT     
ftap_trst_b                 Yes      Yes         Yes         INPUT     
ftap_tdi                    Yes      Yes         Yes         INPUT     
ftap_slvidcode[31:0]        Yes      Yes         Yes         INPUT     
atap_tdo                    Yes      Yes         Yes         OUTPUT    
atap_tdoen                  Yes      Yes         Yes         OUTPUT    
fdfx_powergood              Yes      Yes         Yes         INPUT     
tdr_data_out[63:0]          Yes      Yes         Yes         OUTPUT    
tdr_data_in[63:0]           Yes      Yes         Yes         INPUT     
fdfx_secure_policy[2:0]     Yes      Yes         Yes         INPUT     
fdfx_secure_policy[3]       Excluded Excluded    Excluded    INPUT     
fdfx_earlyboot_exit         Yes      Yes         Yes         INPUT     
fdfx_policy_update          Yes      Yes         Yes         INPUT     
sftapnw_ftap_secsel[0]      Excluded Excluded    Excluded    OUTPUT    
sftapnw_ftap_secsel[1]      Yes      Yes         Yes         OUTPUT    
sftapnw_ftap_secsel[2]      Excluded Excluded    Excluded    OUTPUT    
sftapnw_ftap_secsel[3]      Yes      Yes         Yes         OUTPUT    
sftapnw_ftap_enabletdo[3:0] Yes      Yes         Yes         OUTPUT    
sftapnw_ftap_enabletap[3:0] Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tck            Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tms            Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_trst_b         Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tdi            Yes      Yes         Yes         OUTPUT    
sntapnw_atap_tdo            Yes      Yes         Yes         INPUT     
sntapnw_atap_tdo_en[3:0]    Yes      Yes         Yes         INPUT     
ftapsslv_tck                Yes      Yes         Yes         INPUT     
ftapsslv_tms                Yes      Yes         Yes         INPUT     
ftapsslv_trst_b             Yes      Yes         Yes         INPUT     
ftapsslv_tdi                Yes      Yes         Yes         INPUT     
atapsslv_tdo                Yes      Yes         Yes         OUTPUT    
atapsslv_tdoen              Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tck2           Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tms2           Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_trst2_b        Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tdi2           Yes      Yes         Yes         OUTPUT    
sntapnw_atap_tdo2           Yes      Yes         Yes         INPUT     
sntapnw_atap_tdo2_en[3:0]   Yes      Yes         Yes         INPUT     
sn_fwtap_wrck               Yes      Yes         Yes         OUTPUT    
sn_fwtap_wrst_b             Yes      Yes         Yes         OUTPUT    
sn_fwtap_capturewr          Yes      Yes         Yes         OUTPUT    
sn_fwtap_shiftwr            Yes      Yes         Yes         OUTPUT    
sn_fwtap_updatewr           Yes      Yes         Yes         OUTPUT    
sn_fwtap_rti                Yes      Yes         Yes         OUTPUT    
sn_fwtap_selectwir          Yes      Yes         Yes         OUTPUT    
sn_awtap_wso[2:0]           Yes      Yes         Yes         INPUT     
sn_fwtap_wsi[2:0]           Yes      Yes         Yes         OUTPUT    
stap_fbscan_tck             Yes      Yes         Yes         OUTPUT    
stap_abscan_tdo             Yes      Yes         Yes         INPUT     
stap_fbscan_capturedr       Yes      Yes         Yes         OUTPUT    
stap_fbscan_shiftdr         Yes      Yes         Yes         OUTPUT    
stap_fbscan_updatedr        Yes      Yes         Yes         OUTPUT    
stap_fbscan_updatedr_clk    Yes      Yes         Yes         OUTPUT    
stap_fbscan_runbist_en      Yes      Yes         Yes         OUTPUT    
stap_fbscan_highz           Yes      Yes         Yes         OUTPUT    
stap_fbscan_extogen         Yes      Yes         Yes         OUTPUT    
stap_fbscan_intest_mode     Yes      Yes         Yes         OUTPUT    
stap_fbscan_chainen         Yes      Yes         Yes         OUTPUT    
stap_fbscan_mode            Yes      Yes         Yes         OUTPUT    
stap_fbscan_extogsig_b      Yes      Yes         Yes         OUTPUT    
stap_fsm_tlrs               Yes      Yes         Yes         OUTPUT    
ftap_pwrdomain_rst_b        Yes      Yes         Yes         INPUT     
stap_fbscan_d6init          Yes      Yes         Yes         OUTPUT    
stap_fbscan_d6actestsig_b   Yes      Yes         Yes         OUTPUT    
stap_fbscan_d6select        Yes      Yes         Yes         OUTPUT    
rtdr_tap_tdo[2:0]           Yes      Yes         Yes         INPUT     
tap_rtdr_irdec[2:0]         Yes      Yes         Yes         OUTPUT    
tap_rtdr_prog_rst_b[2:0]    Yes      Yes         Yes         OUTPUT    
tap_rtdr_tdi[2:0]           Yes      Yes         Yes         OUTPUT    
tap_rtdr_capture[2:0]       Yes      Yes         Yes         OUTPUT    
tap_rtdr_shift[2:0]         Yes      Yes         Yes         OUTPUT    
tap_rtdr_update[2:0]        Yes      Yes         Yes         OUTPUT    
tap_rtdr_tck                Yes      Yes         Yes         OUTPUT    
tap_rtdr_powergood          Yes      Yes         Yes         OUTPUT    
tap_rtdr_selectir           Yes      Yes         Yes         OUTPUT    
tap_rtdr_rti                Yes      Yes         Yes         OUTPUT    
stap_isol_en_b              Yes      Yes         Yes         INPUT     

Signal Details
                                 Toggle   Toggle 1->0 Toggle 0->1 
stap_selectwir_neg               Yes      Yes         Yes         
stap_fsm_shift_ir_neg            Yes      Yes         Yes         
tdo_dr                           Yes      Yes         Yes         
swcomp_stap_post_tdo             Yes      Yes         Yes         
swcompctrl_tdo                   Yes      Yes         Yes         
swcompstat_tdo                   Yes      Yes         Yes         
stap_fsm_rti                     Yes      Yes         Yes         
stap_fsm_e1dr                    Yes      Yes         Yes         
stap_fsm_e2dr                    Yes      Yes         Yes         
stap_fsm_capture_ir              Yes      Yes         Yes         
stap_fsm_shift_ir                Yes      Yes         Yes         
stap_fsm_update_ir               Yes      Yes         Yes         
stap_fsm_capture_dr              Yes      Yes         Yes         
stap_fsm_shift_dr                Yes      Yes         Yes         
stap_fsm_update_dr               Yes      Yes         Yes         
stap_irreg_ireg[15:0]            Yes      Yes         Yes         
stap_irreg_ireg_nxt[15:0]        Yes      Yes         Yes         
stap_irreg_serial_out            Yes      Yes         Yes         
stap_drreg_tdo[0]                Yes      Yes         Yes         
stap_drreg_tdo[3:1]              Excluded Excluded    Excluded    
stap_drreg_tdo[4]                Yes      Yes         Yes         
stap_drreg_tdo[6:5]              Excluded Excluded    Excluded    
stap_drreg_tdo[7]                Yes      Yes         Yes         
stap_drreg_tdo[12:8]             Excluded Excluded    Excluded    
stap_drreg_tdo[14:13]            Yes      Yes         Yes         
stap_drreg_tdo[15]               No       No          Yes         
stap_drreg_tdo[25:16]            Yes      Yes         Yes         
stap_irdecoder_drselect[1:0]     Yes      Yes         Yes         
stap_irdecoder_drselect[2]       Excluded Excluded    Excluded    
stap_irdecoder_drselect[8:3]     Yes      Yes         Yes         
stap_irdecoder_drselect[9]       Excluded Excluded    Excluded    
stap_irdecoder_drselect[25:10]   Yes      Yes         Yes         
stap_and_all_bits_irreg          Yes      Yes         Yes         
tapc_select[7:0]                 Yes      Yes         Yes         
tapc_wtap_sel[2:0]               Yes      Yes         Yes         
tapc_remove                      Excluded Excluded    Excluded    
stap_mux_tdo                     Excluded Excluded    Excluded    
pre_tdo                          Yes      Yes         Yes         
stap_wtapnw_tdo                  Yes      Yes         Yes         
powergood_rst_trst_b             Yes      Yes         Yes         
stap_tdomux_tdoen                Yes      Yes         Yes         
stap_irreg_shift_reg[15:0]       Yes      Yes         Yes         
stap_selectwir                   Yes      Yes         Yes         
visa_all_dis                     Excluded Excluded    Excluded    
visa_customer_dis                Excluded Excluded    Excluded    
dfxsecure_feature_en[2:0]        Yes      Yes         Yes         
tap_swcomp_active                Yes      Yes         Yes         
stap_fsm_state_ps[15:0]          Yes      Yes         Yes         
stap_bscan_select_bscan_internal Yes      Yes         Yes         


===============================================================================
Module : STAP_RTL_LIB.stap_irdecoder
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.17 100.00 100.00  96.69 --     100.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_irdecoder.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                  
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_irdecoder(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_irdecoder 

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS            155        6        6   100.00
ALWAYS            202       11       11   100.00

154                     always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
155        1/1            if (~ powergood_rst_trst_b)
156        1/1                for (integer count = 0; count <= (IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - 1); count++)
157                           begin
158        1/1                   if (count == IRDECODER_STAP_POSITION_OF_SLVIDCODE)
159        1/1                       stap_irdecoder_drselect[IRDECODER_STAP_POSITION_OF_SLVIDCODE] <= 1'b1;
160                              else
161        1/1                       stap_irdecoder_drselect[count] <= 1'b0;
162                           end
163                       else
164        1/1                stap_irdecoder_drselect <= irdecoder_drselect_nxt;
165                     
166                        // *********************************************************************
167                        // Decoding of some of the Instructions
168                        // *********************************************************************
169                        assign stap_and_all_bits_irreg = &(stap_irreg_ireg);
170                        assign and_all_bits_irreg_nxt  = &(stap_irreg_ireg_nxt) | bypass_enable ; //kbbhagwa cdc fix //badithya fix for making IRREG go to bypass whenever bypass_enable is 1. 
171                     
172                        assign decode_clamp = (stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
173                     
174                        generate
175                          if(IRDECODER_STAP_SWCOMP_ACTIVE == 1)
176                          begin:generate_enable
177                     
178                     //      always_comb begin
179                     //            if(((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))  && (stap_isol_en_b == 1'b0) ) //Whenever SWCOMP registers are selected and SWCOMP is powered down, bypass register should be selected.
180                     //            begin
181                     //                bypass_enable = 1'b1;
182                     //            end
183                     //            else
184                     //            begin 
185                     //                bypass_enable = 1'b0;
186                     //            end
187                     //        
188                     //            if(bypass_enable == 1'b0)  // Whenever bypass enable = 0 and SWCOMP registers are selected, tap_swcomp_active should be high
189                     //              begin
190                     //               if((stap_irreg_ireg == 'h20 | stap_irreg_ireg == 'h21))
191                     //                   tap_swcomp_active = 1'b1;
192                     //               else
193                     //                   tap_swcomp_active = 1'b0;
194                     //              end
195                     //            else 
196                     //            begin
197                     //                   tap_swcomp_active = 1'b1 ;
198                     //            end 
199                     //          end
200                     //
201                       always_comb begin
202        1/1          	  if(stap_isol_en_b == 1'b0)
203                     	  begin
204        1/1                    if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
205                     			  begin
206        1/1                             bypass_enable = 1'b1;
207        1/1                             tap_swcomp_active = 1'b1;
208                     		      end
209                              else 
210                     		      begin
211        1/1                             bypass_enable = 1'b0;
212        1/1                             tap_swcomp_active = 1'b1;
213                     		      end
214                     	  end
215                     	  else
216                     	  begin
217        1/1                    if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
218                     			  begin
219        1/1                             bypass_enable = 1'b0;
220        1/1                            tap_swcomp_active = 1'b1;
221                     			  end
222                               else
223                                   begin
224        1/1                             bypass_enable = 1'b0;
225        1/1          				  tap_swcomp_active = 1'b0;

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_irdecoder 

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       172
 EXPRESSION ((stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW)
             ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       242
 EXPRESSION 
 Number  Term
      1  (and_all_bits_irreg_nxt == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decode_clamp == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect))))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decode_clamp == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect)))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect)

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_irdecoder 
                Total Covered Percent 
Totals          16    14      87.50   
Total Bits      242   234     96.69   
Total Bits 0->1 121   117     96.69   
Total Bits 1->0 121   117     96.69   

                              
Ports          11  10  90.91  
Port Bits      132 128 96.97  
Port Bits 0->1 66  64  96.97  
Port Bits 1->0 66  64  96.97  

                                
Signals          5   4   80.00  
Signal Bits      110 106 96.36  
Signal Bits 0->1 55  53  96.36  
Signal Bits 1->0 55  53  96.36  

Port Details
                               Toggle Toggle 1->0 Toggle 0->1 Direction 
powergood_rst_trst_b           Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]          Yes    Yes         Yes         INPUT     
stap_irreg_ireg_nxt[15:0]      Yes    Yes         Yes         INPUT     
ftap_tck                       Yes    Yes         Yes         INPUT     
feature_green_en               Yes    Yes         Yes         INPUT     
feature_orange_en              Yes    Yes         Yes         INPUT     
feature_red_en                 Yes    Yes         Yes         INPUT     
stap_isol_en_b                 Yes    Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes    Yes         Yes         OUTPUT    
stap_irdecoder_drselect[2]     No     No          No          OUTPUT    
stap_irdecoder_drselect[8:3]   Yes    Yes         Yes         OUTPUT    
stap_irdecoder_drselect[9]     No     No          No          OUTPUT    
stap_irdecoder_drselect[25:10] Yes    Yes         Yes         OUTPUT    
tap_swcomp_active              Yes    Yes         Yes         OUTPUT    
stap_and_all_bits_irreg        Yes    Yes         Yes         OUTPUT    

Signal Details
                              Toggle Toggle 1->0 Toggle 0->1 
decoder_drselect[25:0]        Yes    Yes         Yes         
decode_clamp                  Yes    Yes         Yes         
irdecoder_drselect_nxt[1:0]   Yes    Yes         Yes         
irdecoder_drselect_nxt[2]     No     No          No          
irdecoder_drselect_nxt[8:3]   Yes    Yes         Yes         
irdecoder_drselect_nxt[9]     No     No          No          
irdecoder_drselect_nxt[25:10] Yes    Yes         Yes         
and_all_bits_irreg_nxt        Yes    Yes         Yes         
bypass_enable                 Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_irdecoder 
         Line No. Total Covered Percent 
Branches          13    13      100.00  
TERNARY  172      2     2       100.00  
TERNARY  242      5     5       100.00  
IF       155      2     2       100.00  
IF       202      4     4       100.00  


172           assign decode_clamp = (stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
                                                                                             -1-  
                                                                                             ==>  
                                                                                             ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


242                 assign irdecoder_drselect_nxt = (and_all_bits_irreg_nxt == HIGH) ?
                                                                                     -1-  
                                                                                     ==>  
243                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} : (decode_clamp == HIGH) ?
                                                                                                                -2-  
                                                                                                                ==>  
244                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} :
                                                                                        
245                    (decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS{LOW}}) ?
                                                                                             -3-  
                                                                                             ==>  
246                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} :
                                                                                        
247                    (decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ?
                                                                                    -4-  
                                                                                    ==>  
                                                                                    ==>  

Branches:

-1- -2- -3- -4- Status  
1   -   -   -   Covered 
0   1   -   -   Covered 
0   0   1   -   Covered 
0   0   0   1   Covered 
0   0   0   0   Covered 


155          if (~ powergood_rst_trst_b)
             -1-  
156              for (integer count = 0; count <= (IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - 1); count++)
                 ==>
157              begin
158                 if (count == IRDECODER_STAP_POSITION_OF_SLVIDCODE)
159                     stap_irdecoder_drselect[IRDECODER_STAP_POSITION_OF_SLVIDCODE] <= 1'b1;
160                 else
161                     stap_irdecoder_drselect[count] <= 1'b0;
162              end
163          else
164              stap_irdecoder_drselect <= irdecoder_drselect_nxt;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


202        	  if(stap_isol_en_b == 1'b0)
           	  -1-  
203        	  begin
204                  if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
                     -2-  
205        			  begin
206                           bypass_enable = 1'b1;
                              ==>
207                           tap_swcomp_active = 1'b1;
208        		      end
209                 else 
210        		      begin
211                           bypass_enable = 1'b0;
                              ==>
212                           tap_swcomp_active = 1'b1;
213        		      end
214        	  end
215        	  else
216        	  begin
217                  if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
                     -3-  
218        			  begin
219                           bypass_enable = 1'b0;
                              ==>
220                          tap_swcomp_active = 1'b1;
221        			  end
222                  else
223                      begin
224                           bypass_enable = 1'b0;
                              ==>

Branches:

-1- -2- -3- Status  
1   1   -   Covered 
1   0   -   Covered 
0   -   1   Covered 
0   -   0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irdecoder(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                        
 99.17 100.00 100.00  96.69 --     100.00 --     STAP_RTL_LIB.stap_irdecoder 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                   
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[0].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[10].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[11].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[12].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[13].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[14].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[15].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[16].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[17].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[18].i_stap_decoder(x) 
100.00 100.00 --     100.00 --     --     --     generate_decoder[19].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[1].i_stap_decoder(x)  
100.00 100.00 --     100.00 --     --     --     generate_decoder[20].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[21].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[22].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[23].i_stap_decoder(x) 
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[2].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[3].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[4].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[5].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[6].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[7].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[8].i_stap_decoder(x)  
100.00 100.00 100.00 100.00 --     100.00 --     generate_decoder[9].i_stap_decoder(x)  



-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.i_stap_irdecoder(x)

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS            155        6        6   100.00
ALWAYS            202       11       11   100.00

154                     always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
155        1/1            if (~ powergood_rst_trst_b)
156        1/1                for (integer count = 0; count <= (IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - 1); count++)
157                           begin
158        1/1                   if (count == IRDECODER_STAP_POSITION_OF_SLVIDCODE)
159        1/1                       stap_irdecoder_drselect[IRDECODER_STAP_POSITION_OF_SLVIDCODE] <= 1'b1;
160                              else
161        1/1                       stap_irdecoder_drselect[count] <= 1'b0;
162                           end
163                       else
164        1/1                stap_irdecoder_drselect <= irdecoder_drselect_nxt;
165                     
166                        // *********************************************************************
167                        // Decoding of some of the Instructions
168                        // *********************************************************************
169                        assign stap_and_all_bits_irreg = &(stap_irreg_ireg);
170                        assign and_all_bits_irreg_nxt  = &(stap_irreg_ireg_nxt) | bypass_enable ; //kbbhagwa cdc fix //badithya fix for making IRREG go to bypass whenever bypass_enable is 1. 
171                     
172                        assign decode_clamp = (stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
173                     
174                        generate
175                          if(IRDECODER_STAP_SWCOMP_ACTIVE == 1)
176                          begin:generate_enable
177                     
178                     //      always_comb begin
179                     //            if(((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))  && (stap_isol_en_b == 1'b0) ) //Whenever SWCOMP registers are selected and SWCOMP is powered down, bypass register should be selected.
180                     //            begin
181                     //                bypass_enable = 1'b1;
182                     //            end
183                     //            else
184                     //            begin 
185                     //                bypass_enable = 1'b0;
186                     //            end
187                     //        
188                     //            if(bypass_enable == 1'b0)  // Whenever bypass enable = 0 and SWCOMP registers are selected, tap_swcomp_active should be high
189                     //              begin
190                     //               if((stap_irreg_ireg == 'h20 | stap_irreg_ireg == 'h21))
191                     //                   tap_swcomp_active = 1'b1;
192                     //               else
193                     //                   tap_swcomp_active = 1'b0;
194                     //              end
195                     //            else 
196                     //            begin
197                     //                   tap_swcomp_active = 1'b1 ;
198                     //            end 
199                     //          end
200                     //
201                       always_comb begin
202        1/1          	  if(stap_isol_en_b == 1'b0)
203                     	  begin
204        1/1                    if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
205                     			  begin
206        1/1                             bypass_enable = 1'b1;
207        1/1                             tap_swcomp_active = 1'b1;
208                     		      end
209                              else 
210                     		      begin
211        1/1                             bypass_enable = 1'b0;
212        1/1                             tap_swcomp_active = 1'b1;
213                     		      end
214                     	  end
215                     	  else
216                     	  begin
217        1/1                    if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
218                     			  begin
219        1/1                             bypass_enable = 1'b0;
220        1/1                            tap_swcomp_active = 1'b1;
221                     			  end
222                               else
223                                   begin
224        1/1                             bypass_enable = 1'b0;
225        1/1          				  tap_swcomp_active = 1'b0;

-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_irdecoder(x)

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       172
 EXPRESSION ((stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW)
             ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       242
 EXPRESSION 
 Number  Term
      1  (and_all_bits_irreg_nxt == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decode_clamp == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect))))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decode_clamp == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect)))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS {LOW}}) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : ((decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect))

-1- Status
 0  Covered
 1  Covered

 LINE       242
 SUB-EXPRESSION 
 Number  Term
      1  (decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ? ({{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE) {LOW}}, HIGH}) : decoder_drselect)

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_irdecoder(x)
                Total Covered Percent 
Totals          15    15      100.00  
Total Bits      232   232     100.00  
Total Bits 0->1 116   116     100.00  
Total Bits 1->0 116   116     100.00  

                              
Ports          10  10  100.00 
Port Bits      126 126 100.00 
Port Bits 0->1 63  63  100.00 
Port Bits 1->0 63  63  100.00 

                                
Signals          5   5   100.00 
Signal Bits      106 106 100.00 
Signal Bits 0->1 53  53  100.00 
Signal Bits 1->0 53  53  100.00 

Port Details
                               Toggle   Toggle 1->0 Toggle 0->1 Direction 
powergood_rst_trst_b           Yes      Yes         Yes         INPUT     
stap_irreg_ireg[15:0]          Yes      Yes         Yes         INPUT     
stap_irreg_ireg_nxt[15:0]      Yes      Yes         Yes         INPUT     
ftap_tck                       Yes      Yes         Yes         INPUT     
feature_green_en               Yes      Yes         Yes         INPUT     
feature_orange_en              Excluded Excluded    Excluded    INPUT     
feature_red_en                 Yes      Yes         Yes         INPUT     
stap_isol_en_b                 Yes      Yes         Yes         INPUT     
stap_irdecoder_drselect[1:0]   Yes      Yes         Yes         OUTPUT    
stap_irdecoder_drselect[2]     Excluded Excluded    Excluded    OUTPUT    
stap_irdecoder_drselect[8:3]   Yes      Yes         Yes         OUTPUT    
stap_irdecoder_drselect[9]     Excluded Excluded    Excluded    OUTPUT    
stap_irdecoder_drselect[25:10] Yes      Yes         Yes         OUTPUT    
tap_swcomp_active              Yes      Yes         Yes         OUTPUT    
stap_and_all_bits_irreg        Yes      Yes         Yes         OUTPUT    

Signal Details
                              Toggle   Toggle 1->0 Toggle 0->1 
decoder_drselect[25:0]        Yes      Yes         Yes         
decode_clamp                  Yes      Yes         Yes         
irdecoder_drselect_nxt[1:0]   Yes      Yes         Yes         
irdecoder_drselect_nxt[2]     Excluded Excluded    Excluded    
irdecoder_drselect_nxt[8:3]   Yes      Yes         Yes         
irdecoder_drselect_nxt[9]     Excluded Excluded    Excluded    
irdecoder_drselect_nxt[25:10] Yes      Yes         Yes         
and_all_bits_irreg_nxt        Yes      Yes         Yes         
bypass_enable                 Yes      Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_irdecoder(x)
         Line No. Total Covered Percent 
Branches          13    13      100.00  
TERNARY  172      2     2       100.00  
TERNARY  242      5     5       100.00  
IF       155      2     2       100.00  
IF       202      4     4       100.00  


172           assign decode_clamp = (stap_irreg_ireg_nxt == IRDECODER_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
                                                                                             -1-  
                                                                                             ==>  
                                                                                             ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


242                 assign irdecoder_drselect_nxt = (and_all_bits_irreg_nxt == HIGH) ?
                                                                                     -1-  
                                                                                     ==>  
243                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} : (decode_clamp == HIGH) ?
                                                                                                                -2-  
                                                                                                                ==>  
244                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} :
                                                                                        
245                    (decoder_drselect == {IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS{LOW}}) ?
                                                                                             -3-  
                                                                                             ==>  
246                    {{(IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - ONE){LOW}}, HIGH} :
                                                                                        
247                    (decoder_drselect[IRDECODER_STAP_POSITION_OF_HIGHZ] == HIGH) ?
                                                                                    -4-  
                                                                                    ==>  
                                                                                    ==>  

Branches:

-1- -2- -3- -4- Status  
1   -   -   -   Covered 
0   1   -   -   Covered 
0   0   1   -   Covered 
0   0   0   1   Covered 
0   0   0   0   Covered 


155          if (~ powergood_rst_trst_b)
             -1-  
156              for (integer count = 0; count <= (IRDECODER_STAP_NUMBER_OF_TOTAL_REGISTERS - 1); count++)
                 ==>
157              begin
158                 if (count == IRDECODER_STAP_POSITION_OF_SLVIDCODE)
159                     stap_irdecoder_drselect[IRDECODER_STAP_POSITION_OF_SLVIDCODE] <= 1'b1;
160                 else
161                     stap_irdecoder_drselect[count] <= 1'b0;
162              end
163          else
164              stap_irdecoder_drselect <= irdecoder_drselect_nxt;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


202        	  if(stap_isol_en_b == 1'b0)
           	  -1-  
203        	  begin
204                  if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
                     -2-  
205        			  begin
206                           bypass_enable = 1'b1;
                              ==>
207                           tap_swcomp_active = 1'b1;
208        		      end
209                 else 
210        		      begin
211                           bypass_enable = 1'b0;
                              ==>
212                           tap_swcomp_active = 1'b1;
213        		      end
214        	  end
215        	  else
216        	  begin
217                  if((stap_irreg_ireg == 'h20) | (stap_irreg_ireg == 'h21))
                     -3-  
218        			  begin
219                           bypass_enable = 1'b0;
                              ==>
220                          tap_swcomp_active = 1'b1;
221        			  end
222                  else
223                      begin
224                           bypass_enable = 1'b0;
                              ==>

Branches:

-1- -2- -3- Status  
1   1   -   Covered 
1   0   -   Covered 
0   -   1   Covered 
0   -   0   Covered 


===============================================================================
Module : STAP_RTL_LIB.stap_bscan_assertions
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.37 100.00 --      98.46 --     100.00  99.00 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_bscan_assertions.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                          
 99.75 100.00 --     100.00 --     100.00  99.00 top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_bscan_assertions 

             Line No.   Total   Covered  Percent
TOTAL                       27       27   100.00
ALWAYS            257        3        3   100.00
ALWAYS            291        2        2   100.00
ALWAYS            328        2        2   100.00
ALWAYS            373        3        3   100.00
ALWAYS            420        4        4   100.00
ALWAYS            463        4        4   100.00
ALWAYS            499        2        2   100.00
ALWAYS            537        2        2   100.00
ALWAYS            574        2        2   100.00
ALWAYS            610        2        2   100.00
ALWAYS            651        1        1   100.00

256                           begin
257        1/1                   if (stap_fsm_tlrs === HIGH)
258                              begin
259        2/2                      #1ps;
260                                 chk_if_bscan_ex1_at_reset_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
261                                 else $error("Mode is not Low at Reset");
262                     
263                                 chk_if_bscan_ex2_at_reset_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
264                                 else $error("HighZ is not Low at Reset");
265                     
266                                 chk_if_bscan_ex3_at_reset_then_chainen_equals_zero: assert (stap_fbscan_chainen === LOW)
267                                 else $error("Chain enable is not Low at Reset");
268                     
269                                 chk_if_bscan_ex4_at_reset_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
270                                 else $error("Extog enable is not Low at Reset");
271                     
272                                 chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
273                                 else $error("Extogsig is not HIGH at Reset");
274                     
275                                 chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
276                                 else $error("D6Select is not LOW at Reset");
277                     
278                                 chk_if_bscan_ex7_at_reset_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
279                                 else $error("D6int is not LOW at Reset");
280                     
281                                 chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
282                                 else $error("D6actsig_b is not HIGH at Reset");
283                     
284                              end
                        MISSING_ELSE
285                           end
286                           // ====================================================================
287                           // Check for BSCAN sigals during SAMPLE/PRELOAD instruction
288                           // ====================================================================
289                           always @(negedge ftap_tck)
290                           begin
291        1/1                   if (stap_fsm_tlrs === LOW)
292                              begin
293        1/1                      if (($past(inst_sampre,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD))
294                                 begin
295                     
296                                    chk_if_bscan_ex1_sample_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
297                                    else $error("Mode is not Low for a Bscan instruction: SAMPLE_PRELOAD");
298                     
299                                    chk_if_bscan_ex2_sample_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
300                                    else $error("HighZ is not Low for a Bscan instruction: SAMPLE_PRELOAD");
301                     
302                                    chk_if_bscan_ex3_sample_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
303                                    else $error("Chain enable is not High for a Bscan instruction: SAMPLE_PRELOAD");
304                     
305                                    chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
306                                    else $error("Extog enable is not Low for a Bscan instruction: SAMPLE_PRELOAD");
307                     
308                                    chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
309                                    else $error("Extogsig is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
310                     
311                                    chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
312                                    else $error("D6Select is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
313                     
314                                    chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
315                                    else $error("D6int is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
316                     
317                                    chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
318                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
319                     
320                                 end
                        MISSING_ELSE
321                              end
                        MISSING_ELSE
322                           end
323                           // ====================================================================
324                           // Check for BSCAN sigals during EXTEST instruction
325                           // ====================================================================
326                           always @(negedge ftap_tck)
327                           begin
328        1/1                   if (stap_fsm_tlrs === LOW)
329                              begin
330        1/1                      if (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))
331                                 begin
332                     
333                                    chk_if_bscan_ex1_extest_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
334                                    else $error("Mode is not High for a Bscan instruction: EXTEST");
335                     
336                                    chk_if_bscan_ex2_extest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
337                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST");
338                     
339                                    chk_if_bscan_ex3_extest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
340                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST");
341                     
342                                    chk_if_bscan_ex4_extest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
343                                    else $error("Extog enable is not Low for a Bscan instruction: EXTEST");
344                     
345                                    chk_if_bscan_ex5_extest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
346                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST");
347                     
348                                    chk_if_bscan_ex6_extest_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
349                                    else $error("D6Select is not LOW  for a Bscan instruction: EXTEST");
350                     
351                                   // chk_if_bscan_ex7_extest_preload_then_d6init_equals_pulse: assert property (stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
352                                   // else $error("D6int is not Pulse for a Bscan instruction: EXTEST");
353                     
354                                    chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
355                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST");
356                     
357                                 end
                        MISSING_ELSE
358                              end
                        MISSING_ELSE
359                           end
360                          property my_chk;
361                            @(negedge ftap_tck)
362                     
363                            ((stap_fsm_tlrs === LOW) && (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))) && stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init;
364                     
365                           endproperty
366                     
367                     
368                     chk_if_bscan_ex9_extest_preload_then_d6init_equals_pulse: assert property (my_chk); // ====================================================================
369                           // Check for BSCAN sigals during EXTEST TOGGLE instruction
370                           // ====================================================================
371                           always @(negedge ftap_tck)
372                           begin
373        1/1                   if (stap_fsm_tlrs === LOW)
374                              begin
375        1/1                      if (($past(stap_fbscan_extogen,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) && (stap_fsm_rti === HIGH))
376                                 begin
377                     
378                                    chk_if_bscan_ex1_extest_tgl_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
379                                    else $error("Mode is not High for a Bscan instruction: EXTEST TOGGLE");
380                     
381                                    chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
382                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TOGGLE");
383                     
384                                    chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
385                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST TOGGLE");
386                     
387                                    chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one: assert (stap_fbscan_extogen === HIGH)
388                                    else $error("Extog enable is not high for a Bscan instruction: EXTEST TOGGLE");
389                     
390        1/1                         if($past(stap_fsm_rti,1) === 1'b0) begin
391                                       chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active: assert (stap_fbscan_extogsig_b === HIGH)
392                                       else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
393                     
394                                       chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active: assert (stap_fbscan_d6actestsig_b === HIGH)
395                                       else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
396                     
397                                    end else begin
398                                       chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles: assert (stap_fbscan_extogsig_b !== $past(stap_fbscan_extogsig_b,1))
399                                       else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
400                     
401                                       chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
402                                       else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
403                                    end
404                     
405                                    chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
406                                    else $error("D6Select is not LOW  for a Bscan instruction: EXTEST TOGGLE");
407                     
408                                    chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
409                                    else $error("D6int is not LOW for a Bscan instruction: EXTEST TOGGLE");
410                     
411                                 end
                        MISSING_ELSE
412                              end
                        MISSING_ELSE
413                           end
414                     
415                           // ====================================================================
416                           // Check for BSCAN sigals during EXTEST TRAIN instruction
417                           // ====================================================================
418                           always @(negedge ftap_tck)
419                           begin
420        1/1                   if (stap_fsm_tlrs === LOW)
421                              begin
422        1/1                      if (($past(inst_extest_train,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN))
423                                 begin
424                     
425                                    chk_if_bscan_ex1_extest_train_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
426                                    else $error("Mode is not High for a Bscan instruction: EXTEST TRAIN");
427                     
428                                    chk_if_bscan_ex2_extest_train_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
429                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TRAIN");
430                     
431                                    chk_if_bscan_ex3_extest_train_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
432                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST TRAIN");
433                     
434                                    chk_if_bscan_ex4_extest_train_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
435                                    else $error("Extog enable is not low for a Bscan instruction: EXTEST TRAIN");
436                     
437                                    chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
438                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST TRAIN");
439                     
440                                    chk_if_bscan_ex6_extest_train_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
441                                    else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST TRAIN");
442                     
443        1/1                         chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
444                                    else $error("D6int is not a pulse for a Bscan instruction: EXTEST TRAIN");
445                     
446        1/1                         if($past(stap_fsm_rti,1) === 1'b0) begin
447                                       chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset: assert (stap_fbscan_d6actestsig_b === HIGH)
448                                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
449                                    end else begin
450                                       chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
451                                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
452                                    end
453                     
454                                 end
                        MISSING_ELSE
455                              end
                        MISSING_ELSE
456                           end
457                     
458                           // ====================================================================
459                           // Check for BSCAN sigals during EXTEST PULSE instruction
460                           // ====================================================================
461                           always @(negedge ftap_tck)
462                           begin
463        1/1                   if (stap_fsm_tlrs === LOW)
464                              begin
465        1/1                      if (($past(inst_extest_pulse,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE))
466                                 begin
467                                    chk_if_bscan_ex1_extest_pulse_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
468                                    else $error("Mode is not HIGH for a Bscan instruction: EXTEST PULSE");
469                     
470                                    chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
471                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST PULSE");
472                     
473                                    chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
474                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST PULSE");
475                     
476                                    chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
477                                    else $error("Extog enable is not low for a Bscan instruction: EXTEST PULSE");
478                     
479                                    chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
480                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST PULSE");
481                     
482                                    chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
483                                    else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST PULSE");
484                     
485        1/1                         chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
486                                    else $error("D6int is not LOW for a Bscan instruction: EXTEST PULSE");
487                     
488        1/1                         chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one: assert property ($past(stap_fsm_rti) |-> !stap_fbscan_d6actestsig_b)
489                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST PULSE");
490                     
491                                 end
                        MISSING_ELSE
492                              end
                        MISSING_ELSE
493                           end
494                           // ====================================================================
495                           // Check for BSCAN sigals during CLAMP instruction
496                           // ====================================================================
497                           always @(negedge ftap_tck)
498                           begin
499        1/1                   if (stap_fsm_tlrs === LOW)
500                              begin
501        1/1                      if (($past(inst_clamp,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_CLAMP))
502                                 begin
503                     
504                                    chk_if_bscan_ex1_clamp_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
505                                    else $error("Mode is not High for a Bscan instruction: CLAMP");
506                     
507                                    chk_if_bscan_ex2_clamp_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
508                                    else $error("HIGHZ is not Low for a Bscan instruction: CLAMP");
509                     
510                                    chk_if_bscan_ex3_clamp_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
511                                    else $error("Chain enable is not high for a Bscan instruction: CLAMP");
512                     
513                                    chk_if_bscan_ex4_clamp_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
514                                    else $error("Extog enable is not Low for a Bscan instruction: CLAMP");
515                     
516                                    chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
517                                    else $error("Extogsig is not high for a Bscan instruction: CLAMP");
518                     
519                                    chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
520                                    else $error("D6Select is not LOW  for a Bscan instruction: CLAMP");
521                     
522                                    chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
523                                    else $error("D6int is not LOW for a Bscan instruction: CLAMP");
524                     
525                                    chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
526                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: CLAMP");
527                     
528                                 end
                        MISSING_ELSE
529                              end
                        MISSING_ELSE
530                           end
531                     
532                           // ====================================================================
533                           // Check for BSCAN sigals during HIGHZ instruction
534                           // ====================================================================
535                           always @(negedge ftap_tck)
536                           begin
537        1/1                   if (stap_fsm_tlrs === LOW)
538                              begin
539        1/1                      if (($past(inst_highz,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_HIGHZ))
540                                 begin
541                     
542                                    chk_if_bscan_ex1_highz_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
543                                    else $error("Mode is not High for a Bscan instruction: HIGHZ");
544                     
545                                    chk_if_bscan_ex2_highz_then_highz_equals_one: assert (stap_fbscan_highz === HIGH)
546                                    else $error("HIGHZ is not HIGH for a Bscan instruction: HIGHZ");
547                     
548                                    chk_if_bscan_ex3_highz_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
549                                    else $error("Chain enable is not high for a Bscan instruction: HIGHZ");
550                     
551                                    chk_if_bscan_ex4_highz_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
552                                    else $error("Extog enable is not Low for a Bscan instruction: HIGHZ");
553                     
554                                    chk_if_bscan_ex5_highz_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
555                                    else $error("Extogsig is not high for a Bscan instruction: HIGHZ");
556                     
557                                    chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
558                                    else $error("D6Select is not LOW  for a Bscan instruction: HIGHZ");
559                     
560                                    chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
561                                    else $error("D6int is not LOW for a Bscan instruction: HIGHZ");
562                     
563                                    chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
564                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: HIGHZ");
565                     
566                                 end
                        MISSING_ELSE
567                              end
                        MISSING_ELSE
568                           end
569                           // ====================================================================
570                           // Check for BSCAN sigals during PRELOAD instruction
571                           // ====================================================================
572                           always @(negedge ftap_tck)
573                           begin
574        1/1                   if (stap_fsm_tlrs === LOW)
575                              begin
576        1/1                      if (($past(inst_preload,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_PRELOAD))
577                                 begin
578                                    chk_if_bscan_ex1_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
579                                    else $error("Mode is not Low for a Bscan instruction: PRELOAD");
580                     
581                                    chk_if_bscan_ex2_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
582                                    else $error("HIGHZ is not Low for a Bscan instruction: PRELOAD");
583                     
584                                    chk_if_bscan_ex3_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
585                                    else $error("Chain enable is not HIGH for a Bscan instruction: PRELOAD");
586                     
587                                    chk_if_bscan_ex4_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
588                                    else $error("Extog enable is not Low for a Bscan instruction: PRELOAD");
589                     
590                                    chk_if_bscan_ex5_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
591                                    else $error("Extogsig is not high for a Bscan instruction: PRELOAD");
592                     
593                                    chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
594                                    else $error("D6Select is not LOW  for a Bscan instruction: PRELOAD");
595                     
596                                    chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
597                                    else $error("D6int is not LOW for a Bscan instruction: PRELOAD");
598                     
599                                    chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
600                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: PRELOAD");
601                     
602                                 end
                        MISSING_ELSE
603                              end
                        MISSING_ELSE
604                           end
605                           // ====================================================================
606                           // Check for BSCAN sigals during INTEST instruction
607                           // ====================================================================
608                           always @(negedge ftap_tck)
609                           begin
610        1/1                   if (stap_fsm_tlrs === LOW)
611                              begin
612        1/1                      if (($past(inst_intest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_INTEST))
613                                 begin
614                     
615                                    chk_if_bscan_ex1_intest_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
616                                    else $error("Mode is not LOW for a Bscan instruction: INTEST");
617                     
618                                    chk_if_bscan_ex2_intest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
619                                    else $error("HIGHZ is not Low for a Bscan instruction: INTEST");
620                     
621                                    chk_if_bscan_ex3_intest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
622                                    else $error("Chain enable is not High for a Bscan instruction: INTEST");
623                     
624                                    chk_if_bscan_ex4_intest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
625                                    else $error("Extog enable is not Low for a Bscan instruction: INTEST");
626                     
627                                    chk_if_bscan_ex5_intest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
628                                    else $error("Extogsig is not high for a Bscan instruction: INTEST");
629                     
630                                    chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
631                                    else $error("D6Select is not LOW  for a Bscan instruction: INTEST");
632                     
633                                    chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
634                                    else $error("D6int is not LOW for a Bscan instruction: INTEST");
635                     
636                                    chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
637                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: INTEST");
638                     
639                                 end
                        MISSING_ELSE
640                              end
                        MISSING_ELSE
641                           end
642                     
643                           // =============================================================================================
644                           // Check if extest_train or pulse is choosed. Then Check if reset you are not in TLRS.
645                           // Then in the same clk cycle as when TLRS is low, check if d6select is equal to train_or_pluse.
646                           // =============================================================================================
647                           always @(negedge ftap_tck)
648                           begin
649                              chk_if_bscan_trainorpulse_then_d6select_equals_1:
650                              //assume property ((train_or_pulse) ##1 (stap_fsm_tlrs === LOW) |-> stap_fbscan_d6select);
651        1/1                   assert property ((train_or_pulse) |-> stap_fbscan_d6select);

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_bscan_assertions 
                Total Covered Percent 
Totals          50    49      98.00   
Total Bits      130   128     98.46   
Total Bits 0->1 65    64      98.46   
Total Bits 1->0 65    64      98.46   

                            
Ports          28 28 100.00 
Port Bits      86 86 100.00 
Port Bits 0->1 43 43 100.00 
Port Bits 1->0 43 43 100.00 

                              
Signals          22 21 95.45  
Signal Bits      44 42 95.45  
Signal Bits 0->1 22 21 95.45  
Signal Bits 1->0 22 21 95.45  

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                  Yes    Yes         Yes         INPUT     
stap_fbscan_capturedr     Yes    Yes         Yes         INPUT     
powergood_rst_trst_b      Yes    Yes         Yes         INPUT     
stap_fbscan_shiftdr       Yes    Yes         Yes         INPUT     
stap_fbscan_updatedr      Yes    Yes         Yes         INPUT     
stap_fbscan_updatedr_clk  Yes    Yes         Yes         INPUT     
stap_fsm_tlrs             Yes    Yes         Yes         INPUT     
stap_fbscan_mode          Yes    Yes         Yes         INPUT     
stap_fbscan_highz         Yes    Yes         Yes         INPUT     
stap_fbscan_chainen       Yes    Yes         Yes         INPUT     
stap_fbscan_extogen       Yes    Yes         Yes         INPUT     
stap_fbscan_extogsig_b    Yes    Yes         Yes         INPUT     
stap_fbscan_d6select      Yes    Yes         Yes         INPUT     
stap_fbscan_d6init        Yes    Yes         Yes         INPUT     
stap_fbscan_d6actestsig_b Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]     Yes    Yes         Yes         INPUT     
inst_extest               Yes    Yes         Yes         INPUT     
inst_sampre               Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr       Yes    Yes         Yes         INPUT     
stap_fsm_rti              Yes    Yes         Yes         INPUT     
inst_extest_train         Yes    Yes         Yes         INPUT     
e1dr_or_e2dr              Yes    Yes         Yes         INPUT     
inst_extest_pulse         Yes    Yes         Yes         INPUT     
inst_clamp                Yes    Yes         Yes         INPUT     
inst_highz                Yes    Yes         Yes         INPUT     
inst_preload              Yes    Yes         Yes         INPUT     
inst_intest               Yes    Yes         Yes         INPUT     
train_or_pulse            Yes    Yes         Yes         INPUT     

Signal Details
                                       Toggle Toggle 1->0 Toggle 0->1 
ftap_tck_delayed_by_1ps                Yes    Yes         Yes         
ftap_clk_raising_edge_pulse            Yes    Yes         Yes         
ftap_clk_falling_edge_pulse            Yes    Yes         Yes         
fbscan_capturedr_delayed_by_1ps        Yes    Yes         Yes         
fbscan_capturedr_raising_edge_pulse    Yes    Yes         Yes         
fbscan_capturedr_falling_edge_pulse    Yes    Yes         Yes         
capturedr_raising_valid                Yes    Yes         Yes         
capturedr_falling_valid                Yes    Yes         Yes         
fbscan_shiftdr_delayed_by_1ps          Yes    Yes         Yes         
fbscan_shiftdr_raising_edge_pulse      Yes    Yes         Yes         
fbscan_shiftdr_falling_edge_pulse      Yes    Yes         Yes         
shiftdr_raising_valid                  Yes    Yes         Yes         
shiftdr_falling_valid                  Yes    Yes         Yes         
fbscan_updatedr_delayed_by_1ps         Yes    Yes         Yes         
fbscan_updatedr_raising_edge_pulse     Yes    Yes         Yes         
fbscan_updatedr_falling_edge_pulse     Yes    Yes         Yes         
updatedr_raising_valid                 Yes    Yes         Yes         
updatedr_falling_valid                 Yes    Yes         Yes         
fbscan_updatedr_clk_delayed_by_1ps     Yes    Yes         Yes         
fbscan_updatedr_clk_raising_edge_pulse Yes    Yes         Yes         
fbscan_updatedr_clk_falling_edge_pulse Yes    Yes         Yes         
updatedr_clk_raising_valid             No     No          No          


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_bscan_assertions 
         Line No. Total Covered Percent 
Branches          31    31      100.00  
IF       257      2     2       100.00  
IF       291      3     3       100.00  
IF       328      3     3       100.00  
IF       373      4     4       100.00  
IF       420      4     4       100.00  
IF       463      3     3       100.00  
IF       499      3     3       100.00  
IF       537      3     3       100.00  
IF       574      3     3       100.00  
IF       610      3     3       100.00  


257                 if (stap_fsm_tlrs === HIGH)
                    -1-  
258                 begin
259                    #1ps;
                       ==>
260                    chk_if_bscan_ex1_at_reset_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
261                    else $error("Mode is not Low at Reset");
262        
263                    chk_if_bscan_ex2_at_reset_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
264                    else $error("HighZ is not Low at Reset");
265        
266                    chk_if_bscan_ex3_at_reset_then_chainen_equals_zero: assert (stap_fbscan_chainen === LOW)
267                    else $error("Chain enable is not Low at Reset");
268        
269                    chk_if_bscan_ex4_at_reset_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
270                    else $error("Extog enable is not Low at Reset");
271        
272                    chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
273                    else $error("Extogsig is not HIGH at Reset");
274        
275                    chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
276                    else $error("D6Select is not LOW at Reset");
277        
278                    chk_if_bscan_ex7_at_reset_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
279                    else $error("D6int is not LOW at Reset");
280        
281                    chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
282                    else $error("D6actsig_b is not HIGH at Reset");
283        
284                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


291                 if (stap_fsm_tlrs === LOW)
                    -1-  
292                 begin
293                    if (($past(inst_sampre,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD))
                       -2-  
294                    begin
295        
296                       chk_if_bscan_ex1_sample_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
297                       else $error("Mode is not Low for a Bscan instruction: SAMPLE_PRELOAD");
298        
299                       chk_if_bscan_ex2_sample_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
300                       else $error("HighZ is not Low for a Bscan instruction: SAMPLE_PRELOAD");
301        
302                       chk_if_bscan_ex3_sample_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
303                       else $error("Chain enable is not High for a Bscan instruction: SAMPLE_PRELOAD");
304        
305                       chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
306                       else $error("Extog enable is not Low for a Bscan instruction: SAMPLE_PRELOAD");
307        
308                       chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
309                       else $error("Extogsig is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
310        
311                       chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
312                       else $error("D6Select is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
313        
314                       chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
315                       else $error("D6int is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
316        
317                       chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
318                       else $error("D6actsig_b is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
319        
320                    end
                       MISSING_ELSE
                       ==>
321                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


328                 if (stap_fsm_tlrs === LOW)
                    -1-  
329                 begin
330                    if (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))
                       -2-  
331                    begin
332        
333                       chk_if_bscan_ex1_extest_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
334                       else $error("Mode is not High for a Bscan instruction: EXTEST");
335        
336                       chk_if_bscan_ex2_extest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
337                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST");
338        
339                       chk_if_bscan_ex3_extest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
340                       else $error("Chain enable is not high for a Bscan instruction: EXTEST");
341        
342                       chk_if_bscan_ex4_extest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
343                       else $error("Extog enable is not Low for a Bscan instruction: EXTEST");
344        
345                       chk_if_bscan_ex5_extest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
346                       else $error("Extogsig is not high for a Bscan instruction: EXTEST");
347        
348                       chk_if_bscan_ex6_extest_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
349                       else $error("D6Select is not LOW  for a Bscan instruction: EXTEST");
350        
351                      // chk_if_bscan_ex7_extest_preload_then_d6init_equals_pulse: assert property (stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
352                      // else $error("D6int is not Pulse for a Bscan instruction: EXTEST");
353        
354                       chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
355                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST");
356        
357                    end
                       MISSING_ELSE
                       ==>
358                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


373                 if (stap_fsm_tlrs === LOW)
                    -1-  
374                 begin
375                    if (($past(stap_fbscan_extogen,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) && (stap_fsm_rti === HIGH))
                       -2-  
376                    begin
377        
378                       chk_if_bscan_ex1_extest_tgl_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
379                       else $error("Mode is not High for a Bscan instruction: EXTEST TOGGLE");
380        
381                       chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
382                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TOGGLE");
383        
384                       chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
385                       else $error("Chain enable is not high for a Bscan instruction: EXTEST TOGGLE");
386        
387                       chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one: assert (stap_fbscan_extogen === HIGH)
388                       else $error("Extog enable is not high for a Bscan instruction: EXTEST TOGGLE");
389        
390                       if($past(stap_fsm_rti,1) === 1'b0) begin
                          -3-  
391                          chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active: assert (stap_fbscan_extogsig_b === HIGH)
                             ==>
392                          else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
393        
394                          chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active: assert (stap_fbscan_d6actestsig_b === HIGH)
395                          else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
396        
397                       end else begin
398                          chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles: assert (stap_fbscan_extogsig_b !== $past(stap_fbscan_extogsig_b,1))
                             ==>
399                          else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
400        
401                          chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
402                          else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
403                       end
404        
405                       chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
406                       else $error("D6Select is not LOW  for a Bscan instruction: EXTEST TOGGLE");
407        
408                       chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
409                       else $error("D6int is not LOW for a Bscan instruction: EXTEST TOGGLE");
410        
411                    end
                       MISSING_ELSE
                       ==>
412                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- -3- Status  
1   1   1   Covered 
1   1   0   Covered 
1   0   -   Covered 
0   -   -   Covered 


420                 if (stap_fsm_tlrs === LOW)
                    -1-  
421                 begin
422                    if (($past(inst_extest_train,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN))
                       -2-  
423                    begin
424        
425                       chk_if_bscan_ex1_extest_train_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
426                       else $error("Mode is not High for a Bscan instruction: EXTEST TRAIN");
427        
428                       chk_if_bscan_ex2_extest_train_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
429                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TRAIN");
430        
431                       chk_if_bscan_ex3_extest_train_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
432                       else $error("Chain enable is not high for a Bscan instruction: EXTEST TRAIN");
433        
434                       chk_if_bscan_ex4_extest_train_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
435                       else $error("Extog enable is not low for a Bscan instruction: EXTEST TRAIN");
436        
437                       chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
438                       else $error("Extogsig is not high for a Bscan instruction: EXTEST TRAIN");
439        
440                       chk_if_bscan_ex6_extest_train_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
441                       else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST TRAIN");
442        
443                       chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
444                       else $error("D6int is not a pulse for a Bscan instruction: EXTEST TRAIN");
445        
446                       if($past(stap_fsm_rti,1) === 1'b0) begin
                          -3-  
447                          chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset: assert (stap_fbscan_d6actestsig_b === HIGH)
                             ==>
448                          else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
449                       end else begin
450                          chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
                             ==>
451                          else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
452                       end
453        
454                    end
                       MISSING_ELSE
                       ==>
455                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- -3- Status  
1   1   1   Covered 
1   1   0   Covered 
1   0   -   Covered 
0   -   -   Covered 


463                 if (stap_fsm_tlrs === LOW)
                    -1-  
464                 begin
465                    if (($past(inst_extest_pulse,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE))
                       -2-  
466                    begin
467                       chk_if_bscan_ex1_extest_pulse_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
468                       else $error("Mode is not HIGH for a Bscan instruction: EXTEST PULSE");
469        
470                       chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
471                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST PULSE");
472        
473                       chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
474                       else $error("Chain enable is not high for a Bscan instruction: EXTEST PULSE");
475        
476                       chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
477                       else $error("Extog enable is not low for a Bscan instruction: EXTEST PULSE");
478        
479                       chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
480                       else $error("Extogsig is not high for a Bscan instruction: EXTEST PULSE");
481        
482                       chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
483                       else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST PULSE");
484        
485                       chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
486                       else $error("D6int is not LOW for a Bscan instruction: EXTEST PULSE");
487        
488                       chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one: assert property ($past(stap_fsm_rti) |-> !stap_fbscan_d6actestsig_b)
489                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST PULSE");
490        
491                    end
                       MISSING_ELSE
                       ==>
492                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


499                 if (stap_fsm_tlrs === LOW)
                    -1-  
500                 begin
501                    if (($past(inst_clamp,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_CLAMP))
                       -2-  
502                    begin
503        
504                       chk_if_bscan_ex1_clamp_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
505                       else $error("Mode is not High for a Bscan instruction: CLAMP");
506        
507                       chk_if_bscan_ex2_clamp_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
508                       else $error("HIGHZ is not Low for a Bscan instruction: CLAMP");
509        
510                       chk_if_bscan_ex3_clamp_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
511                       else $error("Chain enable is not high for a Bscan instruction: CLAMP");
512        
513                       chk_if_bscan_ex4_clamp_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
514                       else $error("Extog enable is not Low for a Bscan instruction: CLAMP");
515        
516                       chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
517                       else $error("Extogsig is not high for a Bscan instruction: CLAMP");
518        
519                       chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
520                       else $error("D6Select is not LOW  for a Bscan instruction: CLAMP");
521        
522                       chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
523                       else $error("D6int is not LOW for a Bscan instruction: CLAMP");
524        
525                       chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
526                       else $error("D6actsig_b is not HIGH for a Bscan instruction: CLAMP");
527        
528                    end
                       MISSING_ELSE
                       ==>
529                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


537                 if (stap_fsm_tlrs === LOW)
                    -1-  
538                 begin
539                    if (($past(inst_highz,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_HIGHZ))
                       -2-  
540                    begin
541        
542                       chk_if_bscan_ex1_highz_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
543                       else $error("Mode is not High for a Bscan instruction: HIGHZ");
544        
545                       chk_if_bscan_ex2_highz_then_highz_equals_one: assert (stap_fbscan_highz === HIGH)
546                       else $error("HIGHZ is not HIGH for a Bscan instruction: HIGHZ");
547        
548                       chk_if_bscan_ex3_highz_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
549                       else $error("Chain enable is not high for a Bscan instruction: HIGHZ");
550        
551                       chk_if_bscan_ex4_highz_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
552                       else $error("Extog enable is not Low for a Bscan instruction: HIGHZ");
553        
554                       chk_if_bscan_ex5_highz_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
555                       else $error("Extogsig is not high for a Bscan instruction: HIGHZ");
556        
557                       chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
558                       else $error("D6Select is not LOW  for a Bscan instruction: HIGHZ");
559        
560                       chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
561                       else $error("D6int is not LOW for a Bscan instruction: HIGHZ");
562        
563                       chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
564                       else $error("D6actsig_b is not HIGH for a Bscan instruction: HIGHZ");
565        
566                    end
                       MISSING_ELSE
                       ==>
567                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


574                 if (stap_fsm_tlrs === LOW)
                    -1-  
575                 begin
576                    if (($past(inst_preload,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_PRELOAD))
                       -2-  
577                    begin
578                       chk_if_bscan_ex1_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
579                       else $error("Mode is not Low for a Bscan instruction: PRELOAD");
580        
581                       chk_if_bscan_ex2_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
582                       else $error("HIGHZ is not Low for a Bscan instruction: PRELOAD");
583        
584                       chk_if_bscan_ex3_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
585                       else $error("Chain enable is not HIGH for a Bscan instruction: PRELOAD");
586        
587                       chk_if_bscan_ex4_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
588                       else $error("Extog enable is not Low for a Bscan instruction: PRELOAD");
589        
590                       chk_if_bscan_ex5_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
591                       else $error("Extogsig is not high for a Bscan instruction: PRELOAD");
592        
593                       chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
594                       else $error("D6Select is not LOW  for a Bscan instruction: PRELOAD");
595        
596                       chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
597                       else $error("D6int is not LOW for a Bscan instruction: PRELOAD");
598        
599                       chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
600                       else $error("D6actsig_b is not HIGH for a Bscan instruction: PRELOAD");
601        
602                    end
                       MISSING_ELSE
                       ==>
603                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


610                 if (stap_fsm_tlrs === LOW)
                    -1-  
611                 begin
612                    if (($past(inst_intest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_INTEST))
                       -2-  
613                    begin
614        
615                       chk_if_bscan_ex1_intest_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
616                       else $error("Mode is not LOW for a Bscan instruction: INTEST");
617        
618                       chk_if_bscan_ex2_intest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
619                       else $error("HIGHZ is not Low for a Bscan instruction: INTEST");
620        
621                       chk_if_bscan_ex3_intest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
622                       else $error("Chain enable is not High for a Bscan instruction: INTEST");
623        
624                       chk_if_bscan_ex4_intest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
625                       else $error("Extog enable is not Low for a Bscan instruction: INTEST");
626        
627                       chk_if_bscan_ex5_intest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
628                       else $error("Extogsig is not high for a Bscan instruction: INTEST");
629        
630                       chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
631                       else $error("D6Select is not LOW  for a Bscan instruction: INTEST");
632        
633                       chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
634                       else $error("D6int is not LOW for a Bscan instruction: INTEST");
635        
636                       chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
637                       else $error("D6actsig_b is not HIGH for a Bscan instruction: INTEST");
638        
639                    end
                       MISSING_ELSE
                       ==>
640                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_bscan_assertions 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       92    92        100.00  92                100.00  
Cover properties 8     8         100.00  7                 87.50   
Cover sequences  0     0                 0                         
Total            100   100       100.00  99                99.00   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                         Attempts Real Successes Failures Incomplete 
chk_if_bscan_ex1_at_reset_then_mode_equals_zero                              7682     7682           0        0          
chk_if_bscan_ex1_clamp_then_mode_equals_one                                  63       63             0        0          
chk_if_bscan_ex1_extest_pulse_then_mode_equals_one                           2772     2772           0        0          
chk_if_bscan_ex1_extest_tgl_then_mode_equals_one                             519      519            0        0          
chk_if_bscan_ex1_extest_then_mode_equals_one                                 2967     2967           0        0          
chk_if_bscan_ex1_extest_train_then_mode_equals_one                           2259     2259           0        0          
chk_if_bscan_ex1_highz_then_mode_equals_one                                  92       92             0        0          
chk_if_bscan_ex1_intest_then_mode_equals_zero                                2132     2132           0        0          
chk_if_bscan_ex1_preload_then_mode_equals_zero                               2692     2692           0        0          
chk_if_bscan_ex1_sample_preload_then_mode_equals_zero                        132      132            0        0          
chk_if_bscan_ex2_at_reset_then_highz_equals_zero                             7682     7682           0        0          
chk_if_bscan_ex2_clamp_then_highz_equals_zero                                63       63             0        0          
chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero                         2772     2772           0        0          
chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero                           519      519            0        0          
chk_if_bscan_ex2_extest_then_highz_equals_zero                               2967     2967           0        0          
chk_if_bscan_ex2_extest_train_then_highz_equals_zero                         2259     2259           0        0          
chk_if_bscan_ex2_highz_then_highz_equals_one                                 92       92             0        0          
chk_if_bscan_ex2_intest_then_highz_equals_zero                               2132     2132           0        0          
chk_if_bscan_ex2_preload_then_highz_equals_zero                              2692     2692           0        0          
chk_if_bscan_ex2_sample_preload_then_highz_equals_zero                       132      132            0        0          
chk_if_bscan_ex3_at_reset_then_chainen_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex3_clamp_then_chainen_equals_one                               63       63             0        0          
chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one                        2772     2772           0        0          
chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one                          519      519            0        0          
chk_if_bscan_ex3_extest_then_chainen_equals_one                              2967     2967           0        0          
chk_if_bscan_ex3_extest_train_then_chainen_equals_one                        2259     2259           0        0          
chk_if_bscan_ex3_highz_then_chainen_equals_one                               92       92             0        0          
chk_if_bscan_ex3_intest_then_chainen_equals_one                              2132     2132           0        0          
chk_if_bscan_ex3_preload_then_chainen_equals_one                             2692     2692           0        0          
chk_if_bscan_ex3_sample_preload_then_chainen_equals_one                      132      132            0        0          
chk_if_bscan_ex4_at_reset_then_extogen_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex4_clamp_then_extogen_equals_zero                              63       63             0        0          
chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero                       2772     2772           0        0          
chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one                          519      519            0        0          
chk_if_bscan_ex4_extest_then_extogen_equals_zero                             2967     2967           0        0          
chk_if_bscan_ex4_extest_train_then_extogen_equals_zero                       2259     2259           0        0          
chk_if_bscan_ex4_highz_then_extogen_equals_zero                              92       92             0        0          
chk_if_bscan_ex4_intest_then_extogen_equals_zero                             2132     2132           0        0          
chk_if_bscan_ex4_preload_then_extogen_equals_zero                            2692     2692           0        0          
chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero                     132      132            0        0          
chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one                         7682     7682           0        0          
chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one                            63       63             0        0          
chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one                     2772     2772           0        0          
chk_if_bscan_ex5_extest_then_extogsig_b_equals_one                           2967     2967           0        0          
chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one                     2259     2259           0        0          
chk_if_bscan_ex5_highz_then_extogsig_b_equals_one                            92       92             0        0          
chk_if_bscan_ex5_intest_then_extogsig_b_equals_one                           2132     2132           0        0          
chk_if_bscan_ex5_preload_then_extogsig_b_equals_one                          2692     2692           0        0          
chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one                   132      132            0        0          
chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active             80       80             0        0          
chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles                         439      439            0        0          
chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero                              63       63             0        0          
chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one                       2772     2772           0        0          
chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero                        519      519            0        0          
chk_if_bscan_ex6_extest_then_d6select_equals_zero                            2967     2967           0        0          
chk_if_bscan_ex6_extest_train_then_d6select_equals_one                       2259     2259           0        0          
chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero                              92       92             0        0          
chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero                             2132     2132           0        0          
chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero                            2692     2692           0        0          
chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero                     132      132            0        0          
chk_if_bscan_ex7_at_reset_then_d6init_equals_zero                            7682     7682           0        0          
chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero                       63       63             0        0          
chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse               85375    73             0        0          
chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero                  519      519            0        0          
chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse               85375    54             0        0          
chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero                       92       92             0        0          
chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero                      2132     2132           0        0          
chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero                     2692     2692           0        0          
chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero                      132      132            0        0          
chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one                      7682     7682           0        0          
chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one                 63       63             0        0          
chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one                2967     2967           0        0          
chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one          85375    276            0        0          
chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset 1848     1848           0        0          
chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles             411      411            0        0          
chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one                 92       92             0        0          
chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one                2132     2132           0        0          
chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one               2692     2692           0        0          
chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one                132      132            0        0          
chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active             80       80             0        0          
chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles                         439      439            0        0          
chk_if_bscan_ex9_extest_preload_then_d6init_equals_pulse                     85375    76             0        0          
chk_if_bscan_trainorpulse_then_d6select_equals_1                             85375    5155           0        0          
chk_stap_bscan_falling_capturedr_during_posedge_clk                          170745   818            0        0          
chk_stap_bscan_falling_shiftdr_during_posedge_clk                            170745   24552          0        0          
chk_stap_bscan_falling_updatedr_clk_during_posedge_clk                       170745   818            0        0          
chk_stap_bscan_falling_updatedr_during_posedge_clk                           170745   818            0        0          
chk_stap_bscan_raising_capturedr_during_posedge_clk                          170745   818            0        0          
chk_stap_bscan_raising_shiftdr_during_posedge_clk                            170745   24552          0        0          
chk_stap_bscan_raising_updatedr_clk_during_negedge_clk                       170745   818            0        0          
chk_stap_bscan_raising_updatedr_during_posedge_clk                           170745   818            0        0          


-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                                                   Attempts Matches Incomplete 
cov_stap_bscan_falling_capturedr_during_negedge_clk    170745   409     0          
cov_stap_bscan_falling_shiftdr_during_negedge_clk      170745   409     0          
cov_stap_bscan_falling_updatedr_clk_during_negedge_clk 170745   409     0          
cov_stap_bscan_falling_updatedr_during_negedge_clk     170745   409     0          
cov_stap_bscan_raising_capturedr_during_negedge_clk    170745   409     0          
cov_stap_bscan_raising_shiftdr_during_negedge_clk      170745   409     0          
cov_stap_bscan_raising_updatedr_clk_during_posedge_clk 170745   0       0          
cov_stap_bscan_raising_updatedr_during_negedge_clk     170745   409     0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.75 100.00 --     100.00 --     100.00  99.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.75 100.00 --     100.00 --     100.00  99.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
 99.37 100.00 --      98.46 --     100.00  99.00 STAP_RTL_LIB.stap_bscan_assertions 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Line Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x)

             Line No.   Total   Covered  Percent
TOTAL                       27       27   100.00
ALWAYS            257        3        3   100.00
ALWAYS            291        2        2   100.00
ALWAYS            328        2        2   100.00
ALWAYS            373        3        3   100.00
ALWAYS            420        4        4   100.00
ALWAYS            463        4        4   100.00
ALWAYS            499        2        2   100.00
ALWAYS            537        2        2   100.00
ALWAYS            574        2        2   100.00
ALWAYS            610        2        2   100.00
ALWAYS            651        1        1   100.00

256                           begin
257        1/1                   if (stap_fsm_tlrs === HIGH)
258                              begin
259        2/2                      #1ps;
260                                 chk_if_bscan_ex1_at_reset_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
261                                 else $error("Mode is not Low at Reset");
262                     
263                                 chk_if_bscan_ex2_at_reset_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
264                                 else $error("HighZ is not Low at Reset");
265                     
266                                 chk_if_bscan_ex3_at_reset_then_chainen_equals_zero: assert (stap_fbscan_chainen === LOW)
267                                 else $error("Chain enable is not Low at Reset");
268                     
269                                 chk_if_bscan_ex4_at_reset_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
270                                 else $error("Extog enable is not Low at Reset");
271                     
272                                 chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
273                                 else $error("Extogsig is not HIGH at Reset");
274                     
275                                 chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
276                                 else $error("D6Select is not LOW at Reset");
277                     
278                                 chk_if_bscan_ex7_at_reset_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
279                                 else $error("D6int is not LOW at Reset");
280                     
281                                 chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
282                                 else $error("D6actsig_b is not HIGH at Reset");
283                     
284                              end
                        MISSING_ELSE
285                           end
286                           // ====================================================================
287                           // Check for BSCAN sigals during SAMPLE/PRELOAD instruction
288                           // ====================================================================
289                           always @(negedge ftap_tck)
290                           begin
291        1/1                   if (stap_fsm_tlrs === LOW)
292                              begin
293        1/1                      if (($past(inst_sampre,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD))
294                                 begin
295                     
296                                    chk_if_bscan_ex1_sample_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
297                                    else $error("Mode is not Low for a Bscan instruction: SAMPLE_PRELOAD");
298                     
299                                    chk_if_bscan_ex2_sample_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
300                                    else $error("HighZ is not Low for a Bscan instruction: SAMPLE_PRELOAD");
301                     
302                                    chk_if_bscan_ex3_sample_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
303                                    else $error("Chain enable is not High for a Bscan instruction: SAMPLE_PRELOAD");
304                     
305                                    chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
306                                    else $error("Extog enable is not Low for a Bscan instruction: SAMPLE_PRELOAD");
307                     
308                                    chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
309                                    else $error("Extogsig is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
310                     
311                                    chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
312                                    else $error("D6Select is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
313                     
314                                    chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
315                                    else $error("D6int is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
316                     
317                                    chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
318                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
319                     
320                                 end
                        MISSING_ELSE
321                              end
                        MISSING_ELSE
322                           end
323                           // ====================================================================
324                           // Check for BSCAN sigals during EXTEST instruction
325                           // ====================================================================
326                           always @(negedge ftap_tck)
327                           begin
328        1/1                   if (stap_fsm_tlrs === LOW)
329                              begin
330        1/1                      if (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))
331                                 begin
332                     
333                                    chk_if_bscan_ex1_extest_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
334                                    else $error("Mode is not High for a Bscan instruction: EXTEST");
335                     
336                                    chk_if_bscan_ex2_extest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
337                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST");
338                     
339                                    chk_if_bscan_ex3_extest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
340                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST");
341                     
342                                    chk_if_bscan_ex4_extest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
343                                    else $error("Extog enable is not Low for a Bscan instruction: EXTEST");
344                     
345                                    chk_if_bscan_ex5_extest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
346                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST");
347                     
348                                    chk_if_bscan_ex6_extest_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
349                                    else $error("D6Select is not LOW  for a Bscan instruction: EXTEST");
350                     
351                                   // chk_if_bscan_ex7_extest_preload_then_d6init_equals_pulse: assert property (stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
352                                   // else $error("D6int is not Pulse for a Bscan instruction: EXTEST");
353                     
354                                    chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
355                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST");
356                     
357                                 end
                        MISSING_ELSE
358                              end
                        MISSING_ELSE
359                           end
360                          property my_chk;
361                            @(negedge ftap_tck)
362                     
363                            ((stap_fsm_tlrs === LOW) && (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))) && stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init;
364                     
365                           endproperty
366                     
367                     
368                     chk_if_bscan_ex9_extest_preload_then_d6init_equals_pulse: assert property (my_chk); // ====================================================================
369                           // Check for BSCAN sigals during EXTEST TOGGLE instruction
370                           // ====================================================================
371                           always @(negedge ftap_tck)
372                           begin
373        1/1                   if (stap_fsm_tlrs === LOW)
374                              begin
375        1/1                      if (($past(stap_fbscan_extogen,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) && (stap_fsm_rti === HIGH))
376                                 begin
377                     
378                                    chk_if_bscan_ex1_extest_tgl_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
379                                    else $error("Mode is not High for a Bscan instruction: EXTEST TOGGLE");
380                     
381                                    chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
382                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TOGGLE");
383                     
384                                    chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
385                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST TOGGLE");
386                     
387                                    chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one: assert (stap_fbscan_extogen === HIGH)
388                                    else $error("Extog enable is not high for a Bscan instruction: EXTEST TOGGLE");
389                     
390        1/1                         if($past(stap_fsm_rti,1) === 1'b0) begin
391                                       chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active: assert (stap_fbscan_extogsig_b === HIGH)
392                                       else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
393                     
394                                       chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active: assert (stap_fbscan_d6actestsig_b === HIGH)
395                                       else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
396                     
397                                    end else begin
398                                       chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles: assert (stap_fbscan_extogsig_b !== $past(stap_fbscan_extogsig_b,1))
399                                       else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
400                     
401                                       chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
402                                       else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
403                                    end
404                     
405                                    chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
406                                    else $error("D6Select is not LOW  for a Bscan instruction: EXTEST TOGGLE");
407                     
408                                    chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
409                                    else $error("D6int is not LOW for a Bscan instruction: EXTEST TOGGLE");
410                     
411                                 end
                        MISSING_ELSE
412                              end
                        MISSING_ELSE
413                           end
414                     
415                           // ====================================================================
416                           // Check for BSCAN sigals during EXTEST TRAIN instruction
417                           // ====================================================================
418                           always @(negedge ftap_tck)
419                           begin
420        1/1                   if (stap_fsm_tlrs === LOW)
421                              begin
422        1/1                      if (($past(inst_extest_train,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN))
423                                 begin
424                     
425                                    chk_if_bscan_ex1_extest_train_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
426                                    else $error("Mode is not High for a Bscan instruction: EXTEST TRAIN");
427                     
428                                    chk_if_bscan_ex2_extest_train_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
429                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TRAIN");
430                     
431                                    chk_if_bscan_ex3_extest_train_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
432                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST TRAIN");
433                     
434                                    chk_if_bscan_ex4_extest_train_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
435                                    else $error("Extog enable is not low for a Bscan instruction: EXTEST TRAIN");
436                     
437                                    chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
438                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST TRAIN");
439                     
440                                    chk_if_bscan_ex6_extest_train_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
441                                    else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST TRAIN");
442                     
443        1/1                         chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
444                                    else $error("D6int is not a pulse for a Bscan instruction: EXTEST TRAIN");
445                     
446        1/1                         if($past(stap_fsm_rti,1) === 1'b0) begin
447                                       chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset: assert (stap_fbscan_d6actestsig_b === HIGH)
448                                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
449                                    end else begin
450                                       chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
451                                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
452                                    end
453                     
454                                 end
                        MISSING_ELSE
455                              end
                        MISSING_ELSE
456                           end
457                     
458                           // ====================================================================
459                           // Check for BSCAN sigals during EXTEST PULSE instruction
460                           // ====================================================================
461                           always @(negedge ftap_tck)
462                           begin
463        1/1                   if (stap_fsm_tlrs === LOW)
464                              begin
465        1/1                      if (($past(inst_extest_pulse,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE))
466                                 begin
467                                    chk_if_bscan_ex1_extest_pulse_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
468                                    else $error("Mode is not HIGH for a Bscan instruction: EXTEST PULSE");
469                     
470                                    chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
471                                    else $error("HIGHZ is not Low for a Bscan instruction: EXTEST PULSE");
472                     
473                                    chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
474                                    else $error("Chain enable is not high for a Bscan instruction: EXTEST PULSE");
475                     
476                                    chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
477                                    else $error("Extog enable is not low for a Bscan instruction: EXTEST PULSE");
478                     
479                                    chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
480                                    else $error("Extogsig is not high for a Bscan instruction: EXTEST PULSE");
481                     
482                                    chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
483                                    else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST PULSE");
484                     
485        1/1                         chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
486                                    else $error("D6int is not LOW for a Bscan instruction: EXTEST PULSE");
487                     
488        1/1                         chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one: assert property ($past(stap_fsm_rti) |-> !stap_fbscan_d6actestsig_b)
489                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST PULSE");
490                     
491                                 end
                        MISSING_ELSE
492                              end
                        MISSING_ELSE
493                           end
494                           // ====================================================================
495                           // Check for BSCAN sigals during CLAMP instruction
496                           // ====================================================================
497                           always @(negedge ftap_tck)
498                           begin
499        1/1                   if (stap_fsm_tlrs === LOW)
500                              begin
501        1/1                      if (($past(inst_clamp,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_CLAMP))
502                                 begin
503                     
504                                    chk_if_bscan_ex1_clamp_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
505                                    else $error("Mode is not High for a Bscan instruction: CLAMP");
506                     
507                                    chk_if_bscan_ex2_clamp_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
508                                    else $error("HIGHZ is not Low for a Bscan instruction: CLAMP");
509                     
510                                    chk_if_bscan_ex3_clamp_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
511                                    else $error("Chain enable is not high for a Bscan instruction: CLAMP");
512                     
513                                    chk_if_bscan_ex4_clamp_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
514                                    else $error("Extog enable is not Low for a Bscan instruction: CLAMP");
515                     
516                                    chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
517                                    else $error("Extogsig is not high for a Bscan instruction: CLAMP");
518                     
519                                    chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
520                                    else $error("D6Select is not LOW  for a Bscan instruction: CLAMP");
521                     
522                                    chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
523                                    else $error("D6int is not LOW for a Bscan instruction: CLAMP");
524                     
525                                    chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
526                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: CLAMP");
527                     
528                                 end
                        MISSING_ELSE
529                              end
                        MISSING_ELSE
530                           end
531                     
532                           // ====================================================================
533                           // Check for BSCAN sigals during HIGHZ instruction
534                           // ====================================================================
535                           always @(negedge ftap_tck)
536                           begin
537        1/1                   if (stap_fsm_tlrs === LOW)
538                              begin
539        1/1                      if (($past(inst_highz,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_HIGHZ))
540                                 begin
541                     
542                                    chk_if_bscan_ex1_highz_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
543                                    else $error("Mode is not High for a Bscan instruction: HIGHZ");
544                     
545                                    chk_if_bscan_ex2_highz_then_highz_equals_one: assert (stap_fbscan_highz === HIGH)
546                                    else $error("HIGHZ is not HIGH for a Bscan instruction: HIGHZ");
547                     
548                                    chk_if_bscan_ex3_highz_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
549                                    else $error("Chain enable is not high for a Bscan instruction: HIGHZ");
550                     
551                                    chk_if_bscan_ex4_highz_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
552                                    else $error("Extog enable is not Low for a Bscan instruction: HIGHZ");
553                     
554                                    chk_if_bscan_ex5_highz_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
555                                    else $error("Extogsig is not high for a Bscan instruction: HIGHZ");
556                     
557                                    chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
558                                    else $error("D6Select is not LOW  for a Bscan instruction: HIGHZ");
559                     
560                                    chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
561                                    else $error("D6int is not LOW for a Bscan instruction: HIGHZ");
562                     
563                                    chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
564                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: HIGHZ");
565                     
566                                 end
                        MISSING_ELSE
567                              end
                        MISSING_ELSE
568                           end
569                           // ====================================================================
570                           // Check for BSCAN sigals during PRELOAD instruction
571                           // ====================================================================
572                           always @(negedge ftap_tck)
573                           begin
574        1/1                   if (stap_fsm_tlrs === LOW)
575                              begin
576        1/1                      if (($past(inst_preload,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_PRELOAD))
577                                 begin
578                                    chk_if_bscan_ex1_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
579                                    else $error("Mode is not Low for a Bscan instruction: PRELOAD");
580                     
581                                    chk_if_bscan_ex2_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
582                                    else $error("HIGHZ is not Low for a Bscan instruction: PRELOAD");
583                     
584                                    chk_if_bscan_ex3_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
585                                    else $error("Chain enable is not HIGH for a Bscan instruction: PRELOAD");
586                     
587                                    chk_if_bscan_ex4_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
588                                    else $error("Extog enable is not Low for a Bscan instruction: PRELOAD");
589                     
590                                    chk_if_bscan_ex5_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
591                                    else $error("Extogsig is not high for a Bscan instruction: PRELOAD");
592                     
593                                    chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
594                                    else $error("D6Select is not LOW  for a Bscan instruction: PRELOAD");
595                     
596                                    chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
597                                    else $error("D6int is not LOW for a Bscan instruction: PRELOAD");
598                     
599                                    chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
600                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: PRELOAD");
601                     
602                                 end
                        MISSING_ELSE
603                              end
                        MISSING_ELSE
604                           end
605                           // ====================================================================
606                           // Check for BSCAN sigals during INTEST instruction
607                           // ====================================================================
608                           always @(negedge ftap_tck)
609                           begin
610        1/1                   if (stap_fsm_tlrs === LOW)
611                              begin
612        1/1                      if (($past(inst_intest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_INTEST))
613                                 begin
614                     
615                                    chk_if_bscan_ex1_intest_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
616                                    else $error("Mode is not LOW for a Bscan instruction: INTEST");
617                     
618                                    chk_if_bscan_ex2_intest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
619                                    else $error("HIGHZ is not Low for a Bscan instruction: INTEST");
620                     
621                                    chk_if_bscan_ex3_intest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
622                                    else $error("Chain enable is not High for a Bscan instruction: INTEST");
623                     
624                                    chk_if_bscan_ex4_intest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
625                                    else $error("Extog enable is not Low for a Bscan instruction: INTEST");
626                     
627                                    chk_if_bscan_ex5_intest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
628                                    else $error("Extogsig is not high for a Bscan instruction: INTEST");
629                     
630                                    chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
631                                    else $error("D6Select is not LOW  for a Bscan instruction: INTEST");
632                     
633                                    chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
634                                    else $error("D6int is not LOW for a Bscan instruction: INTEST");
635                     
636                                    chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
637                                    else $error("D6actsig_b is not HIGH for a Bscan instruction: INTEST");
638                     
639                                 end
                        MISSING_ELSE
640                              end
                        MISSING_ELSE
641                           end
642                     
643                           // =============================================================================================
644                           // Check if extest_train or pulse is choosed. Then Check if reset you are not in TLRS.
645                           // Then in the same clk cycle as when TLRS is low, check if d6select is equal to train_or_pluse.
646                           // =============================================================================================
647                           always @(negedge ftap_tck)
648                           begin
649                              chk_if_bscan_trainorpulse_then_d6select_equals_1:
650                              //assume property ((train_or_pulse) ##1 (stap_fsm_tlrs === LOW) |-> stap_fbscan_d6select);
651        1/1                   assert property ((train_or_pulse) |-> stap_fbscan_d6select);

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x)
                Total Covered Percent 
Totals          49    49      100.00  
Total Bits      128   128     100.00  
Total Bits 0->1 64    64      100.00  
Total Bits 1->0 64    64      100.00  

                            
Ports          28 28 100.00 
Port Bits      86 86 100.00 
Port Bits 0->1 43 43 100.00 
Port Bits 1->0 43 43 100.00 

                              
Signals          21 21 100.00 
Signal Bits      42 42 100.00 
Signal Bits 0->1 21 21 100.00 
Signal Bits 1->0 21 21 100.00 

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                  Yes    Yes         Yes         INPUT     
stap_fbscan_capturedr     Yes    Yes         Yes         INPUT     
powergood_rst_trst_b      Yes    Yes         Yes         INPUT     
stap_fbscan_shiftdr       Yes    Yes         Yes         INPUT     
stap_fbscan_updatedr      Yes    Yes         Yes         INPUT     
stap_fbscan_updatedr_clk  Yes    Yes         Yes         INPUT     
stap_fsm_tlrs             Yes    Yes         Yes         INPUT     
stap_fbscan_mode          Yes    Yes         Yes         INPUT     
stap_fbscan_highz         Yes    Yes         Yes         INPUT     
stap_fbscan_chainen       Yes    Yes         Yes         INPUT     
stap_fbscan_extogen       Yes    Yes         Yes         INPUT     
stap_fbscan_extogsig_b    Yes    Yes         Yes         INPUT     
stap_fbscan_d6select      Yes    Yes         Yes         INPUT     
stap_fbscan_d6init        Yes    Yes         Yes         INPUT     
stap_fbscan_d6actestsig_b Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]     Yes    Yes         Yes         INPUT     
inst_extest               Yes    Yes         Yes         INPUT     
inst_sampre               Yes    Yes         Yes         INPUT     
stap_fsm_capture_dr       Yes    Yes         Yes         INPUT     
stap_fsm_rti              Yes    Yes         Yes         INPUT     
inst_extest_train         Yes    Yes         Yes         INPUT     
e1dr_or_e2dr              Yes    Yes         Yes         INPUT     
inst_extest_pulse         Yes    Yes         Yes         INPUT     
inst_clamp                Yes    Yes         Yes         INPUT     
inst_highz                Yes    Yes         Yes         INPUT     
inst_preload              Yes    Yes         Yes         INPUT     
inst_intest               Yes    Yes         Yes         INPUT     
train_or_pulse            Yes    Yes         Yes         INPUT     

Signal Details
                                       Toggle   Toggle 1->0 Toggle 0->1 
ftap_tck_delayed_by_1ps                Yes      Yes         Yes         
ftap_clk_raising_edge_pulse            Yes      Yes         Yes         
ftap_clk_falling_edge_pulse            Yes      Yes         Yes         
fbscan_capturedr_delayed_by_1ps        Yes      Yes         Yes         
fbscan_capturedr_raising_edge_pulse    Yes      Yes         Yes         
fbscan_capturedr_falling_edge_pulse    Yes      Yes         Yes         
capturedr_raising_valid                Yes      Yes         Yes         
capturedr_falling_valid                Yes      Yes         Yes         
fbscan_shiftdr_delayed_by_1ps          Yes      Yes         Yes         
fbscan_shiftdr_raising_edge_pulse      Yes      Yes         Yes         
fbscan_shiftdr_falling_edge_pulse      Yes      Yes         Yes         
shiftdr_raising_valid                  Yes      Yes         Yes         
shiftdr_falling_valid                  Yes      Yes         Yes         
fbscan_updatedr_delayed_by_1ps         Yes      Yes         Yes         
fbscan_updatedr_raising_edge_pulse     Yes      Yes         Yes         
fbscan_updatedr_falling_edge_pulse     Yes      Yes         Yes         
updatedr_raising_valid                 Yes      Yes         Yes         
updatedr_falling_valid                 Yes      Yes         Yes         
fbscan_updatedr_clk_delayed_by_1ps     Yes      Yes         Yes         
fbscan_updatedr_clk_raising_edge_pulse Yes      Yes         Yes         
fbscan_updatedr_clk_falling_edge_pulse Yes      Yes         Yes         
updatedr_clk_raising_valid             Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x)
         Line No. Total Covered Percent 
Branches          31    31      100.00  
IF       257      2     2       100.00  
IF       291      3     3       100.00  
IF       328      3     3       100.00  
IF       373      4     4       100.00  
IF       420      4     4       100.00  
IF       463      3     3       100.00  
IF       499      3     3       100.00  
IF       537      3     3       100.00  
IF       574      3     3       100.00  
IF       610      3     3       100.00  


257                 if (stap_fsm_tlrs === HIGH)
                    -1-  
258                 begin
259                    #1ps;
                       ==>
260                    chk_if_bscan_ex1_at_reset_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
261                    else $error("Mode is not Low at Reset");
262        
263                    chk_if_bscan_ex2_at_reset_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
264                    else $error("HighZ is not Low at Reset");
265        
266                    chk_if_bscan_ex3_at_reset_then_chainen_equals_zero: assert (stap_fbscan_chainen === LOW)
267                    else $error("Chain enable is not Low at Reset");
268        
269                    chk_if_bscan_ex4_at_reset_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
270                    else $error("Extog enable is not Low at Reset");
271        
272                    chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
273                    else $error("Extogsig is not HIGH at Reset");
274        
275                    chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
276                    else $error("D6Select is not LOW at Reset");
277        
278                    chk_if_bscan_ex7_at_reset_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
279                    else $error("D6int is not LOW at Reset");
280        
281                    chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
282                    else $error("D6actsig_b is not HIGH at Reset");
283        
284                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


291                 if (stap_fsm_tlrs === LOW)
                    -1-  
292                 begin
293                    if (($past(inst_sampre,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD))
                       -2-  
294                    begin
295        
296                       chk_if_bscan_ex1_sample_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
297                       else $error("Mode is not Low for a Bscan instruction: SAMPLE_PRELOAD");
298        
299                       chk_if_bscan_ex2_sample_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
300                       else $error("HighZ is not Low for a Bscan instruction: SAMPLE_PRELOAD");
301        
302                       chk_if_bscan_ex3_sample_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
303                       else $error("Chain enable is not High for a Bscan instruction: SAMPLE_PRELOAD");
304        
305                       chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
306                       else $error("Extog enable is not Low for a Bscan instruction: SAMPLE_PRELOAD");
307        
308                       chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
309                       else $error("Extogsig is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
310        
311                       chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
312                       else $error("D6Select is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
313        
314                       chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
315                       else $error("D6int is not LOW for a Bscan instruction: SAMPLE_PRELOAD");
316        
317                       chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
318                       else $error("D6actsig_b is not HIGH for a Bscan instruction: SAMPLE_PRELOAD");
319        
320                    end
                       MISSING_ELSE
                       ==>
321                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


328                 if (stap_fsm_tlrs === LOW)
                    -1-  
329                 begin
330                    if (($past(inst_extest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST))
                       -2-  
331                    begin
332        
333                       chk_if_bscan_ex1_extest_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
334                       else $error("Mode is not High for a Bscan instruction: EXTEST");
335        
336                       chk_if_bscan_ex2_extest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
337                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST");
338        
339                       chk_if_bscan_ex3_extest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
340                       else $error("Chain enable is not high for a Bscan instruction: EXTEST");
341        
342                       chk_if_bscan_ex4_extest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
343                       else $error("Extog enable is not Low for a Bscan instruction: EXTEST");
344        
345                       chk_if_bscan_ex5_extest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
346                       else $error("Extogsig is not high for a Bscan instruction: EXTEST");
347        
348                       chk_if_bscan_ex6_extest_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
349                       else $error("D6Select is not LOW  for a Bscan instruction: EXTEST");
350        
351                      // chk_if_bscan_ex7_extest_preload_then_d6init_equals_pulse: assert property (stap_fsm_capture_dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
352                      // else $error("D6int is not Pulse for a Bscan instruction: EXTEST");
353        
354                       chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
355                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST");
356        
357                    end
                       MISSING_ELSE
                       ==>
358                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


373                 if (stap_fsm_tlrs === LOW)
                    -1-  
374                 begin
375                    if (($past(stap_fbscan_extogen,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) && (stap_fsm_rti === HIGH))
                       -2-  
376                    begin
377        
378                       chk_if_bscan_ex1_extest_tgl_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
379                       else $error("Mode is not High for a Bscan instruction: EXTEST TOGGLE");
380        
381                       chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
382                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TOGGLE");
383        
384                       chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
385                       else $error("Chain enable is not high for a Bscan instruction: EXTEST TOGGLE");
386        
387                       chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one: assert (stap_fbscan_extogen === HIGH)
388                       else $error("Extog enable is not high for a Bscan instruction: EXTEST TOGGLE");
389        
390                       if($past(stap_fsm_rti,1) === 1'b0) begin
                          -3-  
391                          chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active: assert (stap_fbscan_extogsig_b === HIGH)
                             ==>
392                          else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
393        
394                          chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active: assert (stap_fbscan_d6actestsig_b === HIGH)
395                          else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
396        
397                       end else begin
398                          chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles: assert (stap_fbscan_extogsig_b !== $past(stap_fbscan_extogsig_b,1))
                             ==>
399                          else $error("Extogsig is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
400        
401                          chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
402                          else $error("D6actsig_b is not high for a Bscan instruction when not in RUTI state: EXTEST TOGGLE");
403                       end
404        
405                       chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero: assert (stap_fbscan_d6select === LOW)
406                       else $error("D6Select is not LOW  for a Bscan instruction: EXTEST TOGGLE");
407        
408                       chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
409                       else $error("D6int is not LOW for a Bscan instruction: EXTEST TOGGLE");
410        
411                    end
                       MISSING_ELSE
                       ==>
412                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- -3- Status  
1   1   1   Covered 
1   1   0   Covered 
1   0   -   Covered 
0   -   -   Covered 


420                 if (stap_fsm_tlrs === LOW)
                    -1-  
421                 begin
422                    if (($past(inst_extest_train,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN))
                       -2-  
423                    begin
424        
425                       chk_if_bscan_ex1_extest_train_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
426                       else $error("Mode is not High for a Bscan instruction: EXTEST TRAIN");
427        
428                       chk_if_bscan_ex2_extest_train_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
429                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST TRAIN");
430        
431                       chk_if_bscan_ex3_extest_train_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
432                       else $error("Chain enable is not high for a Bscan instruction: EXTEST TRAIN");
433        
434                       chk_if_bscan_ex4_extest_train_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
435                       else $error("Extog enable is not low for a Bscan instruction: EXTEST TRAIN");
436        
437                       chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
438                       else $error("Extogsig is not high for a Bscan instruction: EXTEST TRAIN");
439        
440                       chk_if_bscan_ex6_extest_train_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
441                       else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST TRAIN");
442        
443                       chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
444                       else $error("D6int is not a pulse for a Bscan instruction: EXTEST TRAIN");
445        
446                       if($past(stap_fsm_rti,1) === 1'b0) begin
                          -3-  
447                          chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset: assert (stap_fbscan_d6actestsig_b === HIGH)
                             ==>
448                          else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
449                       end else begin
450                          chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles: assert (stap_fbscan_d6actestsig_b !== $past(stap_fbscan_d6actestsig_b,1))
                             ==>
451                          else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST TRAIN");
452                       end
453        
454                    end
                       MISSING_ELSE
                       ==>
455                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- -3- Status  
1   1   1   Covered 
1   1   0   Covered 
1   0   -   Covered 
0   -   -   Covered 


463                 if (stap_fsm_tlrs === LOW)
                    -1-  
464                 begin
465                    if (($past(inst_extest_pulse,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE))
                       -2-  
466                    begin
467                       chk_if_bscan_ex1_extest_pulse_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
468                       else $error("Mode is not HIGH for a Bscan instruction: EXTEST PULSE");
469        
470                       chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
471                       else $error("HIGHZ is not Low for a Bscan instruction: EXTEST PULSE");
472        
473                       chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
474                       else $error("Chain enable is not high for a Bscan instruction: EXTEST PULSE");
475        
476                       chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
477                       else $error("Extog enable is not low for a Bscan instruction: EXTEST PULSE");
478        
479                       chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
480                       else $error("Extogsig is not high for a Bscan instruction: EXTEST PULSE");
481        
482                       chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one: assert (stap_fbscan_d6select === HIGH)
483                       else $error("D6Select is not HIGH  for a Bscan instruction: EXTEST PULSE");
484        
485                       chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse: assert property (e1dr_or_e2dr |=> stap_fbscan_d6init ##1 !stap_fbscan_d6init)
486                       else $error("D6int is not LOW for a Bscan instruction: EXTEST PULSE");
487        
488                       chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one: assert property ($past(stap_fsm_rti) |-> !stap_fbscan_d6actestsig_b)
489                       else $error("D6actsig_b is not HIGH for a Bscan instruction: EXTEST PULSE");
490        
491                    end
                       MISSING_ELSE
                       ==>
492                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


499                 if (stap_fsm_tlrs === LOW)
                    -1-  
500                 begin
501                    if (($past(inst_clamp,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_CLAMP))
                       -2-  
502                    begin
503        
504                       chk_if_bscan_ex1_clamp_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
505                       else $error("Mode is not High for a Bscan instruction: CLAMP");
506        
507                       chk_if_bscan_ex2_clamp_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
508                       else $error("HIGHZ is not Low for a Bscan instruction: CLAMP");
509        
510                       chk_if_bscan_ex3_clamp_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
511                       else $error("Chain enable is not high for a Bscan instruction: CLAMP");
512        
513                       chk_if_bscan_ex4_clamp_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
514                       else $error("Extog enable is not Low for a Bscan instruction: CLAMP");
515        
516                       chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
517                       else $error("Extogsig is not high for a Bscan instruction: CLAMP");
518        
519                       chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
520                       else $error("D6Select is not LOW  for a Bscan instruction: CLAMP");
521        
522                       chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
523                       else $error("D6int is not LOW for a Bscan instruction: CLAMP");
524        
525                       chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
526                       else $error("D6actsig_b is not HIGH for a Bscan instruction: CLAMP");
527        
528                    end
                       MISSING_ELSE
                       ==>
529                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


537                 if (stap_fsm_tlrs === LOW)
                    -1-  
538                 begin
539                    if (($past(inst_highz,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_HIGHZ))
                       -2-  
540                    begin
541        
542                       chk_if_bscan_ex1_highz_then_mode_equals_one: assert (stap_fbscan_mode === HIGH)
                          ==>
543                       else $error("Mode is not High for a Bscan instruction: HIGHZ");
544        
545                       chk_if_bscan_ex2_highz_then_highz_equals_one: assert (stap_fbscan_highz === HIGH)
546                       else $error("HIGHZ is not HIGH for a Bscan instruction: HIGHZ");
547        
548                       chk_if_bscan_ex3_highz_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
549                       else $error("Chain enable is not high for a Bscan instruction: HIGHZ");
550        
551                       chk_if_bscan_ex4_highz_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
552                       else $error("Extog enable is not Low for a Bscan instruction: HIGHZ");
553        
554                       chk_if_bscan_ex5_highz_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
555                       else $error("Extogsig is not high for a Bscan instruction: HIGHZ");
556        
557                       chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
558                       else $error("D6Select is not LOW  for a Bscan instruction: HIGHZ");
559        
560                       chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
561                       else $error("D6int is not LOW for a Bscan instruction: HIGHZ");
562        
563                       chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
564                       else $error("D6actsig_b is not HIGH for a Bscan instruction: HIGHZ");
565        
566                    end
                       MISSING_ELSE
                       ==>
567                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


574                 if (stap_fsm_tlrs === LOW)
                    -1-  
575                 begin
576                    if (($past(inst_preload,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_PRELOAD))
                       -2-  
577                    begin
578                       chk_if_bscan_ex1_preload_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
579                       else $error("Mode is not Low for a Bscan instruction: PRELOAD");
580        
581                       chk_if_bscan_ex2_preload_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
582                       else $error("HIGHZ is not Low for a Bscan instruction: PRELOAD");
583        
584                       chk_if_bscan_ex3_preload_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
585                       else $error("Chain enable is not HIGH for a Bscan instruction: PRELOAD");
586        
587                       chk_if_bscan_ex4_preload_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
588                       else $error("Extog enable is not Low for a Bscan instruction: PRELOAD");
589        
590                       chk_if_bscan_ex5_preload_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
591                       else $error("Extogsig is not high for a Bscan instruction: PRELOAD");
592        
593                       chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
594                       else $error("D6Select is not LOW  for a Bscan instruction: PRELOAD");
595        
596                       chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
597                       else $error("D6int is not LOW for a Bscan instruction: PRELOAD");
598        
599                       chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
600                       else $error("D6actsig_b is not HIGH for a Bscan instruction: PRELOAD");
601        
602                    end
                       MISSING_ELSE
                       ==>
603                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


610                 if (stap_fsm_tlrs === LOW)
                    -1-  
611                 begin
612                    if (($past(inst_intest,1) === HIGH) && (stap_irreg_ireg === BSCAN_STAP_ADDRESS_OF_INTEST))
                       -2-  
613                    begin
614        
615                       chk_if_bscan_ex1_intest_then_mode_equals_zero: assert (stap_fbscan_mode === LOW)
                          ==>
616                       else $error("Mode is not LOW for a Bscan instruction: INTEST");
617        
618                       chk_if_bscan_ex2_intest_then_highz_equals_zero: assert (stap_fbscan_highz === LOW)
619                       else $error("HIGHZ is not Low for a Bscan instruction: INTEST");
620        
621                       chk_if_bscan_ex3_intest_then_chainen_equals_one: assert (stap_fbscan_chainen === HIGH)
622                       else $error("Chain enable is not High for a Bscan instruction: INTEST");
623        
624                       chk_if_bscan_ex4_intest_then_extogen_equals_zero: assert (stap_fbscan_extogen === LOW)
625                       else $error("Extog enable is not Low for a Bscan instruction: INTEST");
626        
627                       chk_if_bscan_ex5_intest_then_extogsig_b_equals_one: assert (stap_fbscan_extogsig_b === HIGH)
628                       else $error("Extogsig is not high for a Bscan instruction: INTEST");
629        
630                       chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero: assert (stap_fbscan_d6select === LOW)
631                       else $error("D6Select is not LOW  for a Bscan instruction: INTEST");
632        
633                       chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero: assert (stap_fbscan_d6init === LOW)
634                       else $error("D6int is not LOW for a Bscan instruction: INTEST");
635        
636                       chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one: assert (stap_fbscan_d6actestsig_b === HIGH)
637                       else $error("D6actsig_b is not HIGH for a Bscan instruction: INTEST");
638        
639                    end
                       MISSING_ELSE
                       ==>
640                 end
                    MISSING_ELSE
                    ==>

Branches:

-1- -2- Status  
1   1   Covered 
1   0   Covered 
0   -   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_bscan_assertions(x)
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       92    92        100.00  92                100.00  
Cover properties 8     8         100.00  7                 87.50   
Cover sequences  0     0                 0                         
Total            100   100       100.00  99                99.00   



-------------------------------------------------------------------------------

Assertion Details

Name                                                                         Attempts Real Successes Failures Incomplete 
chk_if_bscan_ex1_at_reset_then_mode_equals_zero                              7682     7682           0        0          
chk_if_bscan_ex1_clamp_then_mode_equals_one                                  63       63             0        0          
chk_if_bscan_ex1_extest_pulse_then_mode_equals_one                           2772     2772           0        0          
chk_if_bscan_ex1_extest_tgl_then_mode_equals_one                             519      519            0        0          
chk_if_bscan_ex1_extest_then_mode_equals_one                                 2967     2967           0        0          
chk_if_bscan_ex1_extest_train_then_mode_equals_one                           2259     2259           0        0          
chk_if_bscan_ex1_highz_then_mode_equals_one                                  92       92             0        0          
chk_if_bscan_ex1_intest_then_mode_equals_zero                                2132     2132           0        0          
chk_if_bscan_ex1_preload_then_mode_equals_zero                               2692     2692           0        0          
chk_if_bscan_ex1_sample_preload_then_mode_equals_zero                        132      132            0        0          
chk_if_bscan_ex2_at_reset_then_highz_equals_zero                             7682     7682           0        0          
chk_if_bscan_ex2_clamp_then_highz_equals_zero                                63       63             0        0          
chk_if_bscan_ex2_extest_pulse_then_highz_equals_zero                         2772     2772           0        0          
chk_if_bscan_ex2_extest_tgl_then_highz_equals_zero                           519      519            0        0          
chk_if_bscan_ex2_extest_then_highz_equals_zero                               2967     2967           0        0          
chk_if_bscan_ex2_extest_train_then_highz_equals_zero                         2259     2259           0        0          
chk_if_bscan_ex2_highz_then_highz_equals_one                                 92       92             0        0          
chk_if_bscan_ex2_intest_then_highz_equals_zero                               2132     2132           0        0          
chk_if_bscan_ex2_preload_then_highz_equals_zero                              2692     2692           0        0          
chk_if_bscan_ex2_sample_preload_then_highz_equals_zero                       132      132            0        0          
chk_if_bscan_ex3_at_reset_then_chainen_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex3_clamp_then_chainen_equals_one                               63       63             0        0          
chk_if_bscan_ex3_extest_pulse_then_chainen_equals_one                        2772     2772           0        0          
chk_if_bscan_ex3_extest_tgl_then_chainen_equals_one                          519      519            0        0          
chk_if_bscan_ex3_extest_then_chainen_equals_one                              2967     2967           0        0          
chk_if_bscan_ex3_extest_train_then_chainen_equals_one                        2259     2259           0        0          
chk_if_bscan_ex3_highz_then_chainen_equals_one                               92       92             0        0          
chk_if_bscan_ex3_intest_then_chainen_equals_one                              2132     2132           0        0          
chk_if_bscan_ex3_preload_then_chainen_equals_one                             2692     2692           0        0          
chk_if_bscan_ex3_sample_preload_then_chainen_equals_one                      132      132            0        0          
chk_if_bscan_ex4_at_reset_then_extogen_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex4_clamp_then_extogen_equals_zero                              63       63             0        0          
chk_if_bscan_ex4_extest_pulse_then_extogen_equals_zero                       2772     2772           0        0          
chk_if_bscan_ex4_extest_tgl_then_extogen_equals_one                          519      519            0        0          
chk_if_bscan_ex4_extest_then_extogen_equals_zero                             2967     2967           0        0          
chk_if_bscan_ex4_extest_train_then_extogen_equals_zero                       2259     2259           0        0          
chk_if_bscan_ex4_highz_then_extogen_equals_zero                              92       92             0        0          
chk_if_bscan_ex4_intest_then_extogen_equals_zero                             2132     2132           0        0          
chk_if_bscan_ex4_preload_then_extogen_equals_zero                            2692     2692           0        0          
chk_if_bscan_ex4_sample_preload_then_extogen_equals_zero                     132      132            0        0          
chk_if_bscan_ex5_at_reset_then_extogsig_b_equals_one                         7682     7682           0        0          
chk_if_bscan_ex5_clamp_then_extogsig_b_equals_one                            63       63             0        0          
chk_if_bscan_ex5_extest_pulse_then_extogsig_b_equals_one                     2772     2772           0        0          
chk_if_bscan_ex5_extest_then_extogsig_b_equals_one                           2967     2967           0        0          
chk_if_bscan_ex5_extest_train_then_extogsig_b_equals_one                     2259     2259           0        0          
chk_if_bscan_ex5_highz_then_extogsig_b_equals_one                            92       92             0        0          
chk_if_bscan_ex5_intest_then_extogsig_b_equals_one                           2132     2132           0        0          
chk_if_bscan_ex5_preload_then_extogsig_b_equals_one                          2692     2692           0        0          
chk_if_bscan_ex5_sample_preload_then_extogsig_b_equals_one                   132      132            0        0          
chk_if_bscan_ex5a_extest_tgl_then_extogsig_b_one_when_not_active             80       80             0        0          
chk_if_bscan_ex5b_extest_tgl_then_extogsig_b_toggles                         439      439            0        0          
chk_if_bscan_ex6_at_reset_then_d6sel_b_equals_zero                           7682     7682           0        0          
chk_if_bscan_ex6_clamp_then_d6sel_b_equals_zero                              63       63             0        0          
chk_if_bscan_ex6_extest_pulse_then_d6select_equals_one                       2772     2772           0        0          
chk_if_bscan_ex6_extest_tgl_then_d6select_equals_zero                        519      519            0        0          
chk_if_bscan_ex6_extest_then_d6select_equals_zero                            2967     2967           0        0          
chk_if_bscan_ex6_extest_train_then_d6select_equals_one                       2259     2259           0        0          
chk_if_bscan_ex6_highz_then_d6sel_b_equals_zero                              92       92             0        0          
chk_if_bscan_ex6_intest_then_d6sel_b_equals_zero                             2132     2132           0        0          
chk_if_bscan_ex6_preload_then_d6sel_b_equals_zero                            2692     2692           0        0          
chk_if_bscan_ex6_sample_preload_then_d6sel_b_equals_zero                     132      132            0        0          
chk_if_bscan_ex7_at_reset_then_d6init_equals_zero                            7682     7682           0        0          
chk_if_bscan_ex7_clamp_preload_then_d6init_equals_zero                       63       63             0        0          
chk_if_bscan_ex7_extest_pulse_preload_then_d6init_equals_pulse               85375    73             0        0          
chk_if_bscan_ex7_extest_tgl_preload_then_d6init_equals_zero                  519      519            0        0          
chk_if_bscan_ex7_extest_train_preload_then_d6init_equals_pulse               85375    54             0        0          
chk_if_bscan_ex7_highz_preload_then_d6init_equals_zero                       92       92             0        0          
chk_if_bscan_ex7_intest_preload_then_d6init_equals_zero                      2132     2132           0        0          
chk_if_bscan_ex7_preload_preload_then_d6init_equals_zero                     2692     2692           0        0          
chk_if_bscan_ex7_sample_preload_then_d6init_equals_zero                      132      132            0        0          
chk_if_bscan_ex8_at_reset_then_d6actestsig_b_equals_one                      7682     7682           0        0          
chk_if_bscan_ex8_clamp_preload_then_d6actestsig_b_equals_one                 63       63             0        0          
chk_if_bscan_ex8_extest_preload_then_d6actestsig_b_equals_one                2967     2967           0        0          
chk_if_bscan_ex8_extest_pulse_preload_then_d6actestsig_b_equals_one          85375    276            0        0          
chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_equals_one_at_reset 1848     1848           0        0          
chk_if_bscan_ex8_extest_train_preload_then_d6actestsig_b_toggles             411      411            0        0          
chk_if_bscan_ex8_highz_preload_then_d6actestsig_b_equals_one                 92       92             0        0          
chk_if_bscan_ex8_intest_preload_then_d6actestsig_b_equals_one                2132     2132           0        0          
chk_if_bscan_ex8_preload_preload_then_d6actestsig_b_equals_one               2692     2692           0        0          
chk_if_bscan_ex8_sample_preload_then_d6actestsig_b_equals_one                132      132            0        0          
chk_if_bscan_ex8a_extest_tgl_then_D6actsig_b_one_when_not_active             80       80             0        0          
chk_if_bscan_ex8b_extest_tgl_then_D6actsig_b_toggles                         439      439            0        0          
chk_if_bscan_ex9_extest_preload_then_d6init_equals_pulse                     85375    76             0        0          
chk_if_bscan_trainorpulse_then_d6select_equals_1                             85375    5155           0        0          
chk_stap_bscan_falling_capturedr_during_posedge_clk                          170745   818            0        0          
chk_stap_bscan_falling_shiftdr_during_posedge_clk                            170745   24552          0        0          
chk_stap_bscan_falling_updatedr_clk_during_posedge_clk                       170745   818            0        0          
chk_stap_bscan_falling_updatedr_during_posedge_clk                           170745   818            0        0          
chk_stap_bscan_raising_capturedr_during_posedge_clk                          170745   818            0        0          
chk_stap_bscan_raising_shiftdr_during_posedge_clk                            170745   24552          0        0          
chk_stap_bscan_raising_updatedr_clk_during_negedge_clk                       170745   818            0        0          
chk_stap_bscan_raising_updatedr_during_posedge_clk                           170745   818            0        0          


-------------------------------------------------------------------------------

Cover Directives for Properties: Details

Name                                                   Attempts Matches Incomplete 
cov_stap_bscan_falling_capturedr_during_negedge_clk    170745   409     0          
cov_stap_bscan_falling_shiftdr_during_negedge_clk      170745   409     0          
cov_stap_bscan_falling_updatedr_clk_during_negedge_clk 170745   409     0          
cov_stap_bscan_falling_updatedr_during_negedge_clk     170745   409     0          
cov_stap_bscan_raising_capturedr_during_negedge_clk    170745   409     0          
cov_stap_bscan_raising_shiftdr_during_negedge_clk      170745   409     0          
cov_stap_bscan_raising_updatedr_clk_during_posedge_clk 170745   0       0          
cov_stap_bscan_raising_updatedr_during_negedge_clk     170745   409     0          


===============================================================================
Module : STAP_RTL_LIB.stap_glue
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.66 --     100.00  98.98 --     100.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_glue.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 --     100.00 100.00 --     100.00 --     top.stap_top_inst.i_stap_glue(x) 



-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_glue 

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       234
 EXPRESSION ((tapc_remove == HIGH) ? ((|sntapnw_atap_tdo_en)) : stap_tdomux_tdoen)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       167
 EXPRESSION ((tapc_remove == HIGH) ? ftap_tdi : stap_mux_tdo)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       200
 EXPRESSION 
 Number  Term
      1  (tapc_remove == HIGH) ? sntapnw_atap_tdo : (((|tapc_select) == HIGH) ? sntapnw_atap_tdo : (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso)))

-1- Status
 0  Covered
 1  Covered

 LINE       200
 SUB-EXPRESSION (((|tapc_select) == HIGH) ? sntapnw_atap_tdo : (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso))
                 ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       200
 SUB-EXPRESSION (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso)
                 -------------1------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_glue 
                Total Covered Percent 
Totals          34    33      97.06   
Total Bits      98    97      98.98   
Total Bits 0->1 49    49      100.00  
Total Bits 1->0 49    48      97.96   

                            
Ports          33 32 96.97  
Port Bits      96 95 98.96  
Port Bits 0->1 48 48 100.00 
Port Bits 1->0 48 47 97.92  

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                          Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                  Yes    Yes         Yes         INPUT     
ftap_tms                  Yes    Yes         Yes         INPUT     
ftap_trst_b               Yes    Yes         Yes         INPUT     
fdfx_powergood            Yes    Yes         Yes         INPUT     
ftap_tdi                  Yes    Yes         Yes         INPUT     
stap_tdomux_tdoen         Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo_en[3:0]  Yes    Yes         Yes         INPUT     
pre_tdo                   Yes    Yes         Yes         OUTPUT    
powergood_rst_trst_b      Yes    Yes         Yes         OUTPUT    
atap_tdoen                Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tck          Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tms          Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_trst_b       Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tdi          Yes    Yes         Yes         OUTPUT    
sntapnw_atap_tdo          Yes    Yes         Yes         INPUT     
ftapsslv_tck              Yes    Yes         Yes         INPUT     
ftapsslv_tms              Yes    Yes         Yes         INPUT     
ftapsslv_trst_b           Yes    Yes         Yes         INPUT     
ftapsslv_tdi              Yes    Yes         Yes         INPUT     
atapsslv_tdo              Yes    Yes         Yes         OUTPUT    
atapsslv_tdoen            Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tck2         Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tms2         Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_trst2_b      Yes    Yes         Yes         OUTPUT    
sntapnw_ftap_tdi2         Yes    Yes         Yes         OUTPUT    
sntapnw_atap_tdo2         Yes    Yes         Yes         INPUT     
sntapnw_atap_tdo2_en[3:0] Yes    Yes         Yes         INPUT     
sn_fwtap_wrck             Yes    Yes         Yes         OUTPUT    
stap_mux_tdo              Yes    Yes         Yes         INPUT     
tapc_select[7:0]          Yes    Yes         Yes         INPUT     
tapc_wtap_sel[2:0]        Yes    Yes         Yes         INPUT     
tapc_remove               No     No          Yes         INPUT     
stap_wtapnw_tdo           Yes    Yes         Yes         INPUT     

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
stap_muxtdo_wtapwso Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_glue 
         Line No. Total Covered Percent 
Branches          8     8       100.00  
TERNARY  234      2     2       100.00  
TERNARY  167      2     2       100.00  
TERNARY  200      4     4       100.00  


234           assign atap_tdoen = (tapc_remove == HIGH) ? (|sntapnw_atap_tdo_en) : stap_tdomux_tdoen;
                                                        -1-  
                                                        ==>  
                                                        ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


167                 assign sntapnw_ftap_tdi    = (tapc_remove == HIGH) ? ftap_tdi : stap_mux_tdo;
                                                                       -1-  
                                                                       ==>  
                                                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


200                    assign pre_tdo = (tapc_remove == HIGH) ? sntapnw_atap_tdo :
                                                              -1-  
                                                              ==>  
201                                     ((|tapc_select) == HIGH) ? sntapnw_atap_tdo :
                                                                 -2-  
                                                                 ==>  
202                                     (|tapc_wtap_sel == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso;
                                                                 -3-  
                                                                 ==>  
                                                                 ==>  

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                   
 99.66 --     100.00  98.98 --     100.00 --     STAP_RTL_LIB.stap_glue 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                  
100.00 --     --     100.00 --     --     --     generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1 
100.00 --     --     100.00 --     --     --     generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck    
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_tck2                         
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq                                   



-------------------------------------------------------------------------------
Cond Coverage for Instance : top.stap_top_inst.i_stap_glue(x)

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       234
 EXPRESSION ((tapc_remove == HIGH) ? ((|sntapnw_atap_tdo_en)) : stap_tdomux_tdoen)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       167
 EXPRESSION ((tapc_remove == HIGH) ? ftap_tdi : stap_mux_tdo)
             ----------1----------

-1- Status
 0  Covered
 1  Covered

 LINE       200
 EXPRESSION 
 Number  Term
      1  (tapc_remove == HIGH) ? sntapnw_atap_tdo : (((|tapc_select) == HIGH) ? sntapnw_atap_tdo : (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso)))

-1- Status
 0  Covered
 1  Covered

 LINE       200
 SUB-EXPRESSION (((|tapc_select) == HIGH) ? sntapnw_atap_tdo : (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso))
                 ------------1-----------

-1- Status
 0  Covered
 1  Covered

 LINE       200
 SUB-EXPRESSION (((|tapc_wtap_sel) == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso)
                 -------------1------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue(x)
                Total Covered Percent 
Totals          33    33      100.00  
Total Bits      96    96      100.00  
Total Bits 0->1 48    48      100.00  
Total Bits 1->0 48    48      100.00  

                            
Ports          32 32 100.00 
Port Bits      94 94 100.00 
Port Bits 0->1 47 47 100.00 
Port Bits 1->0 47 47 100.00 

                            
Signals          1 1 100.00 
Signal Bits      2 2 100.00 
Signal Bits 0->1 1 1 100.00 
Signal Bits 1->0 1 1 100.00 

Port Details
                          Toggle   Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                  Yes      Yes         Yes         INPUT     
ftap_tms                  Yes      Yes         Yes         INPUT     
ftap_trst_b               Yes      Yes         Yes         INPUT     
fdfx_powergood            Yes      Yes         Yes         INPUT     
ftap_tdi                  Yes      Yes         Yes         INPUT     
stap_tdomux_tdoen         Yes      Yes         Yes         INPUT     
sntapnw_atap_tdo_en[3:0]  Yes      Yes         Yes         INPUT     
pre_tdo                   Yes      Yes         Yes         OUTPUT    
powergood_rst_trst_b      Yes      Yes         Yes         OUTPUT    
atap_tdoen                Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tck          Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tms          Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_trst_b       Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tdi          Yes      Yes         Yes         OUTPUT    
sntapnw_atap_tdo          Yes      Yes         Yes         INPUT     
ftapsslv_tck              Yes      Yes         Yes         INPUT     
ftapsslv_tms              Yes      Yes         Yes         INPUT     
ftapsslv_trst_b           Yes      Yes         Yes         INPUT     
ftapsslv_tdi              Yes      Yes         Yes         INPUT     
atapsslv_tdo              Yes      Yes         Yes         OUTPUT    
atapsslv_tdoen            Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tck2         Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tms2         Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_trst2_b      Yes      Yes         Yes         OUTPUT    
sntapnw_ftap_tdi2         Yes      Yes         Yes         OUTPUT    
sntapnw_atap_tdo2         Yes      Yes         Yes         INPUT     
sntapnw_atap_tdo2_en[3:0] Yes      Yes         Yes         INPUT     
sn_fwtap_wrck             Yes      Yes         Yes         OUTPUT    
stap_mux_tdo              Yes      Yes         Yes         INPUT     
tapc_select[7:0]          Yes      Yes         Yes         INPUT     
tapc_wtap_sel[2:0]        Yes      Yes         Yes         INPUT     
tapc_remove               Excluded Excluded    Excluded    INPUT     
stap_wtapnw_tdo           Yes      Yes         Yes         INPUT     

Signal Details
                    Toggle Toggle 1->0 Toggle 0->1 
stap_muxtdo_wtapwso Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Instance : top.stap_top_inst.i_stap_glue(x)
         Line No. Total Covered Percent 
Branches          8     8       100.00  
TERNARY  234      2     2       100.00  
TERNARY  167      2     2       100.00  
TERNARY  200      4     4       100.00  


234           assign atap_tdoen = (tapc_remove == HIGH) ? (|sntapnw_atap_tdo_en) : stap_tdomux_tdoen;
                                                        -1-  
                                                        ==>  
                                                        ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


167                 assign sntapnw_ftap_tdi    = (tapc_remove == HIGH) ? ftap_tdi : stap_mux_tdo;
                                                                       -1-  
                                                                       ==>  
                                                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


200                    assign pre_tdo = (tapc_remove == HIGH) ? sntapnw_atap_tdo :
                                                              -1-  
                                                              ==>  
201                                     ((|tapc_select) == HIGH) ? sntapnw_atap_tdo :
                                                                 -2-  
                                                                 ==>  
202                                     (|tapc_wtap_sel == HIGH) ? stap_wtapnw_tdo : stap_muxtdo_wtapwso;
                                                                 -3-  
                                                                 ==>  
                                                                 ==>  

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


===============================================================================
Module : STAP_PKG_LIB.STapPkg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/STapPkg.sv

Module self-instances :

SCORE LINE COND TOGGLE FSM BRANCH ASSERT NAME 



-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_PKG_LIB.STapPkg 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       2     2         100.00  2                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            2     2         100.00  2                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                     Attempts Real Successes Failures Incomplete 
\STapInputMonitor::connect .unnamed$$_0  16       16             0        0          
\STapOutputMonitor::connect .unnamed$$_0 16       16             0        0          


===============================================================================
Module : STAP_RTL_LIB.stap_remote_data_reg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_remote_data_reg.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[23].i_stap_remote_data_reg 
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[24].i_stap_remote_data_reg 
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[25].i_stap_remote_data_reg 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_remote_data_reg 
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      10    10      100.00  
Total Bits 0->1 5     5       100.00  
Total Bits 1->0 5     5       100.00  

                            
Ports          5  5  100.00 
Port Bits      10 10 100.00 
Port Bits 0->1 5  5  100.00 
Port Bits 1->0 5  5  100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
rtdr_tap_tdo            Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
rtdr_tap_tdo_gated      Yes    Yes         Yes         OUTPUT    
tap_rtdr_irdec          Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[23].i_stap_remote_data_reg
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                              
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_remote_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[23].i_stap_remote_data_reg
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      10    10      100.00  
Total Bits 0->1 5     5       100.00  
Total Bits 1->0 5     5       100.00  

                            
Ports          5  5  100.00 
Port Bits      10 10 100.00 
Port Bits 0->1 5  5  100.00 
Port Bits 1->0 5  5  100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
rtdr_tap_tdo            Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
rtdr_tap_tdo_gated      Yes    Yes         Yes         OUTPUT    
tap_rtdr_irdec          Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[24].i_stap_remote_data_reg
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                              
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_remote_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[24].i_stap_remote_data_reg
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      10    10      100.00  
Total Bits 0->1 5     5       100.00  
Total Bits 1->0 5     5       100.00  

                            
Ports          5  5  100.00 
Port Bits      10 10 100.00 
Port Bits 0->1 5  5  100.00 
Port Bits 1->0 5  5  100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
rtdr_tap_tdo            Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
rtdr_tap_tdo_gated      Yes    Yes         Yes         OUTPUT    
tap_rtdr_irdec          Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[25].i_stap_remote_data_reg
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                              
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_remote_data_reg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
100.00 100.00 100.00 100.00 --     100.00 100.00 i_stap_drreg(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_drreg.generate_rtdr.generate_rtdr_1[25].i_stap_remote_data_reg
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      10    10      100.00  
Total Bits 0->1 5     5       100.00  
Total Bits 1->0 5     5       100.00  

                            
Ports          5  5  100.00 
Port Bits      10 10 100.00 
Port Bits 0->1 5  5  100.00 
Port Bits 1->0 5  5  100.00 

Port Details
                        Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_irdecoder_drselect Yes    Yes         Yes         INPUT     
rtdr_tap_tdo            Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr       Yes    Yes         Yes         INPUT     
rtdr_tap_tdo_gated      Yes    Yes         Yes         OUTPUT    
tap_rtdr_irdec          Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_RTL_LIB.ctech_lib_dq
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/p/hdk/cad/ctech/c2v16ww47e_hdk141/source/v/ctech_lib_dq.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                           
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq.i_ctech_lib_dq                               
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen.i_ctech_lib_dq  
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode.i_ctech_lib_dq     
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz.i_ctech_lib_dq    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen.i_ctech_lib_dq  
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest.i_ctech_lib_dq   
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select.i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.ctech_lib_dq 
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                        
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_chainen 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                     
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_mode 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_highz 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                        
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_extogen 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_intest 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select.i_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                      
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                         
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_d6select 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select.i_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : SIP_SHARED_LIB.JtagBfmIntf
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 

Source File(s) : 

/p/cdft/dteg/bfms/jtag_bfm/dteg-jtag_bfm/verif/tb/JtagBfm/JtagBfmPinIf.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     --     --     --     100.00 top.Primary_if 



-------------------------------------------------------------------------------
Line Coverage for Module : \SIP_SHARED_LIB.JtagBfmIntf 

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL           122        0        0
INITIAL           132        0        0
ALWAYS            136        0        0
ALWAYS            167        0        0
ALWAYS            172        0        0

121                         initial begin
122        excluded            $sformat (intf_name, "%m");
123                           //$display ("This instance of JtagBfmIntf is hierarchically at : %s", intf_name);
124                         end
125                     
126                         //--------------------------------------------------------------------
127                         // Clock Generation
128                         //--------------------------------------------------------------------
129                         logic clock;
130                     
131                         initial begin 
132        excluded             clock = 1'b0;
133                         end
134                        
135                         always begin
136        excluded             #(CLOCK_PERIOD/2) clock = ~(clock);
137                         end
138                     
139                     
140                         //--------------------------------------------------------------------
141                         // Mux for Power Good 
142                         //--------------------------------------------------------------------
143                         assign powergood_rst_b = (PWRGOOD_SRC == 1) ? soc_powergood_rst_b : bfm_powergood_rst_b;
144                         assign tap_rtdr_powergood = (PWRGOOD_SRC == 1) ? soc_powergood_rst_b : bfm_powergood_rst_b;
145                         assign jtagbfm_clk = (CLK_SRC == 1)     ? soc_clock : clock;
146                     
147                         //--------------------------------------------------------------------
148                         // Assertion on TMS
149                         // Change detector on posedge
150                         //--------------------------------------------------------------------
151                     
152                         localparam LOW  = 1'b0;
153                         localparam HIGH = 1'b1;
154                     
155                         wire   tms_pulse;
156                         wire   tms_delayed_by_1ps;
157                         assign #1 tms_delayed_by_1ps     = tms ;
158                         assign tms_pulse                 = tms ^ tms_delayed_by_1ps;
159                     
160                         fsm_state_test  driver_state;
161                         fsm_state_test  mon_driver_state;
162                         fsm_state_test display_state_t;
163                         fsm_state_test mon_display_state_t;
164                     
165                         always_comb
166                         begin
167        excluded            driver_state = display_state_t;
168                         end
169                         
170                         always_comb
171                         begin
172        excluded            mon_driver_state = mon_display_state_t;

-------------------------------------------------------------------------------
Toggle Coverage for Module : \SIP_SHARED_LIB.JtagBfmIntf 
Port Details
                    Toggle   Toggle 1->0 Toggle 0->1 Direction 
soc_powergood_rst_b Excluded Excluded    Excluded    INPUT     
soc_clock           Excluded Excluded    Excluded    INPUT     

Signal Details
                          Toggle   Toggle 1->0 Toggle 0->1 
tck                       Excluded Excluded    Excluded    
tms                       Excluded Excluded    Excluded    
trst_b                    Excluded Excluded    Excluded    
tdi                       Excluded Excluded    Excluded    
tdo                       Excluded Excluded    Excluded    
shift_ir_reg[4095:0]      Excluded Excluded    Excluded    
tap_ir_reg[4095:0]        Excluded Excluded    Excluded    
bfm_powergood_rst_b       Excluded Excluded    Excluded    
tap_tdo_strobe            Excluded Excluded    Excluded    
powergood_rst_b           Excluded Excluded    Excluded    
bfm_shift_states          Excluded Excluded    Excluded    
jtagbfm_clk               Excluded Excluded    Excluded    
tap_rtdr_tck              Excluded Excluded    Excluded    
tap_rtdr_tdi[49:0]        Excluded Excluded    Excluded    
tap_rtdr_tdo[49:0]        Excluded Excluded    Excluded    
tap_rtdr_capture[49:0]    Excluded Excluded    Excluded    
tap_rtdr_shift[49:0]      Excluded Excluded    Excluded    
tap_rtdr_update[49:0]     Excluded Excluded    Excluded    
tap_rtdr_irdec[49:0]      Excluded Excluded    Excluded    
tap_rtdr_powergood        Excluded Excluded    Excluded    
tap_rtdr_selectir         Excluded Excluded    Excluded    
tap_rtdr_rti              Excluded Excluded    Excluded    
tap_rtdr_prog_rst_b[49:0] Excluded Excluded    Excluded    
clock                     Excluded Excluded    Excluded    
tms_pulse                 Excluded Excluded    Excluded    
tms_delayed_by_1ps        Excluded Excluded    Excluded    
driver_state[3:0]         Excluded Excluded    Excluded    
mon_driver_state[3:0]     Excluded Excluded    Excluded    
display_state_t[3:0]      Excluded Excluded    Excluded    
mon_display_state_t[3:0]  Excluded Excluded    Excluded    
tck_delayed_by_1ps        Excluded Excluded    Excluded    
tdi_pulse                 Excluded Excluded    Excluded    
tdi_delayed_by_1ps        Excluded Excluded    Excluded    
tdo_delayed_by_1ps        Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Assert Coverage for Module : \SIP_SHARED_LIB.JtagBfmIntf 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       5     5         100.00  5                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            5     5         100.00  5                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                              Attempts Real Successes Failures Incomplete 
chk_bfmintf_tap_assert_check_tdi_change_wrt_clk_0 24737    24737          0        0          
chk_bfmintf_tap_assert_check_tms_change_wrt_clk_0 12689    12689          0        0          
chk_bfmintf_tap_assert_tdi_during_posedge_clk_0   88842    87154          0        0          
chk_bfmintf_tap_assert_tdo_during_posedge_clk_0   19402    16955          0        0          
chk_bfmintf_tap_assert_tms_during_posedge_clk_0   88842    87154          0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.Primary_if
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                       
100.00 --     --     --     --     --     100.00 SIP_SHARED_LIB.JtagBfmIntf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME   
--     --     --     --     --     --     --     top(X) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.ctech_lib_clk_mux_2to1
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     

Source File(s) : 

/p/hdk/cad/ctech/c2v16ww47e_hdk141/source/v/ctech_lib_clk_mux_2to1.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                                             
100.00 --     100.00 100.00 --     100.00 --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_mux_2to1_d6init.i_ctech_lib_clk_mux_2to1 



-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_mux_2to1 

               Total   Covered  Percent
Conditions          2        2   100.00
Logical             2        2   100.00
Non-Logical         0        0
Event               0        0

 LINE       21
 EXPRESSION ((s == 1'b1) ? clk1 : clk2)
             -----1-----

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_mux_2to1 
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk1   Yes    Yes         Yes         INPUT     
clk2   Yes    Yes         Yes         INPUT     
s      Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_mux_2to1 
         Line No. Total Covered Percent 
Branches          2     2       100.00  
TERNARY  21       2     2       100.00  


21            assign clkout = (s==1'b1)?clk1:clk2;
                                       -1-  
                                       ==>  
                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_mux_2to1_d6init.i_ctech_lib_clk_mux_2to1
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     100.00 100.00 --     100.00 --     STAP_RTL_LIB.ctech_lib_clk_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                 
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_mux_2to1_d6init 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_tapnw
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_tapnw.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                               
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_tapnw.i_stap_tapnw 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_tapnw 
                Total Covered Percent 
Totals          5     5       100.00  
Total Bits      50    50      100.00  
Total Bits 0->1 25    25      100.00  
Total Bits 1->0 25    25      100.00  

                            
Ports          4  4  100.00 
Port Bits      34 34 100.00 
Port Bits 0->1 17 17 100.00 
Port Bits 1->0 17 17 100.00 

                              
Signals          1  1  100.00 
Signal Bits      16 16 100.00 
Signal Bits 0->1 8  8  100.00 
Signal Bits 1->0 8  8  100.00 

Port Details
                            Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_selectwir_neg          Yes    Yes         Yes         INPUT     
tapc_select[7:0]            Yes    Yes         Yes         INPUT     
sftapnw_ftap_enabletap[3:0] Yes    Yes         Yes         OUTPUT    
sftapnw_ftap_enabletdo[3:0] Yes    Yes         Yes         OUTPUT    

Signal Details
                       Toggle Toggle 1->0 Toggle 0->1 
agent_tapc_select[7:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_tapnw.i_stap_tapnw
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                    
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_tapnw 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_wtapnw
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_wtapnw.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                 
100.00 --     100.00 100.00 --     100.00 --     top.stap_top_inst.generate_stap_wtapnw.i_stap_wtapnw 



-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_wtapnw 

               Total   Covered  Percent
Conditions         10       10   100.00
Logical            10       10   100.00
Non-Logical         0        0
Event               0        0

 LINE       121
 EXPRESSION 
 Number  Term
      1  ((|tapc_select) == HIGH) ? ({WTAPNW_STAP_NUMBER_OF_WTAPS {HIGH}}) : (((|tapc_wtap_sel) == LOW) ? ({WTAPNW_STAP_NUMBER_OF_WTAPS {HIGH}}) : wtap_wsi_internal))

-1- Status
 0  Covered
 1  Covered

 LINE       121
 SUB-EXPRESSION (((|tapc_wtap_sel) == LOW) ? ({WTAPNW_STAP_NUMBER_OF_WTAPS {HIGH}}) : wtap_wsi_internal)
                 ------------1------------

-1- Status
 0  Covered
 1  Covered

 LINE       117
 EXPRESSION ((wtapnw_wsi_internal[0] == HIGH) ? stap_mux_tdo : HIGH)
             ----------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       117
 EXPRESSION ((wtapnw_wsi_internal[1] == HIGH) ? stap_mux_tdo : HIGH)
             ----------------1---------------

-1- Status
 0  Covered
 1  Covered

 LINE       117
 EXPRESSION ((wtapnw_wsi_internal[2] == HIGH) ? stap_mux_tdo : HIGH)
             ----------------1---------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_wtapnw 
                Total Covered Percent 
Totals          11    11      100.00  
Total Bits      60    60      100.00  
Total Bits 0->1 30    30      100.00  
Total Bits 1->0 30    30      100.00  

                            
Ports          8  8  100.00 
Port Bits      42 42 100.00 
Port Bits 0->1 21 21 100.00 
Port Bits 1->0 21 21 100.00 

                              
Signals          3  3  100.00 
Signal Bits      18 18 100.00 
Signal Bits 0->1 9  9  100.00 
Signal Bits 1->0 9  9  100.00 

Port Details
                   Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_mux_tdo       Yes    Yes         Yes         INPUT     
stap_selectwir     Yes    Yes         Yes         INPUT     
sn_awtap_wso[2:0]  Yes    Yes         Yes         INPUT     
tapc_wtap_sel[2:0] Yes    Yes         Yes         INPUT     
tapc_select[7:0]   Yes    Yes         Yes         INPUT     
sn_fwtap_selectwir Yes    Yes         Yes         OUTPUT    
sn_fwtap_wsi[2:0]  Yes    Yes         Yes         OUTPUT    
stap_wtapnw_tdo    Yes    Yes         Yes         OUTPUT    

Signal Details
                         Toggle Toggle 1->0 Toggle 0->1 
wtapnw_tdo_internal[2:0] Yes    Yes         Yes         
wtapnw_wsi_internal[2:0] Yes    Yes         Yes         
wtap_wsi_internal[2:0]   Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_wtapnw 
         Line No. Total Covered Percent 
Branches          9     9       100.00  
TERNARY  121      3     3       100.00  
TERNARY  117      2     2       100.00  
TERNARY  117      2     2       100.00  
TERNARY  117      2     2       100.00  


121           assign sn_fwtap_wsi = ((|tapc_select) == HIGH) ? {WTAPNW_STAP_NUMBER_OF_WTAPS{HIGH}} :
                                                             -1-  
                                                             ==>  
122                                 (|tapc_wtap_sel == LOW) ? {WTAPNW_STAP_NUMBER_OF_WTAPS{HIGH}} : wtap_wsi_internal;
                                                            -2-  
                                                            ==>  
                                                            ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


117                 assign wtap_wsi_internal[m] = (wtapnw_wsi_internal[m] == HIGH) ? stap_mux_tdo : HIGH;
                                                                                   -1-  
                                                                                   ==>  
                                                                                   ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


117                 assign wtap_wsi_internal[m] = (wtapnw_wsi_internal[m] == HIGH) ? stap_mux_tdo : HIGH;
                                                                                   
           Warning: the following expressions can not be annotated
           -1- ((wtapnw_wsi_internal[1] == HIGH)) ? ...;  
           

Branches:

-1- Status  
1   Covered 
0   Covered 


117                 assign wtap_wsi_internal[m] = (wtapnw_wsi_internal[m] == HIGH) ? stap_mux_tdo : HIGH;
                                                                                   
           Warning: the following expressions can not be annotated
           -1- ((wtapnw_wsi_internal[2] == HIGH)) ? ...;  
           

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_wtapnw.i_stap_wtapnw
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                     
100.00 --     100.00 100.00 --     100.00 --     STAP_RTL_LIB.stap_wtapnw 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_ctech_lib_mux_2to1
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/ctech_lib/stap_ctech_map.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                  
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge(x)              
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_ctech_lib_mux_2to1 
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
   Toggle Toggle 1->0 Toggle 0->1 Direction 
d1 Yes    Yes         Yes         INPUT     
d2 Yes    Yes         Yes         INPUT     
s  Yes    Yes         Yes         INPUT     
o  Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                 
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
100.00 100.00 --     100.00 --     100.00 --     i_stap_tdomux(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                    
100.00 --     --     100.00 --     --     --     i_ctech_lib_mux_2to1(x) 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge(x)
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
   Toggle   Toggle 1->0 Toggle 0->1 Direction 
d1 Yes      Yes         Yes         INPUT     
d2 Yes      Yes         Yes         INPUT     
s  Excluded Excluded    Excluded    INPUT     
o  Yes      Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                 
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                 
100.00 --     --     100.00 --     --     --     i_ctech_lib_mux_2to1 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
   Toggle Toggle 1->0 Toggle 0->1 Direction 
d1 Yes    Yes         Yes         INPUT     
d2 Yes    Yes         Yes         INPUT     
s  Yes    Yes         Yes         INPUT     
o  Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_RTL_LIB.ctech_lib_mux_2to1
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/p/hdk/cad/ctech/c2v16ww47e_hdk141/source/v/ctech_lib_mux_2to1.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                                       
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge.i_ctech_lib_mux_2to1(x)              
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest.i_ctech_lib_mux_2to1 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.ctech_lib_mux_2to1 
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
   Toggle Toggle 1->0 Toggle 0->1 Direction 
d1 Yes    Yes         Yes         INPUT     
d2 Yes    Yes         Yes         INPUT     
s  Yes    Yes         Yes         INPUT     
o  Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge.i_ctech_lib_mux_2to1(x)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                            
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                     
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_mux_2to1_tdo_posedge(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_tdomux.i_stap_ctech_lib_mux_2to1_tdo_posedge.i_ctech_lib_mux_2to1(x)
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
   Toggle   Toggle 1->0 Toggle 0->1 Direction 
d1 Yes      Yes         Yes         INPUT     
d2 Yes      Yes         Yes         INPUT     
s  Excluded Excluded    Excluded    INPUT     
o  Yes      Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest.i_ctech_lib_mux_2to1
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                            
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                               
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_mux_2to1_d6actest 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_mux_2to1_d6actest.i_ctech_lib_mux_2to1
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
   Toggle Toggle 1->0 Toggle 0->1 Direction 
d1 Yes    Yes         Yes         INPUT     
d2 Yes    Yes         Yes         INPUT     
s  Yes    Yes         Yes         INPUT     
o  Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : SIP_SHARED_LIB.JtagBfmTestIsland
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 

Source File(s) : 

/p/cdft/dteg/bfms/jtag_bfm/dteg-jtag_bfm/verif/tb/JtagBfm/JtagBfmTestIsland.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                      
100.00 --     --     --     --     --     100.00 top.i_TapTestIsland.pri_JtagBfmTestIsland 



-------------------------------------------------------------------------------
Line Coverage for Module : \SIP_SHARED_LIB.JtagBfmTestIsland 

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL            87        0        0

86                         initial begin
87         excluded           vif_container = new ();
88         excluded           vif_container.set_v_if(Primary_if);
89                      
90                            // HSD_5152244 This check enforces to remove "*" to avoid simulation performance issues in FC.
91                      
92                            assert (TAPVIF != "*") else $error ("TAPVIF is not set, It should be overriden when instanantiating JtagBfmTI");
93         excluded           $display ("This instance of JtagBfmTI is hierarchically at : %m ");
94         excluded           $display ("The associated instance of the JTAGBFM is       : %s \n",TAPVIF);
95                      
96         excluded           set_config_object(TAPVIF, "V_JTAGBFM_PIN_IF", vif_container,0);

-------------------------------------------------------------------------------
Assert Coverage for Module : \SIP_SHARED_LIB.JtagBfmTestIsland 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       1     1         100.00  1                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            1     1         100.00  1                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name        Attempts Real Successes Failures Incomplete 
unnamed$$_0 16       16             0        0          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.i_TapTestIsland.pri_JtagBfmTestIsland
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 --     --     --     --     --     100.00 SIP_SHARED_LIB.JtagBfmTestIsland 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME               
--     --     --     --     --     --     --     i_TapTestIsland(X) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_irreg
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_irreg.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 100.00 --     100.00 --     100.00 100.00 top.stap_top_inst.i_stap_irreg 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_irreg 

             Line No.   Total   Covered  Percent
TOTAL                       17       17   100.00
ALWAYS            117        8        8   100.00
ALWAYS            152        6        6   100.00
ALWAYS            168        3        3   100.00

116                        begin
117        1/1                if (!powergood_rst_trst_b)
118                           begin
119        1/1                   shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
120                           end
121        1/1                else if (stap_fsm_tlrs)
122                           begin
123        1/1                   shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
124                           end
125        1/1                else if (stap_fsm_capture_ir)
126                           begin
127        1/1                   shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
128                           end
129        1/1                else if (stap_fsm_shift_ir)
130                           begin
131        1/1                   shift_reg <= {ftap_tdi, shift_reg[(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - 1):1]};
132                           end
                        MISSING_ELSE
133                        end
134                     
135                        // *********************************************************************
136                        // shift_reg data going to bscan
137                        // *********************************************************************
138                        assign stap_irreg_shift_reg = shift_reg;
139                     
140                        // *********************************************************************
141                        // shift_reg data going to TDOmux FUB
142                        // *********************************************************************
143                        assign stap_irreg_serial_out = shift_reg[0];
144                     
145                        // *********************************************************************
146                        // parallel register implementation
147                        // Reset part: resetting the parallel register to all1 value - which
148                        // means bypass instruction will be selected
149                        // *********************************************************************
150                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
151                        begin
152        1/1                if (!powergood_rst_trst_b)
153                           begin
154        1/1                   stap_irreg_ireg <= IRREG_STAP_ADDRESS_OF_SLVIDCODE;
155                           end
156        1/1                else if (stap_fsm_tlrs)
157                           begin
158        1/1                   stap_irreg_ireg <= IRREG_STAP_ADDRESS_OF_SLVIDCODE;
159                           end
160        1/1                else if (stap_fsm_update_ir)
161                           begin
162        1/1                   stap_irreg_ireg <= shift_reg;
163                           end
                        MISSING_ELSE
164                        end
165                     
166                        always_comb
167                        begin
168        1/1               if (stap_fsm_update_ir)
169        1/1                stap_irreg_ireg_nxt = shift_reg ;
170                          else
171        1/1                stap_irreg_ireg_nxt = stap_irreg_ireg;

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_irreg 
                Total Covered Percent 
Totals          12    12      100.00  
Total Bits      144   144     100.00  
Total Bits 0->1 72    72      100.00  
Total Bits 1->0 72    72      100.00  

                              
Ports          11  11  100.00 
Port Bits      112 112 100.00 
Port Bits 0->1 56  56  100.00 
Port Bits 1->0 56  56  100.00 

                              
Signals          1  1  100.00 
Signal Bits      32 32 100.00 
Signal Bits 0->1 16 16 100.00 
Signal Bits 1->0 16 16 100.00 

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
stap_fsm_tlrs              Yes    Yes         Yes         INPUT     
stap_fsm_capture_ir        Yes    Yes         Yes         INPUT     
stap_fsm_shift_ir          Yes    Yes         Yes         INPUT     
stap_fsm_update_ir         Yes    Yes         Yes         INPUT     
ftap_tdi                   Yes    Yes         Yes         INPUT     
ftap_tck                   Yes    Yes         Yes         INPUT     
powergood_rst_trst_b       Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]      Yes    Yes         Yes         OUTPUT    
stap_irreg_ireg_nxt[15:0]  Yes    Yes         Yes         OUTPUT    
stap_irreg_serial_out      Yes    Yes         Yes         OUTPUT    
stap_irreg_shift_reg[15:0] Yes    Yes         Yes         OUTPUT    

Signal Details
                Toggle Toggle 1->0 Toggle 0->1 
shift_reg[15:0] Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_irreg 
         Line No. Total Covered Percent 
Branches          11    11      100.00  
IF       117      5     5       100.00  
IF       152      4     4       100.00  
IF       168      2     2       100.00  


117              if (!powergood_rst_trst_b)
                 -1-  
118              begin
119                 shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
                    ==>
120              end
121              else if (stap_fsm_tlrs)
                      -2-  
122              begin
123                 shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
                    ==>
124              end
125              else if (stap_fsm_capture_ir)
                      -3-  
126              begin
127                 shift_reg <= {{(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - TWO){LOW}}, TWO_LSB_BITS_OF_IR};
                    ==>
128              end
129              else if (stap_fsm_shift_ir)
                      -4-               
130              begin
131                 shift_reg <= {ftap_tdi, shift_reg[(IRREG_STAP_SIZE_OF_EACH_INSTRUCTION - 1):1]};
                    ==>
132              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- -4- Status  
1   -   -   -   Covered 
0   1   -   -   Covered 
0   0   1   -   Covered 
0   0   0   1   Covered 
0   0   0   0   Covered 


152              if (!powergood_rst_trst_b)
                 -1-  
153              begin
154                 stap_irreg_ireg <= IRREG_STAP_ADDRESS_OF_SLVIDCODE;
                    ==>
155              end
156              else if (stap_fsm_tlrs)
                      -2-  
157              begin
158                 stap_irreg_ireg <= IRREG_STAP_ADDRESS_OF_SLVIDCODE;
                    ==>
159              end
160              else if (stap_fsm_update_ir)
                      -3-  
161              begin
162                 stap_irreg_ireg <= shift_reg;
                    ==>
163              end
                 MISSING_ELSE
                 ==>

Branches:

-1- -2- -3- Status  
1   -   -   Covered 
0   1   -   Covered 
0   0   1   Covered 
0   0   0   Covered 


168             if (stap_fsm_update_ir)
                -1-  
169              stap_irreg_ireg_nxt = shift_reg ;
                 ==>
170             else
171              stap_irreg_ireg_nxt = stap_irreg_ireg;
                 ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


-------------------------------------------------------------------------------
Assert Coverage for Module : \STAP_RTL_LIB.stap_irreg 
                 Total Attempted Percent Succeeded/Matched Percent 
Assertions       3     3         100.00  3                 100.00  
Cover properties 0     0                 0                         
Cover sequences  0     0                 0                         
Total            3     3         100.00  3                 100.00  



-------------------------------------------------------------------------------

Assertion Details

Name                                          Attempts Real Successes Failures Incomplete 
chk_stap_ir_equals_slvidcode_01               88842    9181           0        9          
chk_stap_irreg_change_when_update_ir_0        88842    1187           0        0          
chk_stap_shift_ir_reg_equals_01_during_tlrs_0 88842    10496          0        9          


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_irreg
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 --     100.00 --     100.00 100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                    
100.00 100.00 --     100.00 --     100.00 100.00 STAP_RTL_LIB.stap_irreg 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_bscan
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/stap/stap_bscan.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                               
100.00 100.00 100.00 100.00 --     100.00 --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_RTL_LIB.stap_bscan 

             Line No.   Total   Covered  Percent
TOTAL                       44       44   100.00
ALWAYS            425       11       11   100.00
ALWAYS            513        3        3   100.00
ALWAYS            535        5        5   100.00
ALWAYS            559        5        5   100.00
ALWAYS            575        5        5   100.00
ALWAYS            613        5        5   100.00
ALWAYS            635        5        5   100.00
ALWAYS            657        5        5   100.00

424                        begin
425        1/1                if (!powergood_rst_trst_b)
426                           begin
427        1/1                   fbscan_chainen_early_dly <= LOW;
428        1/1                   fbscan_mode_early_dly    <= LOW;
429        1/1                   fbscan_highz_early_dly   <= LOW;
430        1/1                   inst_extog_early_dly     <= LOW;
431        1/1                   fbscan_intest_early_dly  <= LOW;
432                           end
433                           else
434                           begin
435        1/1                   fbscan_chainen_early_dly <= fbscan_chainen_early;
436        1/1                   fbscan_mode_early_dly    <= fbscan_mode_early;
437        1/1                   fbscan_highz_early_dly   <= inst_highz_early;
438        1/1                   inst_extog_early_dly     <= inst_extesttoggle_early;
439        1/1                   fbscan_intest_early_dly  <= inst_intest_early;
440                           end
441                        end
442                     
443                        // *********************************************************************
444                        // stap_fbscan_chainen generation
445                        // *********************************************************************
446                        assign stap_fbscan_chainen_int = (inst_extest       |
447                                                          inst_intest       |
448                                                          inst_extesttoggle |
449                                                          inst_extest_train |
450                                                          inst_extest_pulse |
451                                                          inst_clamp        |
452                                                          inst_highz        |
453                                                          inst_sampre       |
454                                                          inst_preload);
455                     
456                        stap_ctech_lib_dq i_stap_ctech_lib_dq_chainen (.a(stap_fbscan_chainen_int), .b(fbscan_chainen_early_dly), .o(stap_fbscan_chainen));
457                     
458                        // *********************************************************************
459                        // stap_fbscan_mode generation
460                        // *********************************************************************
461                        assign stap_fbscan_mode_int = (inst_extest       |
462                                                       inst_extesttoggle |
463                                                       inst_extest_train |
464                                                       inst_extest_pulse |
465                                                       inst_clamp        |
466                                                       inst_highz);
467                     
468                        stap_ctech_lib_dq i_stap_ctech_lib_dq_mode (.a(stap_fbscan_mode_int), .b(fbscan_mode_early_dly), .o(stap_fbscan_mode));
469                     
470                        // *********************************************************************
471                        // stap_fbscan_highz generation
472                        // *********************************************************************
473                        stap_ctech_lib_dq i_stap_ctech_lib_dq_highz (.a(inst_highz), .b(fbscan_highz_early_dly), .o(stap_fbscan_highz));
474                     
475                        // *********************************************************************
476                        // stap_fbscan_extogen generation
477                        // *********************************************************************
478                        stap_ctech_lib_dq i_stap_ctech_lib_dq_extogen (.a(inst_extesttoggle), .b(inst_extog_early_dly), .o(stap_fbscan_extogen));
479                     
480                        // *********************************************************************
481                        // stap_fbscan_intest_mode generation
482                        // *********************************************************************
483                        stap_ctech_lib_dq i_stap_ctech_lib_dq_intest (.a(inst_intest), .b(fbscan_intest_early_dly), .o(stap_fbscan_intest_mode));
484                     
485                        // *********************************************************************
486                        // stap_fbscan_tck is pass through of primary clock ftap_tck
487                        // *********************************************************************
488                        stap_ctech_lib_clk_buf i_stap_ctech_lib_clk_buf_bscan (.clkout(stap_fbscan_tck), .clk(ftap_tck));
489                     
490                        // *********************************************************************
491                        // Capturdr, shiftdr and updatedr clocks the parallel stages of the boundary-scan
492                        // register flops. These signals to the bscan register is generated off a neg-edge
493                        // flop so that the parallel outputs of the boundary-scan register change on the
494                        // falling edge of the TCLK during the Update-DR state (as required by IEEE 1149.1).
495                        // *********************************************************************
496                        assign tap_bscanshclk_en = inst_sampre       |
497                                                   inst_preload      |
498                                                   inst_intest       |
499                                                   inst_extesttoggle |
500                                                   inst_extest_train |
501                                                   inst_extest_pulse |
502                                                   inst_extest;
503                     
504                        assign stap_fbscan_capturedr = stap_fsm_capture_dr & tap_bscanshclk_en;
505                        assign stap_fbscan_shiftdr   = stap_fsm_shift_dr   & tap_bscanshclk_en;
506                        assign stap_fbscan_updatedr  = stap_fsm_update_dr  & tap_bscanshclk_en;
507                     
508                        // *********************************************************************
509                        // Updatedr maybe needed at negative edge for some variations of BSCAN cells
510                        // *********************************************************************
511                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
512                        begin
513        1/1                if (!powergood_rst_trst_b)
514                           begin
515        1/1                   stap_fbscan_updatedr_clk <= LOW;
516                           end
517                           else
518                           begin
519        1/1                   stap_fbscan_updatedr_clk <= stap_fbscan_updatedr;
520                           end
521                        end
522                     
523                        // *********************************************************************
524                        // d6select generation
525                        // The tap_d6sel signal is asserted during the EXTEST_TRAIN or EXTEST_PULSE
526                        // instruction. It is used to place boundary-scan cells into the 1149.6 AC mode
527                        // which allows them to be toggled under control of the AC test signal (tap_actestsigb)
528                        // which takes on 1149.6 functionality during the Dot6 instructions.  This signal
529                        // is deglitched by running it through a flop, to prevent glitching any control
530                        // signals (to the custom circuits) that are switched based on being in one of
531                        // the 1149.6 instructions.
532                        // *********************************************************************
533                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
534                        begin
535        1/1                if (!powergood_rst_trst_b)
536                           begin
537        1/1                   pulse_train_early_delay <= LOW;
538                           end
539        1/1                else if (stap_fsm_tlrs)
540                           begin
541        1/1                   pulse_train_early_delay <= LOW;
542                           end
543                           else
544                           begin
545        1/1                   pulse_train_early_delay <= inst_extest_pulse_early | inst_extest_train_early;
546                           end
547                        end
548                     
549                        assign stap_fbscan_d6select_int = (inst_extest_train | inst_extest_pulse);
550                        stap_ctech_lib_dq i_stap_ctech_lib_dq_d6select (.a(stap_fbscan_d6select_int), .b(pulse_train_early_delay), .o(stap_fbscan_d6select));
551                     
552                        // *********************************************************************
553                        // d6actestsig_b generation
554                        // The d6actestsigb signal is the AC test waveform, driven to those
555                        // pins supporting 1149.6 based on extest_train.
556                        // *********************************************************************
557                        always_ff @(posedge ftap_tck or negedge powergood_rst_trst_b)
558                        begin
559        1/1                if (!powergood_rst_trst_b)
560                           begin
561        1/1                   tap_d6sel_mxsel <= LOW;
562                           end
563        1/1                else if (stap_fsm_tlrs)
564                           begin
565        1/1                   tap_d6sel_mxsel <= LOW;
566                           end
567                           else
568                           begin
569        1/1                   tap_d6sel_mxsel <= train_or_pulse;
570                           end
571                        end
572                     
573                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
574                        begin
575        1/1                if (!powergood_rst_trst_b)
576                           begin
577        1/1                   dot6_actestsig <= LOW;
578                           end
579        1/1                else if (stap_fsm_tlrs)
580                           begin
581        1/1                   dot6_actestsig <= LOW;
582                           end
583                           else
584                           begin
585        1/1                   dot6_actestsig <= ((~(dot6_actestsig & inst_extest_train)) & stap_fsm_rti);
586                           end
587                        end
588                     
589                        assign dot6_actestsigb      = ~dot6_actestsig;
590                     
591                      //  stap_ctech_lib_clk_mux_2to1 i_stap_ctech_lib_clk_mux_2to1_d6actest ( .clk1(dot6_actestsigb), .clk2(stap_fbscan_extogsig_b), .s(tap_d6sel_mxsel), .clkout(stap_fbscan_d6actestsig_b));
592                      stap_ctech_lib_mux_2to1 i_stap_ctech_lib_mux_2to1_d6actest ( .d1(dot6_actestsigb ), .d2(stap_fbscan_extogsig_b ), .s(tap_d6sel_mxsel ), .o(stap_fbscan_d6actestsig_b ) );
593                        // *********************************************************************
594                        // stap_fbscan_d6init
595                        // The d6init signal will initialize the 1149.6 test receiver. During AC
596                        // test instructions (EXTEST_TRAIN, EXTEST_PULSE), the signal will go high during
597                        // the Exit1-DR or Exit2-DR states.? These states occur between the Shift-DR and
598                        // Update-DR states, so that the test receiver initialization occurs according to
599                        // the 1149.6-2003 Rule 6.2.3.1 . Whenever a test receiver is operating in the
600                        // edge-detection mode on an AC input signal, the test receiver output shall be
601                        // cleared of prior history at a time between exiting the Shift-DR TAP Controller
602                        // state and before entering the Update-DR TAP Controller state.
603                        // *********************************************************************
604                        assign e1dr_or_e2dr         = stap_fsm_e1dr       | stap_fsm_e2dr;
605                        assign train_or_pulse       = inst_extest_pulse   | inst_extest_train;
606                        assign edr_and_trainorpulse = train_or_pulse      & e1dr_or_e2dr;
607                        assign cadr_and_extest      = stap_fsm_capture_dr & inst_extest;
608                     
609                        stap_ctech_lib_clk_gate_te  i_stap_ctech_lib_clk_gate_te_trainpulse (.en(edr_and_trainorpulse), .te(LOW), .clk(ftap_tck), .clkout(enable_clk));
610                     
611                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
612                        begin
613        1/1                if (!powergood_rst_trst_b)
614                           begin
615        1/1                   cadr_and_extest_dly <= LOW;
616                           end
617        1/1                else if (stap_fsm_tlrs)
618                           begin
619        1/1                   cadr_and_extest_dly <= LOW;
620                           end
621                           else
622                           begin
623        1/1                   cadr_and_extest_dly <= cadr_and_extest;
624                           end
625                        end
626                     
627                        stap_ctech_lib_clk_mux_2to1 i_stap_ctech_lib_clk_mux_2to1_d6init ( .clk1(cadr_and_extest_dly), .clk2(enable_clk), .s(inst_extest), .clkout(stap_fbscan_d6init));
628                     
629                        // *********************************************************************
630                        // Generation of divide by two clock for stap_fbscan_extogsig_b
631                        // This is based on Extest Toggle instruction
632                        // *********************************************************************
633                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
634                        begin
635        1/1                if (!powergood_rst_trst_b)
636                           begin
637        1/1                   by_two_clock <= LOW;
638                           end
639        1/1                else if (stap_fsm_tlrs)
640                           begin
641        1/1                   by_two_clock <= LOW;
642                           end
643                           else
644                           begin
645        1/1                   by_two_clock <= ~by_two_clock & inst_extesttoggle & stap_fsm_rti;
646                           end
647                        end
648                     
649                        assign stap_fbscan_extogsig_b = ~by_two_clock;
650                     
651                        // *********************************************************************
652                        // Final TDO generation which selects between final tdo (pre_tdo) from
653                        // stap and bscan output (stap_abscan_tdo)
654                        // *********************************************************************
655                        always_ff @(negedge ftap_tck or negedge powergood_rst_trst_b)
656                        begin
657        1/1                if (!powergood_rst_trst_b)
658                           begin
659        1/1                   fbscan_tdo_delay <= LOW;
660                           end
661        1/1                else if (stap_fsm_tlrs)
662                           begin
663        1/1                   fbscan_tdo_delay <= LOW;
664                           end
665                           else
666                           begin
667        1/1                   fbscan_tdo_delay <= stap_abscan_tdo;

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_RTL_LIB.stap_bscan 

               Total   Covered  Percent
Conditions         44       44   100.00
Logical            44       44   100.00
Non-Logical         0        0
Event               0        0

 LINE       248
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE) ? HIGH : LOW)
             ------------------------------1-----------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       250
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE) ? HIGH : LOW)
             ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       256
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN) ? HIGH : LOW)
             ------------------------------1-----------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       258
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN) ? HIGH : LOW)
             ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       264
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD) ? HIGH : LOW)
             -------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       266
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD) ? HIGH : LOW)
             ----------------------------1----------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       272
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST) ? HIGH : LOW)
             ---------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       274
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_EXTEST) ? HIGH : LOW)
             ------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       280
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_HIGHZ) ? HIGH : LOW)
             --------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       282
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_HIGHZ) ? HIGH : LOW)
             ------------------------1-----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       671
 EXPRESSION 
 Number  Term
      1  ((select_bscan_internal & (~stap_fsm_shift_ir_neg)) == HIGH) ? fbscan_tdo_delay : (((stap_fbscan_runbist_en & (~stap_fsm_shift_ir_neg)) == HIGH) ? fbscan_tdo_delay : pre_tdo))

-1- Status
 0  Covered
 1  Covered

 LINE       671
 SUB-EXPRESSION (((stap_fbscan_runbist_en & (~stap_fsm_shift_ir_neg)) == HIGH) ? fbscan_tdo_delay : pre_tdo)
                 ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       297
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_PRELOAD) ? HIGH : LOW)
             ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       299
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_PRELOAD) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       316
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW)
             --------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       318
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW)
             ------------------------1-----------------------

-1- Status
 0  Covered
 1  Covered

 LINE       335
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_INTEST) ? HIGH : LOW)
             ---------------------------1--------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       337
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_INTEST) ? HIGH : LOW)
             ------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       354
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_RUNBIST) ? HIGH : LOW)
             ---------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       356
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_RUNBIST) ? HIGH : LOW)
             -------------------------1------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       373
 EXPRESSION ((stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) ? HIGH : LOW)
             ------------------------------1------------------------------

-1- Status
 0  Covered
 1  Covered

 LINE       375
 EXPRESSION ((stap_irreg_ireg == BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) ? HIGH : LOW)
             ----------------------------1---------------------------

-1- Status
 0  Covered
 1  Covered

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_bscan 
                Total Covered Percent 
Totals          94    94      100.00  
Total Bits      248   248     100.00  
Total Bits 0->1 124   124     100.00  
Total Bits 1->0 124   124     100.00  

                              
Ports          31  31  100.00 
Port Bits      122 122 100.00 
Port Bits 0->1 61  61  100.00 
Port Bits 1->0 61  61  100.00 

                                
Signals          63  63  100.00 
Signal Bits      126 126 100.00 
Signal Bits 0->1 63  63  100.00 
Signal Bits 1->0 63  63  100.00 

Port Details
                           Toggle Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                   Yes    Yes         Yes         INPUT     
powergood_rst_trst_b       Yes    Yes         Yes         INPUT     
stap_fsm_tlrs              Yes    Yes         Yes         INPUT     
stap_fsm_rti               Yes    Yes         Yes         INPUT     
stap_fsm_e1dr              Yes    Yes         Yes         INPUT     
stap_fsm_e2dr              Yes    Yes         Yes         INPUT     
atap_tdo                   Yes    Yes         Yes         OUTPUT    
pre_tdo                    Yes    Yes         Yes         INPUT     
stap_fbscan_tck            Yes    Yes         Yes         OUTPUT    
stap_abscan_tdo            Yes    Yes         Yes         INPUT     
stap_fbscan_capturedr      Yes    Yes         Yes         OUTPUT    
stap_fbscan_shiftdr        Yes    Yes         Yes         OUTPUT    
stap_fbscan_updatedr       Yes    Yes         Yes         OUTPUT    
stap_fbscan_updatedr_clk   Yes    Yes         Yes         OUTPUT    
stap_fbscan_runbist_en     Yes    Yes         Yes         OUTPUT    
stap_fbscan_highz          Yes    Yes         Yes         OUTPUT    
stap_fbscan_extogen        Yes    Yes         Yes         OUTPUT    
stap_fbscan_intest_mode    Yes    Yes         Yes         OUTPUT    
stap_fbscan_chainen        Yes    Yes         Yes         OUTPUT    
stap_fbscan_mode           Yes    Yes         Yes         OUTPUT    
stap_fbscan_extogsig_b     Yes    Yes         Yes         OUTPUT    
stap_fbscan_d6init         Yes    Yes         Yes         OUTPUT    
stap_fbscan_d6actestsig_b  Yes    Yes         Yes         OUTPUT    
stap_fbscan_d6select       Yes    Yes         Yes         OUTPUT    
stap_fsm_capture_dr        Yes    Yes         Yes         INPUT     
stap_fsm_shift_dr          Yes    Yes         Yes         INPUT     
stap_fsm_update_dr         Yes    Yes         Yes         INPUT     
stap_irreg_ireg[15:0]      Yes    Yes         Yes         INPUT     
stap_fsm_update_ir         Yes    Yes         Yes         INPUT     
stap_irreg_shift_reg[15:0] Yes    Yes         Yes         INPUT     
stap_fsm_shift_ir_neg      Yes    Yes         Yes         INPUT     

Signal Details
                                                     Toggle Toggle 1->0 Toggle 0->1 
by_two_clock                                         Yes    Yes         Yes         
select_bscan_internal                                Yes    Yes         Yes         
inst_preload                                         Yes    Yes         Yes         
inst_preload_early                                   Yes    Yes         Yes         
inst_intest                                          Yes    Yes         Yes         
inst_intest_early                                    Yes    Yes         Yes         
fbscan_intest_early_dly                              Yes    Yes         Yes         
e1dr_or_e2dr                                         Yes    Yes         Yes         
train_or_pulse                                       Yes    Yes         Yes         
edr_and_trainorpulse                                 Yes    Yes         Yes         
cadr_and_extest                                      Yes    Yes         Yes         
cadr_and_extest_dly                                  Yes    Yes         Yes         
enable_clk                                           Yes    Yes         Yes         
tap_d6sel_mxsel                                      Yes    Yes         Yes         
dot6_actestsig                                       Yes    Yes         Yes         
dot6_actestsigb                                      Yes    Yes         Yes         
fbscan_tdo_delay                                     Yes    Yes         Yes         
decode_pulse_shiftreg                                Yes    Yes         Yes         
decode_train_shiftreg                                Yes    Yes         Yes         
inst_extest_pulse_early                              Yes    Yes         Yes         
inst_extest_train_early                              Yes    Yes         Yes         
pulse_train_early_delay                              Yes    Yes         Yes         
inst_sampre_early                                    Yes    Yes         Yes         
inst_sampre                                          Yes    Yes         Yes         
decode_sampre_shiftreg                               Yes    Yes         Yes         
upir_and_sampre_shiftreg                             Yes    Yes         Yes         
inst_extesttoggle                                    Yes    Yes         Yes         
inst_extesttoggle_early                              Yes    Yes         Yes         
inst_clamp_early                                     Yes    Yes         Yes         
inst_clamp                                           Yes    Yes         Yes         
inst_extest_pulse                                    Yes    Yes         Yes         
inst_extest_train                                    Yes    Yes         Yes         
decode_extest_shiftreg                               Yes    Yes         Yes         
upir_and_extest_shiftreg                             Yes    Yes         Yes         
inst_extest                                          Yes    Yes         Yes         
inst_extest_early                                    Yes    Yes         Yes         
decode_highz_shiftreg                                Yes    Yes         Yes         
upir_and_highz_shiftreg                              Yes    Yes         Yes         
inst_highz                                           Yes    Yes         Yes         
inst_highz_early                                     Yes    Yes         Yes         
fbscan_mode_early                                    Yes    Yes         Yes         
fbscan_mode_early_dly                                Yes    Yes         Yes         
fbscan_chainen_early                                 Yes    Yes         Yes         
fbscan_chainen_early_dly                             Yes    Yes         Yes         
fbscan_highz_early_dly                               Yes    Yes         Yes         
inst_extog_early_dly                                 Yes    Yes         Yes         
tap_bscanshclk_en                                    Yes    Yes         Yes         
upir_and_pulse_shiftreg                              Yes    Yes         Yes         
upir_and_train_shiftreg                              Yes    Yes         Yes         
runbist_en_early                                     Yes    Yes         Yes         
stap_fbscan_chainen_int                              Yes    Yes         Yes         
stap_fbscan_mode_int                                 Yes    Yes         Yes         
stap_fbscan_d6select_int                             Yes    Yes         Yes         
generate_preload_reg.decode_preload_shiftreg         Yes    Yes         Yes         
generate_preload_reg.upir_and_preload_shiftreg       Yes    Yes         Yes         
generate_clamp_reg.decode_clamp_shiftreg             Yes    Yes         Yes         
generate_clamp_reg.upir_and_clamp_shiftreg           Yes    Yes         Yes         
generate_intest_reg.decode_intest_shiftreg           Yes    Yes         Yes         
generate_intest_reg.upir_and_intest_shiftreg         Yes    Yes         Yes         
generate_runbist_reg.decode_runbist_en_shreg         Yes    Yes         Yes         
generate_runbist_reg.upir_and_runbist_en_shreg       Yes    Yes         Yes         
generate_extest_toggle_reg.decode_extesttoggle_shreg Yes    Yes         Yes         
generate_extest_toggle_reg.upir_and_extog_shiftreg   Yes    Yes         Yes         


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_RTL_LIB.stap_bscan 
         Line No. Total Covered Percent 
Branches          65    65      100.00  
TERNARY  248      2     2       100.00  
TERNARY  250      2     2       100.00  
TERNARY  256      2     2       100.00  
TERNARY  258      2     2       100.00  
TERNARY  264      2     2       100.00  
TERNARY  266      2     2       100.00  
TERNARY  272      2     2       100.00  
TERNARY  274      2     2       100.00  
TERNARY  280      2     2       100.00  
TERNARY  282      2     2       100.00  
TERNARY  671      3     3       100.00  
TERNARY  297      2     2       100.00  
TERNARY  299      2     2       100.00  
TERNARY  316      2     2       100.00  
TERNARY  318      2     2       100.00  
TERNARY  335      2     2       100.00  
TERNARY  337      2     2       100.00  
TERNARY  354      2     2       100.00  
TERNARY  356      2     2       100.00  
TERNARY  373      2     2       100.00  
TERNARY  375      2     2       100.00  
IF       425      2     2       100.00  
IF       513      2     2       100.00  
IF       535      3     3       100.00  
IF       559      3     3       100.00  
IF       575      3     3       100.00  
IF       613      3     3       100.00  
IF       635      3     3       100.00  
IF       657      3     3       100.00  


248           assign decode_pulse_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE) ? HIGH : LOW;
                                                                                                            -1-  
                                                                                                            ==>  
                                                                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


250           assign inst_extest_pulse       = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_EXTEST_PULSE) ? HIGH : LOW;
                                                                                                            -1-  
                                                                                                            ==>  
                                                                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


256           assign decode_train_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN) ? HIGH : LOW;
                                                                                                            -1-  
                                                                                                            ==>  
                                                                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


258           assign inst_extest_train       = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_EXTEST_TRAIN) ? HIGH : LOW;
                                                                                                            -1-  
                                                                                                            ==>  
                                                                                                            ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


264           assign decode_sampre_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


266           assign inst_sampre              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_SAMPLE_PRELOAD) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


272           assign decode_extest_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST) ? HIGH : LOW;
                                                                                                       -1-  
                                                                                                       ==>  
                                                                                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


274           assign inst_extest              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_EXTEST) ? HIGH : LOW;
                                                                                                       -1-  
                                                                                                       ==>  
                                                                                                       ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


280           assign decode_highz_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_HIGHZ) ? HIGH : LOW;
                                                                                                     -1-  
                                                                                                     ==>  
                                                                                                     ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


282           assign inst_highz              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_HIGHZ) ? HIGH : LOW;
                                                                                                     -1-  
                                                                                                     ==>  
                                                                                                     ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


671           assign atap_tdo = ((select_bscan_internal & (~stap_fsm_shift_ir_neg)) == HIGH) ? fbscan_tdo_delay :
                                                                                             -1-  
                                                                                             ==>  
672                             ((stap_fbscan_runbist_en  & (~stap_fsm_shift_ir_neg)) == HIGH) ? fbscan_tdo_delay : pre_tdo;
                                                                                               -2-  
                                                                                               ==>  
                                                                                               ==>  

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


297                 assign decode_preload_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_PRELOAD) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


299                 assign inst_preload              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_PRELOAD) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


316                 assign decode_clamp_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
                                                                                                           -1-  
                                                                                                           ==>  
                                                                                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


318                 assign inst_clamp              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_CLAMP) ? HIGH : LOW;
                                                                                                           -1-  
                                                                                                           ==>  
                                                                                                           ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


335                 assign decode_intest_shiftreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_INTEST) ? HIGH : LOW;
                                                                                                             -1-  
                                                                                                             ==>  
                                                                                                             ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


337                 assign inst_intest              = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_INTEST) ? HIGH : LOW;
                                                                                                             -1-  
                                                                                                             ==>  
                                                                                                             ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


354                 assign decode_runbist_en_shreg   = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_RUNBIST) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


356                 assign stap_fbscan_runbist_en    = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_RUNBIST) ? HIGH : LOW;
                                                                                                               -1-  
                                                                                                               ==>  
                                                                                                               ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


373                 assign decode_extesttoggle_shreg = (stap_irreg_shift_reg == BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) ? HIGH : LOW;
                                                                                                                     -1-  
                                                                                                                     ==>  
                                                                                                                     ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


375                 assign inst_extesttoggle         = (stap_irreg_ireg      == BSCAN_STAP_ADDRESS_OF_EXTEST_TOGGLE) ? HIGH : LOW;
                                                                                                                     -1-  
                                                                                                                     ==>  
                                                                                                                     ==>  

Branches:

-1- Status  
1   Covered 
0   Covered 


425              if (!powergood_rst_trst_b)
                 -1-  
426              begin
427                 fbscan_chainen_early_dly <= LOW;
                    ==>
428                 fbscan_mode_early_dly    <= LOW;
429                 fbscan_highz_early_dly   <= LOW;
430                 inst_extog_early_dly     <= LOW;
431                 fbscan_intest_early_dly  <= LOW;
432              end
433              else
434              begin
435                 fbscan_chainen_early_dly <= fbscan_chainen_early;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


513              if (!powergood_rst_trst_b)
                 -1-  
514              begin
515                 stap_fbscan_updatedr_clk <= LOW;
                    ==>
516              end
517              else
518              begin
519                 stap_fbscan_updatedr_clk <= stap_fbscan_updatedr;
                    ==>

Branches:

-1- Status  
1   Covered 
0   Covered 


535              if (!powergood_rst_trst_b)
                 -1-  
536              begin
537                 pulse_train_early_delay <= LOW;
                    ==>
538              end
539              else if (stap_fsm_tlrs)
                      -2-  
540              begin
541                 pulse_train_early_delay <= LOW;
                    ==>
542              end
543              else
544              begin
545                 pulse_train_early_delay <= inst_extest_pulse_early | inst_extest_train_early;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


559              if (!powergood_rst_trst_b)
                 -1-  
560              begin
561                 tap_d6sel_mxsel <= LOW;
                    ==>
562              end
563              else if (stap_fsm_tlrs)
                      -2-  
564              begin
565                 tap_d6sel_mxsel <= LOW;
                    ==>
566              end
567              else
568              begin
569                 tap_d6sel_mxsel <= train_or_pulse;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


575              if (!powergood_rst_trst_b)
                 -1-  
576              begin
577                 dot6_actestsig <= LOW;
                    ==>
578              end
579              else if (stap_fsm_tlrs)
                      -2-  
580              begin
581                 dot6_actestsig <= LOW;
                    ==>
582              end
583              else
584              begin
585                 dot6_actestsig <= ((~(dot6_actestsig & inst_extest_train)) & stap_fsm_rti);
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


613              if (!powergood_rst_trst_b)
                 -1-  
614              begin
615                 cadr_and_extest_dly <= LOW;
                    ==>
616              end
617              else if (stap_fsm_tlrs)
                      -2-  
618              begin
619                 cadr_and_extest_dly <= LOW;
                    ==>
620              end
621              else
622              begin
623                 cadr_and_extest_dly <= cadr_and_extest;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


635              if (!powergood_rst_trst_b)
                 -1-  
636              begin
637                 by_two_clock <= LOW;
                    ==>
638              end
639              else if (stap_fsm_tlrs)
                      -2-  
640              begin
641                 by_two_clock <= LOW;
                    ==>
642              end
643              else
644              begin
645                 by_two_clock <= ~by_two_clock & inst_extesttoggle & stap_fsm_rti;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


657              if (!powergood_rst_trst_b)
                 -1-  
658              begin
659                 fbscan_tdo_delay <= LOW;
                    ==>
660              end
661              else if (stap_fsm_tlrs)
                      -2-  
662              begin
663                 fbscan_tdo_delay <= LOW;
                    ==>
664              end
665              else
666              begin
667                 fbscan_tdo_delay <= stap_abscan_tdo;
                    ==>

Branches:

-1- -2- Status  
1   -   Covered 
0   1   Covered 
0   0   Covered 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 100.00 100.00 100.00 --     100.00 --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.80 100.00 100.00 100.00 --     100.00  99.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                    
100.00 100.00 100.00 100.00 --     100.00 --     STAP_RTL_LIB.stap_bscan 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                       
 99.75 100.00 --     100.00 --     100.00  99.00 i_stap_bscan_assertions(x)                 
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_bscan             
100.00 100.00 --     100.00 --     100.00 --     i_stap_ctech_lib_clk_gate_te_trainpulse(x) 
100.00 --     100.00 100.00 --     100.00 --     i_stap_ctech_lib_clk_mux_2to1_d6init       
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_chainen                
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_d6select               
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_extogen                
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_highz                  
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_intest                 
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_dq_mode                   
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_mux_2to1_d6actest         



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.ctech_lib_clk_buf
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/p/hdk/cad/ctech/c2v16ww47e_hdk141/source/v/ctech_lib_clk_buf.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                                    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr.i_ctech_lib_clk_buf                                     
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2.i_ctech_lib_clk_buf                         
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck.i_ctech_lib_clk_buf    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1.i_ctech_lib_clk_buf 
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan.i_ctech_lib_clk_buf   



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.ctech_lib_clk_buf 
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr.i_ctech_lib_clk_buf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                          
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_rtdr 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr.i_ctech_lib_clk_buf
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2.i_ctech_lib_clk_buf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                          
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_tck2 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2.i_ctech_lib_clk_buf
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck.i_ctech_lib_clk_buf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                               
100.00 --     --     100.00 --     --     --     generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck.i_ctech_lib_clk_buf
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1.i_ctech_lib_clk_buf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                  
100.00 --     --     100.00 --     --     --     generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1.i_ctech_lib_clk_buf
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan.i_ctech_lib_clk_buf
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     i_stap_ctech_lib_clk_buf_bscan 


Subtrees :


no children
----------------


-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan.i_ctech_lib_clk_buf
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_RTL_LIB.stap_ctech_lib_dq
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/ctech_lib/stap_ctech_map.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                            
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq                               
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen  
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode     
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen  
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest   
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_ctech_lib_dq 
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     100.00 100.00 --     100.00 --     i_stap_glue(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_dq
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_chainen
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_mode
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_highz
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_extogen
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_intest
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                           
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_dq 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     --     100.00 --     --     --     i_ctech_lib_dq 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_dq_d6select
                Total Covered Percent 
Totals          3     3       100.00  
Total Bits      6     6       100.00  
Total Bits 0->1 3     3       100.00  
Total Bits 1->0 3     3       100.00  

                          
Ports          3 3 100.00 
Port Bits      6 6 100.00 
Port Bits 0->1 3 3 100.00 
Port Bits 1->0 3 3 100.00 

Port Details
  Toggle Toggle 1->0 Toggle 0->1 Direction 
a Yes    Yes         Yes         INPUT     
b Yes    Yes         Yes         INPUT     
o Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_RTL_LIB.stap_ctech_lib_clk_mux_2to1
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/ctech_lib/stap_ctech_map.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_mux_2to1_d6init 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_ctech_lib_clk_mux_2to1 
                Total Covered Percent 
Totals          4     4       100.00  
Total Bits      8     8       100.00  
Total Bits 0->1 4     4       100.00  
Total Bits 1->0 4     4       100.00  

                          
Ports          4 4 100.00 
Port Bits      8 8 100.00 
Port Bits 0->1 4 4 100.00 
Port Bits 1->0 4 4 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk1   Yes    Yes         Yes         INPUT     
clk2   Yes    Yes         Yes         INPUT     
s      Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_mux_2to1_d6init
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     100.00 100.00 --     100.00 --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                     
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_mux_2to1 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                     
100.00 --     100.00 100.00 --     100.00 --     i_ctech_lib_clk_mux_2to1 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_RTL_LIB.stap_ctech_lib_clk_buf
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/source/rtl/ctech_lib/stap_ctech_map.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                                
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr                                     
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2                         
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck    
100.00 --     --     100.00 --     --     --     top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1 
100.00 --     --     100.00 --     --     --     top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan   



-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_RTL_LIB.stap_ctech_lib_clk_buf 
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME             
 99.88 --     --      99.88 --     --     --     stap_top_inst(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_ctech_lib_clk_buf 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_ctech_lib_clk_buf_rtdr
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     100.00 100.00 --     100.00 --     i_stap_glue(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_ctech_lib_clk_buf 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.i_stap_ctech_lib_clk_buf_tck2
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     100.00 100.00 --     100.00 --     i_stap_glue(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_ctech_lib_clk_buf 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.generate_wtap_cntrls.i_stap_ctech_lib_clk_buf_wrck
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME           
100.00 --     100.00 100.00 --     100.00 --     i_stap_glue(x) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_ctech_lib_clk_buf 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.i_stap_glue.generate_tapnw_cntrls.i_stap_ctech_lib_clk_buf_tapnw1
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     100.00 --     --     --     


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                
100.00 --     --     100.00 --     --     --     STAP_RTL_LIB.stap_ctech_lib_clk_buf 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                             
100.00 100.00 100.00 100.00 --     100.00 --     generate_stap_bscan.i_stap_bscan 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                
100.00 --     --     100.00 --     --     --     i_ctech_lib_clk_buf 



-------------------------------------------------------------------------------
Toggle Coverage for Instance : top.stap_top_inst.generate_stap_bscan.i_stap_bscan.i_stap_ctech_lib_clk_buf_bscan
                Total Covered Percent 
Totals          2     2       100.00  
Total Bits      4     4       100.00  
Total Bits 0->1 2     2       100.00  
Total Bits 1->0 2     2       100.00  

                          
Ports          2 2 100.00 
Port Bits      4 4 100.00 
Port Bits 0->1 2 2 100.00 
Port Bits 1->0 2 2 100.00 

Port Details
       Toggle Toggle 1->0 Toggle 0->1 Direction 
clk    Yes    Yes         Yes         INPUT     
clkout Yes    Yes         Yes         OUTPUT    


===============================================================================
Module : STAP_TB_LIB.stap_rtdr_ref(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/stap_rtdr_ref.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                                                                  
--     --     --     --     --     --     --     top.tdo_glue.generate_rtdr_asyc.genblk1.genblk1[0].i_stap_data_reg(X) 
--     --     --     --     --     --     --     top.tdo_glue.generate_rtdr_asyc.genblk1.genblk1[1].i_stap_data_reg(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_TB_LIB.stap_rtdr_ref (X)

             Line No.   Total   Covered  Percent
TOTAL                        0        0
ALWAYS            103        0        0
ALWAYS            156        0        0

102                              begin
103        excluded                 if (!reset_b)
104                                 begin
105        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
106                                 end
107        excluded                 else if (sync_reset)
108                                 begin
109        excluded                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
110                                 end
111        excluded                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
112                                 begin
113        excluded                    shift_register <= tdr_data_in;
114                                 end
115        excluded                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
116                                 begin
117        excluded                    shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
118                                 end
                   ==>  MISSING_ELSE
119                              end
120                           end
121                           else
122                           begin:generate_tdr_shift_capture
123                              always_ff @(posedge ftap_tck or negedge reset_b)
124                              begin
125                                 if (!reset_b)
126                                 begin
127                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
128                                 end
129                                 else if (sync_reset)
130                                 begin
131                                    shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
132                                 end
133                                 else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
134                                 begin
135                                    shift_register <= tdr_data_in;
136                                 end
137                                 else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
138                                 begin
139                                    shift_register <= ftap_tdi;
140                                 end
141                              end
142                           end
143                        endgenerate
144                     
145                        // *********************************************************************
146                        // Bit0 is assigned to data_reg_tdo and this is going to the TDOmux FUB.
147                        // *********************************************************************
148                        assign data_reg_tdo = shift_register[0];
149                     
150                        // *********************************************************************
151                        // parallel register implementation - the value will be updated to parallel
152                        // reg during update_DR state and negedge of tck
153                        // *********************************************************************
154                        always_ff @(negedge ftap_tck or negedge reset_b)
155                        begin
156        excluded           if (!reset_b)
157                           begin
158        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
159                           end
160        excluded           else if (sync_reset)
161                           begin
162        excluded              tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
163                           end
164        excluded           else if (stap_fsm_update_dr & stap_irdecoder_drselect)
165                           begin
166        excluded              tdr_data_out <= shift_register;
167                           end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_TB_LIB.stap_rtdr_ref (X)
Port Details
                        Toggle   Toggle 1->0 Toggle 0->1 Direction 
sync_reset              Excluded Excluded    Excluded    INPUT     
ftap_tck                Excluded Excluded    Excluded    INPUT     
ftap_tdi                Excluded Excluded    Excluded    INPUT     
reset_b                 Excluded Excluded    Excluded    INPUT     
stap_irdecoder_drselect Excluded Excluded    Excluded    INPUT     
stap_fsm_capture_dr     Excluded Excluded    Excluded    INPUT     
stap_fsm_shift_dr       Excluded Excluded    Excluded    INPUT     
stap_fsm_update_dr      Excluded Excluded    Excluded    INPUT     
tdr_data_in[31:0]       Excluded Excluded    Excluded    INPUT     
data_reg_tdo            Excluded Excluded    Excluded    OUTPUT    
tdr_data_out[31:0]      Excluded Excluded    Excluded    OUTPUT    

Signal Details
                     Toggle   Toggle 1->0 Toggle 0->1 
shift_register[31:0] Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_TB_LIB.stap_rtdr_ref (X)
         Line No. Total Covered Percent 
Branches          0     0               
IF       156      0     0               
IF       103      0     0               


156              if (!reset_b)
                 -1-  
157              begin
158                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
159              end
160              else if (sync_reset)
                      -2-  
161              begin
162                 tdr_data_out <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                    ==> (Excluded)
163              end
164              else if (stap_fsm_update_dr & stap_irdecoder_drselect)
                      -3-  
165              begin
166                 tdr_data_out <= shift_register;
                    ==> (Excluded)
167              end
                 MISSING_ELSE
                 ==> (Excluded)

Branches:

-1- -2- -3- Status   
1   -   -   Excluded 
0   1   -   Excluded 
0   0   1   Excluded 
0   0   0   Excluded 


103                    if (!reset_b)
                       -1-  
104                    begin
105                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
106                    end
107                    else if (sync_reset)
                            -2-  
108                    begin
109                       shift_register <= DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS;
                          ==> (Excluded)
110                    end
111                    else if (stap_fsm_capture_dr & stap_irdecoder_drselect)
                            -3-  
112                    begin
113                       shift_register <= tdr_data_in;
                          ==> (Excluded)
114                    end
115                    else if (stap_fsm_shift_dr & stap_irdecoder_drselect)
                            -4-               
116                    begin
117                       shift_register <= {ftap_tdi, shift_register[(DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER - 1):1]};
                          ==> (Excluded)
118                    end
                       MISSING_ELSE
                       ==> (Excluded)

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Excluded 
0   1   -   -   Excluded 
0   0   1   -   Excluded 
0   0   0   1   Excluded 
0   0   0   0   Excluded 


===============================================================================
Module : STAP_PKG_LIB.stap_pin_if(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/stap_pin_if.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME       
--     --     --     --     --     --     --     top.pif(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_PKG_LIB.stap_pin_if (X)

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL           172        0        0
INITIAL           185        0        0

171                         initial begin
172        excluded             stap_isol_en_b    = 1'b1;
173        excluded             ftap_pwrdomain_rst_b = 1'b1;
174        excluded             ftap_slvidcode    = $random();
175        excluded             parallel_data_in  = $random();
176        excluded             if (TB_DISABLE_MISC_DRIVE==LOW)
177                             begin
178        excluded                 atapsecs_tms2        = $random();
179        excluded                 trst2_b              = $random();
180        excluded                 atapsecs_tdi2        = $random();
181        excluded                 sntapnw_atap_tdo2_en = $random();
182                             end
                   ==>  MISSING_ELSE
183                         end
184                         initial begin
185        excluded             #1200ns;
186        excluded             repeat (200) begin
187        excluded                 repeat (1) @(negedge ftap_tck);
                   ==>  REPEAT_FALSE
188        excluded                 ftap_slvidcode   = $random();
189        excluded                 parallel_data_in = $random();
190        excluded                 if (TB_DISABLE_MISC_DRIVE==LOW)
191                                 begin
192        excluded                     atapsecs_tms2        = $random();
193        excluded                     trst2_b              = $random();
194        excluded                     atapsecs_tdi2        = $random();
195        excluded                     sntapnw_atap_tdo2_en = $random();
196                                 end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_PKG_LIB.stap_pin_if (X)
Port Details
       Toggle   Toggle 1->0 Toggle 0->1 Direction 
tck    Excluded Excluded    Excluded    INPUT     
trst_b Excluded Excluded    Excluded    INPUT     

Signal Details
                          Toggle   Toggle 1->0 Toggle 0->1 
stap_isol_en              Excluded Excluded    Excluded    
stap_isol_en_b            Excluded Excluded    Excluded    
ftap_pwrdomain_rst_b      Excluded Excluded    Excluded    
ftap_tck                  Excluded Excluded    Excluded    
ftap_tms                  Excluded Excluded    Excluded    
ftap_trst_b               Excluded Excluded    Excluded    
ftap_tdi                  Excluded Excluded    Excluded    
ftap_slvidcode[31:0]      Excluded Excluded    Excluded    
atap_tdo                  Excluded Excluded    Excluded    
fdfx_powergood            Excluded Excluded    Excluded    
parallel_data_out[63:0]   Excluded Excluded    Excluded    
parallel_data_in[63:0]    Excluded Excluded    Excluded    
fdfx_secure_policy[3:0]   Excluded Excluded    Excluded    
fdfx_policy_update        Excluded Excluded    Excluded    
fdfx_earlyboot_exit       Excluded Excluded    Excluded    
sb_policy_ovr_value[4:0]  Excluded Excluded    Excluded    
oem_secure_policy[3:0]    Excluded Excluded    Excluded    
atap_secsel[3:0]          Excluded Excluded    Excluded    
atap_enabletdo[3:0]       Excluded Excluded    Excluded    
atap_enabletap[3:0]       Excluded Excluded    Excluded    
sntapnw_ftap_tck          Excluded Excluded    Excluded    
sntapnw_ftap_tms          Excluded Excluded    Excluded    
sntapnw_ftap_trst_b       Excluded Excluded    Excluded    
sntapnw_ftap_tdi          Excluded Excluded    Excluded    
sntapnw_atap_tdo          Excluded Excluded    Excluded    
atapsecs_tck2             Excluded Excluded    Excluded    
atapsecs_tms2             Excluded Excluded    Excluded    
trst2_b                   Excluded Excluded    Excluded    
atapsecs_tdi2             Excluded Excluded    Excluded    
ftapsecs_tdo2             Excluded Excluded    Excluded    
ftapsecs_tdo2_en          Excluded Excluded    Excluded    
sntapnw_ftap_tck2         Excluded Excluded    Excluded    
sntapnw_ftap_tms2         Excluded Excluded    Excluded    
sntapnw_ftap_trst2_b      Excluded Excluded    Excluded    
sntapnw_ftap_tdi2         Excluded Excluded    Excluded    
sntapnw_atap_tdo2         Excluded Excluded    Excluded    
sntapnw_atap_tdo2_en[3:0] Excluded Excluded    Excluded    
sn_fwtap_wrck             Excluded Excluded    Excluded    
sn_fwtap_wrst_b           Excluded Excluded    Excluded    
atap_capturewr            Excluded Excluded    Excluded    
atap_shiftwr              Excluded Excluded    Excluded    
atap_updatewr             Excluded Excluded    Excluded    
atap_rti                  Excluded Excluded    Excluded    
atap_wtapnw_selectwir     Excluded Excluded    Excluded    
sn_awtap_wso[2:0]         Excluded Excluded    Excluded    
atap_wtapnw_wsi[2:0]      Excluded Excluded    Excluded    
stap_fbscan_tck           Excluded Excluded    Excluded    
stap_abscan_tdo           Excluded Excluded    Excluded    
stap_fbscan_capturedr     Excluded Excluded    Excluded    
stap_fbscan_shiftdr       Excluded Excluded    Excluded    
stap_fbscan_updatedr      Excluded Excluded    Excluded    
stap_fbscan_updatedr_clk  Excluded Excluded    Excluded    
stap_fbscan_runbist_en    Excluded Excluded    Excluded    
stap_fbscan_highz         Excluded Excluded    Excluded    
stap_fbscan_extogen       Excluded Excluded    Excluded    
stap_fbscan_intest_mode   Excluded Excluded    Excluded    
stap_fbscan_chainen       Excluded Excluded    Excluded    
stap_fbscan_mode          Excluded Excluded    Excluded    
stap_fbscan_extogsig_b    Excluded Excluded    Excluded    
stap_fbscan_d6init        Excluded Excluded    Excluded    
stap_fbscan_d6actestsig_b Excluded Excluded    Excluded    
stap_fbscan_d6select      Excluded Excluded    Excluded    
rtdr_tap_tdo[2:0]         Excluded Excluded    Excluded    
tap_rtdr_tdi[2:0]         Excluded Excluded    Excluded    
tap_rtdr_capture[2:0]     Excluded Excluded    Excluded    
tap_rtdr_shift[2:0]       Excluded Excluded    Excluded    
tap_rtdr_update[2:0]      Excluded Excluded    Excluded    
tap_rtdr_selectir         Excluded Excluded    Excluded    
tap_rtdr_powergood        Excluded Excluded    Excluded    
tap_rtdr_irdec[2:0]       Excluded Excluded    Excluded    
tap_rtdr_tck              Excluded Excluded    Excluded    
tap_rtdr_rti              Excluded Excluded    Excluded    
tap_rtdr_prog_rst_b[2:0]  Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_PKG_LIB.stap_pin_if (X)
         Line No. Total Covered Percent 
Branches          0     0               
IF       176      0     0               
IF       190      0     0               


176                if (TB_DISABLE_MISC_DRIVE==LOW)
                   -1-  
177                begin
178                    atapsecs_tms2        = $random();
                       ==> (Excluded)
179                    trst2_b              = $random();
180                    atapsecs_tdi2        = $random();
181                    sntapnw_atap_tdo2_en = $random();
182                end
                   MISSING_ELSE
                   ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


190                    if (TB_DISABLE_MISC_DRIVE==LOW)
                       -1-  
191                    begin
192                        atapsecs_tms2        = $random();
                           ==> (Excluded)
193                        trst2_b              = $random();
194                        atapsecs_tdi2        = $random();
195                        sntapnw_atap_tdo2_en = $random();
196                    end
                       MISSING_ELSE
                       ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


===============================================================================
Module : SIP_SHARED_LIB.DfxSecurePlugin_pin_if(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/subIP/DfxSecurePlugin/verif/tb/DfxSecurePlugin_pin_if.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                  
--     --     --     --     --     --     --     top.dfxsecure_pins(X) 



-------------------------------------------------------------------------------
Toggle Coverage for Module : \SIP_SHARED_LIB.DfxSecurePlugin_pin_if (X)
Port Details
       Toggle   Toggle 1->0 Toggle 0->1 Direction 
tb_clk Excluded Excluded    Excluded    INPUT     

Signal Details
                          Toggle   Toggle 1->0 Toggle 0->1 
fdfx_powergood            Excluded Excluded    Excluded    
fdfx_secure_policy[3:0]   Excluded Excluded    Excluded    
fdfx_earlyboot_exit       Excluded Excluded    Excluded    
fdfx_policy_update        Excluded Excluded    Excluded    
dfxsecure_feature_en[2:0] Excluded Excluded    Excluded    
visa_all_dis              Excluded Excluded    Excluded    
visa_customer_dis         Excluded Excluded    Excluded    
sb_policy_ovr_value[4:0]  Excluded Excluded    Excluded    
oem_secure_policy[3:0]    Excluded Excluded    Excluded    


===============================================================================
Module : STAP_TI_LIB.STap_ti(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/STap_ti.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                   
--     --     --     --     --     --     --     top.i_TapTestIsland(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_TI_LIB.STap_ti (X)

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL            86        0        0

85                         initial begin
86         excluded           i_TapVifContainer = new ();
87         excluded           i_TapVifContainer.set_v_if (pif);
88         excluded           set_config_object ("*", "V_STAP_PINIF", i_TapVifContainer,0);

-------------------------------------------------------------------------------
===============================================================================
Module Instance : top.i_TapTestIsland(X)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
100.00 --     --     --     --     --     100.00 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                   
--     --     --     --     --     --     --     STAP_TI_LIB.STap_ti(X) 


Parent : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME   
--     --     --     --     --     --     --     top(X) 


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME                  
100.00 --     --     --     --     --     100.00 pri_JtagBfmTestIsland 



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
===============================================================================
Module : STAP_TB_LIB.emulate_stap_tdo(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/emulate_stap_tdo.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME            
--     --     --     --     --     --     --     top.tdo_glue(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : \STAP_TB_LIB.emulate_stap_tdo (X)

             Line No.   Total   Covered  Percent
TOTAL                        0        0
ALWAYS            145        0        0
ALWAYS            171        0        0
ALWAYS            184        0        0
ALWAYS            293        0        0

144                        begin
145        excluded          stap_abscan_tdo = pre_fbscan_tdo;
146        excluded          if ((STAP_EN_TAP_NETWORK == 1) & (atap_enabletap != 0))
147                          begin
148        excluded             sntapnw_atap_tdo  = sntapnw_ftap_tdi;
149        excluded             sntapnw_atap_tdo2 = sntapnw_ftap_tdi2;
150        excluded             sn_awtap_wso      = $random;
151                          end
152                          else
153                          begin
154        excluded             if (STAP_EN_WTAP_NETWORK == 1)
155                                begin
156        excluded                sntapnw_atap_tdo  = $random;
157        excluded                sntapnw_atap_tdo2 = $random;
158        excluded                sn_awtap_wso      = atap_wtapnw_wsi;
159                             end
160                             else
161                             begin
162        excluded                sntapnw_atap_tdo  = $random;
163        excluded                sntapnw_atap_tdo2 = $random;
164        excluded                sn_awtap_wso      = $random;
165                             end
166                          end
167                        end
168                     
169                        always_ff @(posedge ftap_tck or ftap_trst_b or fdfx_powergood)
170                        begin
171        excluded           if ((ftap_trst_b == 1'b0) | (fdfx_powergood == 1'b0))
172                           begin
173        excluded              scan_reg <= 3'h0;
174                           end
                   ==>  MISSING_ELSE
175        excluded           if (stap_fbscan_shiftdr == 1'b1)
176                           begin
177        excluded              scan_reg[(LENGTH_OF_BSCAN_CHAIN - 2):0] <= scan_reg[(LENGTH_OF_BSCAN_CHAIN - 1):(LENGTH_OF_BSCAN_CHAIN - 2)];
178        excluded              scan_reg[(LENGTH_OF_BSCAN_CHAIN - 1)]   <= ftap_tdi_delayed;
179                           end
                   ==>  MISSING_ELSE
180                        end
181                     
182                        always_ff @(posedge ftap_tck or ftap_trst_b or fdfx_powergood)
183                        begin
184        excluded           if ((ftap_trst_b == 1'b0) | (fdfx_powergood == 1'b0))
185                           begin
186        excluded              runbist_reg <= 1'b0;
187                           end
                   ==>  MISSING_ELSE
188        excluded           if (stap_fbscan_runbist_en == 1'b1)
189                           begin
190        excluded              runbist_reg <= ftap_tdi_delayed;
191                           end
                   ==>  MISSING_ELSE
192                        end
193                     
194                        assign pre_fbscan_tdo = (stap_fbscan_runbist_en == 1'b1) ? runbist_reg : scan_reg[0];
195                     
196                        /*************************************************/
197                        /* Logic for Remote TDR                          */
198                        /* This implementation is for RTDR on TCK domain */
199                        /*************************************************/
200                        localparam TB_SIZE_OF_REMOTE_TDR_NZ = (TB_REMOTE_TDR_ENABLE == 0) ? 2 : TB_SIZE_OF_REMOTE_TDR;
201                     
202                        reg [(TB_SIZE_OF_REMOTE_TDR_NZ - 1):0] rtdr_shift_reg2, rtdr_shadow_reg2;
203                        reg [(TB_NO_OF_REMOTE_TDR_NZ - 1):0]   rtdr_tap_tdo;
204                        logic [(TB_SIZE_OF_REMOTE_TDR_NZ-1):0]  rtdr_lb[1:0];
205                     
206                        //-----------------------------------------
207                        // Main Logic for RTDR
208                        //-----------------------------------------
209                        generate
210                           if (TB_REMOTE_TDR_ENABLE == 1)
211                           begin:generate_rtdr_asyc
212                              if (TB_RTDR_IS_BUSSED_NZ == 1)
213                              begin
214                                 for (genvar y = 0; y < (TB_NO_OF_REMOTE_TDR_NZ - 1); y++)
215                                 begin
216                                    stap_rtdr_ref #(
217                                                    .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           ((TB_SIZE_OF_REMOTE_TDR_NZ)),
218                                                    .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}})
219                                                   )
220                                    i_stap_data_reg (
221                                                     .sync_reset              (1'b0),
222                                                     .ftap_tck                (tap_rtdr_tck),
223                                                     .ftap_tdi                (tap_rtdr_tdi[0]),
224                                                     .reset_b                 (tap_rtdr_prog_rst_b[y]),
225                                                     .stap_irdecoder_drselect (tap_rtdr_irdec[y]),
226                                                     .stap_fsm_capture_dr     (tap_rtdr_capture[0]),
227                                                     .stap_fsm_shift_dr       (tap_rtdr_shift[0]),
228                                                     .stap_fsm_update_dr      (tap_rtdr_update[0]),
229                                                     .tdr_data_in             (rtdr_lb[y]),
230                                                     .data_reg_tdo            (rtdr_tap_tdo[y]),
231                                                     .tdr_data_out            (rtdr_lb[y])
232                                                    );
233                                 end
234                              end
235                              else
236                              begin
237                                 for (genvar z = 0; z < (TB_NO_OF_REMOTE_TDR_NZ - 1); z++)
238                                 begin
239                                    stap_rtdr_ref #(
240                                                    .DATA_REG_STAP_SIZE_OF_EACH_TEST_DATA_REGISTER           ((TB_SIZE_OF_REMOTE_TDR_NZ)),
241                                                    .DATA_REG_STAP_RESET_VALUES_OF_TEST_DATA_REGISTERS       ({(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}})
242                                                   )
243                                    i_stap_data_reg (
244                                                     .sync_reset              (1'b0),
245                                                     .ftap_tck                (tap_rtdr_tck),
246                                                     .ftap_tdi                (tap_rtdr_tdi[z]),
247                                                     .reset_b                 (tap_rtdr_prog_rst_b[z]),
248                                                     .stap_irdecoder_drselect (tap_rtdr_irdec[z]),
249                                                     .stap_fsm_capture_dr     (tap_rtdr_capture[z]),
250                                                     .stap_fsm_shift_dr       (tap_rtdr_shift[z]),
251                                                     .stap_fsm_update_dr      (tap_rtdr_update[z]),
252                                                     .tdr_data_in             (rtdr_lb[z]),
253                                                     .data_reg_tdo            (rtdr_tap_tdo[z]),
254                                                     .tdr_data_out            (rtdr_lb[z])
255                                                    );
256                                 end
257                              end
258                           end:generate_rtdr_asyc
259                        endgenerate
260                     
261                        generate
262                           if (TB_REMOTE_TDR_ENABLE == 1)
263                           begin:generate_rtdr
264                              if (TB_RTDR_IS_BUSSED_NZ == 1)
265                              begin
266                                 always_ff @(posedge tap_rtdr_tck or negedge tap_rtdr_prog_rst_b[2])
267                                 begin
268                                    if (!tap_rtdr_prog_rst_b[2])
269                                    begin
270                                       rtdr_shift_reg2  <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
271                                       rtdr_shadow_reg2 <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
272                                    end
273                                    else if (tap_rtdr_irdec[2] & tap_rtdr_capture[0])
274                                    begin
275                                       rtdr_shift_reg2 <= rtdr_shadow_reg2;
276                                    end
277                                    else if (tap_rtdr_irdec[2] & tap_rtdr_shift[0])
278                                    begin
279                                       rtdr_shift_reg2 <= {tap_rtdr_tdi[0],rtdr_shift_reg2[(TB_SIZE_OF_REMOTE_TDR_NZ - 1):1]};
280                                    end
281                                    else if (tap_rtdr_irdec[2] & tap_rtdr_update[0])
282                                    begin
283                                       rtdr_shadow_reg2 <= rtdr_shift_reg2;
284                                    end
285                                 end
286                     
287                                 assign rtdr_tap_tdo[2] = rtdr_shift_reg2[0];
288                              end
289                              else
290                              begin
291                                 always_ff @(posedge tap_rtdr_tck or negedge tap_rtdr_prog_rst_b[2])
292                                 begin
293        excluded                    if (!tap_rtdr_prog_rst_b[2])
294                                    begin
295        excluded                       rtdr_shift_reg2  <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
296        excluded                       rtdr_shadow_reg2 <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
297                                    end
298        excluded                    else if (tap_rtdr_irdec[2] & tap_rtdr_capture[2])
299                                    begin
300        excluded                       rtdr_shift_reg2 <= rtdr_shadow_reg2;
301                                    end
302        excluded                    else if (tap_rtdr_irdec[2] & tap_rtdr_shift[2])
303                                    begin
304        excluded                       rtdr_shift_reg2 <= {tap_rtdr_tdi[2],rtdr_shift_reg2[(TB_SIZE_OF_REMOTE_TDR_NZ - 1):1]};
305                                    end
306        excluded                    else if (tap_rtdr_irdec[2] & tap_rtdr_update[2])
307                                    begin
308        excluded                       rtdr_shadow_reg2 <= rtdr_shift_reg2;
309                                    end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Cond Coverage for Module : \STAP_TB_LIB.emulate_stap_tdo (X)

               Total   Covered  Percent
Conditions          0        0
Logical             0        0
Non-Logical         0        0
Event               0        0

 LINE       194
 EXPRESSION ((stap_fbscan_runbist_en == 1'b1) ? runbist_reg : scan_reg[0])
             ----------------1---------------

-1- Status
 0  Excluded
 1  Excluded

-------------------------------------------------------------------------------
Toggle Coverage for Module : \STAP_TB_LIB.emulate_stap_tdo (X)
Port Details
                         Toggle   Toggle 1->0 Toggle 0->1 Direction 
ftap_tck                 Excluded Excluded    Excluded    INPUT     
ftap_trst_b              Excluded Excluded    Excluded    INPUT     
fdfx_powergood           Excluded Excluded    Excluded    INPUT     
atap_secsel[3:0]         Excluded Excluded    Excluded    INPUT     
atap_enabletdo[3:0]      Excluded Excluded    Excluded    INPUT     
atap_enabletap[3:0]      Excluded Excluded    Excluded    INPUT     
atap_wtapnw_selectwir    Excluded Excluded    Excluded    INPUT     
stap_fbscan_runbist_en   Excluded Excluded    Excluded    INPUT     
stap_fbscan_shiftdr      Excluded Excluded    Excluded    INPUT     
ftap_tdi                 Excluded Excluded    Excluded    INPUT     
stap_abscan_tdo          Excluded Excluded    Excluded    OUTPUT    
sntapnw_ftap_tdi         Excluded Excluded    Excluded    INPUT     
sntapnw_atap_tdo         Excluded Excluded    Excluded    OUTPUT    
sntapnw_ftap_tdi2        Excluded Excluded    Excluded    INPUT     
sntapnw_atap_tdo2        Excluded Excluded    Excluded    OUTPUT    
atap_wtapnw_wsi[2:0]     Excluded Excluded    Excluded    INPUT     
sn_awtap_wso[2:0]        Excluded Excluded    Excluded    OUTPUT    
rtdr_tap_tdo[2:0]        Excluded Excluded    Excluded    OUTPUT    
tap_rtdr_tdi[2:0]        Excluded Excluded    Excluded    INPUT     
tap_rtdr_capture[2:0]    Excluded Excluded    Excluded    INPUT     
tap_rtdr_shift[2:0]      Excluded Excluded    Excluded    INPUT     
tap_rtdr_update[2:0]     Excluded Excluded    Excluded    INPUT     
tap_rtdr_selectir        Excluded Excluded    Excluded    INPUT     
tap_rtdr_powergood       Excluded Excluded    Excluded    INPUT     
tap_rtdr_prog_rst_b[2:0] Excluded Excluded    Excluded    INPUT     
tap_rtdr_irdec[2:0]      Excluded Excluded    Excluded    INPUT     
tap_rtdr_tck             Excluded Excluded    Excluded    INPUT     
tap_rtdr_rti             Excluded Excluded    Excluded    INPUT     

Signal Details
                       Toggle   Toggle 1->0 Toggle 0->1 
scan_reg[2:0]          Excluded Excluded    Excluded    
runbist_reg            Excluded Excluded    Excluded    
ftap_tdi_delayed       Excluded Excluded    Excluded    
pre_fbscan_tdo         Excluded Excluded    Excluded    
rtdr_shift_reg2[31:0]  Excluded Excluded    Excluded    
rtdr_shadow_reg2[31:0] Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Module : \STAP_TB_LIB.emulate_stap_tdo (X)
         Line No. Total Covered Percent 
Branches          0     0               
TERNARY  194      0     0               
IF       146      0     0               
IF       171      0     0               
IF       175      0     0               
IF       184      0     0               
IF       188      0     0               
IF       293      0     0               


194           assign pre_fbscan_tdo = (stap_fbscan_runbist_en == 1'b1) ? runbist_reg : scan_reg[0];
                                                                       -1-  
                                                                       ==> (Excluded)  
                                                                       ==> (Excluded)  

Branches:

-1- Status   
1   Excluded 
0   Excluded 


146             if ((STAP_EN_TAP_NETWORK == 1) & (atap_enabletap != 0))
                -1-  
147             begin
148                sntapnw_atap_tdo  = sntapnw_ftap_tdi;
                   ==> (Excluded)
149                sntapnw_atap_tdo2 = sntapnw_ftap_tdi2;
150                sn_awtap_wso      = $random;
151             end
152             else
153             begin
154                if (STAP_EN_WTAP_NETWORK == 1)
                   -2-  
155                   begin
156                   sntapnw_atap_tdo  = $random;
                      ==> (Excluded)
157                   sntapnw_atap_tdo2 = $random;
158                   sn_awtap_wso      = atap_wtapnw_wsi;
159                end
160                else
161                begin
162                   sntapnw_atap_tdo  = $random;
                      ==> (Excluded)

Branches:

-1- -2- Status   
1   -   Excluded 
0   1   Excluded 
0   0   Excluded 


171              if ((ftap_trst_b == 1'b0) | (fdfx_powergood == 1'b0))
                 -1-  
172              begin
173                 scan_reg <= 3'h0;
                    ==> (Excluded)
174              end
                 MISSING_ELSE
                 ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


175              if (stap_fbscan_shiftdr == 1'b1)
                 -1-                  
176              begin
177                 scan_reg[(LENGTH_OF_BSCAN_CHAIN - 2):0] <= scan_reg[(LENGTH_OF_BSCAN_CHAIN - 1):(LENGTH_OF_BSCAN_CHAIN - 2)];
                    ==> (Excluded)
178                 scan_reg[(LENGTH_OF_BSCAN_CHAIN - 1)]   <= ftap_tdi_delayed;
179              end
                 MISSING_ELSE
                 ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


184              if ((ftap_trst_b == 1'b0) | (fdfx_powergood == 1'b0))
                 -1-  
185              begin
186                 runbist_reg <= 1'b0;
                    ==> (Excluded)
187              end
                 MISSING_ELSE
                 ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


188              if (stap_fbscan_runbist_en == 1'b1)
                 -1-  
189              begin
190                 runbist_reg <= ftap_tdi_delayed;
                    ==> (Excluded)
191              end
                 MISSING_ELSE
                 ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


293                       if (!tap_rtdr_prog_rst_b[2])
                          -1-  
294                       begin
295                          rtdr_shift_reg2  <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
                             ==> (Excluded)
296                          rtdr_shadow_reg2 <= {(TB_SIZE_OF_REMOTE_TDR_NZ){1'b0}};
297                       end
298                       else if (tap_rtdr_irdec[2] & tap_rtdr_capture[2])
                               -2-  
299                       begin
300                          rtdr_shift_reg2 <= rtdr_shadow_reg2;
                             ==> (Excluded)
301                       end
302                       else if (tap_rtdr_irdec[2] & tap_rtdr_shift[2])
                               -3-                                   
303                       begin
304                          rtdr_shift_reg2 <= {tap_rtdr_tdi[2],rtdr_shift_reg2[(TB_SIZE_OF_REMOTE_TDR_NZ - 1):1]};
                             ==> (Excluded)
305                       end
306                       else if (tap_rtdr_irdec[2] & tap_rtdr_update[2])
                               -4-  
307                       begin
308                          rtdr_shadow_reg2 <= rtdr_shift_reg2;
                             ==> (Excluded)
309                       end
                          MISSING_ELSE
                          ==> (Excluded)

Branches:

-1- -2- -3- -4- Status   
1   -   -   -   Excluded 
0   1   -   -   Excluded 
0   0   1   -   Excluded 
0   0   0   1   Excluded 
0   0   0   0   Excluded 


===============================================================================
Module : top(X)
===============================================================================
SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     

Source File(s) : 

/nfs/iind/disks/dteg_disk007/users/ka2/dteg-stap/target/stap/TGPLP/aceroot/verif/tb/STapTop.sv

Module self-instances :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME   
--     --     --     --     --     --     --     top(X) 



-------------------------------------------------------------------------------
Line Coverage for Module : top(X)

             Line No.   Total   Covered  Percent
TOTAL                        0        0
INITIAL           242        0        0
INITIAL           250        0        0
INITIAL           258        0        0

241                         initial begin : VCD_BLOCK
242        excluded            if (($test$plusargs("DUMP_VCD")) || ($test$plusargs("VCD"))) begin
243        excluded               $display("Dump in VCD format ENABLED");
244        excluded               $vcdplusfile("Dump.vcd");
245        excluded                  $vcdpluson(0,top);
246                            end
                   ==>  MISSING_ELSE
247                         end : VCD_BLOCK
248                     
249                         initial begin : VPD_BLOCK
250        excluded            if (($test$plusargs("DUMP_VPD")) || ($test$plusargs("VPD"))) begin
251        excluded               $display("Dump in VPD format ENABLED");
252        excluded               $vcdplusfile("Dump.vpd");
253        excluded                  $vcdpluson(0,top);
254                            end
                   ==>  MISSING_ELSE
255                         end : VPD_BLOCK
256                     
257                         initial begin : FSDB_BLOCK
258        excluded            if (($test$plusargs("DUMP")) || ($test$plusargs("FSDB"))) begin
259        excluded               $display("Dump ENABLED");
260        excluded               $fsdbDumpfile("Dump.fsdb");
261        excluded               $fsdbDumpSVAon; 
262                               `ifdef POWERVCD
263                               $fsdbDumpvars(stap,"+all");
264                               `else
265        excluded               $fsdbDumpvars("+all");
266                               `endif
267        excluded             $fsdbDumpSVAoff;
268                            end
                   ==>  MISSING_ELSE

-------------------------------------------------------------------------------
Toggle Coverage for Module : top(X)
Signal Details
                   Toggle   Toggle 1->0 Toggle 0->1 
soc_fdfx_powergood Excluded Excluded    Excluded    
soc_clock          Excluded Excluded    Excluded    
op34[31:0]         Excluded Excluded    Excluded    
op6B[31:0]         Excluded Excluded    Excluded    


-------------------------------------------------------------------------------
Branch Coverage for Module : top(X)
         Line No. Total Covered Percent 
Branches          0     0               
IF       242      0     0               
IF       250      0     0               
IF       258      0     0               


242               if (($test$plusargs("DUMP_VCD")) || ($test$plusargs("VCD"))) begin
                  -1-  
243                  $display("Dump in VCD format ENABLED");
                     ==> (Excluded)
244                  $vcdplusfile("Dump.vcd");
245                     $vcdpluson(0,top);
246               end
                  MISSING_ELSE
                  ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


250               if (($test$plusargs("DUMP_VPD")) || ($test$plusargs("VPD"))) begin
                  -1-  
251                  $display("Dump in VPD format ENABLED");
                     ==> (Excluded)
252                  $vcdplusfile("Dump.vpd");
253                     $vcdpluson(0,top);
254               end
                  MISSING_ELSE
                  ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


258               if (($test$plusargs("DUMP")) || ($test$plusargs("FSDB"))) begin
                  -1-  
259                  $display("Dump ENABLED");
                     ==> (Excluded)
260                  $fsdbDumpfile("Dump.fsdb");
261                  $fsdbDumpSVAon; 
262                  `ifdef POWERVCD
263                  $fsdbDumpvars(stap,"+all");
264                  `else
265                  $fsdbDumpvars("+all");
266                  `endif
267                $fsdbDumpSVAoff;
268               end
                  MISSING_ELSE
                  ==> (Excluded)

Branches:

-1- Status   
1   Excluded 
0   Excluded 


-------------------------------------------------------------------------------
===============================================================================
Module Instance : top(X)
===============================================================================

Instance :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
--     --     --     --     --     --     --     


Instance's subtree :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT 
 99.59 100.00 100.00  99.98 100.00 100.00  97.56 


Module : 

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME   
--     --     --     --     --     --     --     top(X) 


Parent : 

none
----------------


Subtrees :

SCORE  LINE   COND   TOGGLE FSM    BRANCH ASSERT NAME               
100.00 --     --     --     --     --     100.00 Primary_if         
100.00 --     --     --     --     --     100.00 i_TapTestIsland(X) 
 99.57 100.00 100.00  99.98 100.00 100.00  97.47 stap_top_inst(x)   



-------------------------------------------------------------------------------
Since this is the module's only instance, the coverage report is the same as for the module.
