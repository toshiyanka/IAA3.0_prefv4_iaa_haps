
//  INTEL CONFIDENTIAL
//
//  Copyright 2023 Intel Corporation All Rights Reserved.
//
//  The source code contained or described herein and all documents related
//  to the source code ("Material") are owned by Intel Corporation or its
//  suppliers or licensors. Title to the Material remains with Intel
//  Corporation or its suppliers and licensors. The Material contains trade
//  secrets and proprietary and confidential information of Intel or its
//  suppliers and licensors. The Material is protected by worldwide copyright
//  and trade secret laws and treaty provisions. No part of the Material may
//  be used, copied, reproduced, modified, published, uploaded, posted,
//  transmitted, distributed, or disclosed in any way without Intel's prior
//  express written permission.
//
//  No license under any patent, copyright, trade secret or other intellectual
//  property right is granted to or conferred upon you by disclosure or
//  delivery of the Materials, either expressly, by implication, inducement,
//  estoppel or otherwise. Any license under such intellectual property rights
//  must be express and approved by Intel in writing.
//

//------------------------------------------------------------------------------------------------------------------------
// Intel Proprietary        Intel Confidential        Intel Proprietary        Intel Confidential        Intel Proprietary
//------------------------------------------------------------------------------------------------------------------------
// Generated by                  : cudoming
// Generated on                  : April 18, 2023
//------------------------------------------------------------------------------------------------------------------------
// General Information:
// ------------------------------
// 1r1w0c standard array DFX wrapper for SDG server designs.
// Synthesizable RTL for array DFX wrapper.
// RTL is written in SystemVerilog.
//------------------------------------------------------------------------------------------------------------------------
// Detail Information:
// ------------------------------
// Addresses        : RD/WR addresses are encoded.
//                    Input addresses will be valid at the array in 1 phases after being driven.
//                    Address latency of 1 is corresponding to a B-latch.
// Enables          : RD/WR enables are used to condition the clock and wordlines.
//                  : Input enables will be valid at the array in 1 phases after being driven.
//                    Enable latency of 1 is corresponding to a B-latch.
// Write Data       : Write data will be valid at the array 2 phases after being driven.
//                    Write data latency of 2 is corresponding to a rising-edge flop. 
// Read Data        : Read data will be valid at the output of a SDL 1 phase after being read.
//                    Read data latency of 1 is corresponding to a B-latch.
// Address Offset   : 
//------------------------------------------------------------------------------------------------------------------------

//------------------------------------------------------------------------------------------------------------------------
// Other Information:
// ------------------------------
// SDG RFIP RTL Release Path:
// /p/hdk/rtl/ip_releases/shdk74/array_macro_module
//
//------------------------------------------------------------------------------------------------------------------------


MemoryTemplate (arf030b256e1r1w0cbbeheaa4acw_dfx_wrapper) {

  CellName              : arf030b256e1r1w0cbbeheaa4acw_dfx_wrapper;
  MemoryType            : SRAM;
  LogicalPorts          : 1R1W;    //1R1W0C
  NumberofWords         : 256;
  NumberofBits          : 30;
  //BitGrouping           : 1;
  Algorithm             : IntelLVMarchCMinusFx;
  OperationSet          : SyncCustom;
  ConcurrentRead        : Off;
  ConcurrentWrite       : On;
  ShadowRead            : On;
  ShadowWrite           : Off;
  MinHold               : 0.00;
  DataOutStage          : None;
  InternalScanLogic     : On;
  ObservationLogic      : Off;
  TransparentMode       : None;
  
  //ArrayType            : Standard Array;
  //ReadPhase            : Phase A;
  //WritePhase           : Phase A;
  //AddressDecoding      : Encoded Address;
  //RedundantColumns     : 1;
  //RedundantRows        : 1;


  AddressCounter {
    Function (Address) {
      LogicalAddressMap {
        RowAddress[7:0] : Address[7:0];
      }
    }
    Function (RowAddress) {
      CountRange[255:0];  //Encoded Address
    }
  }

 
  Port ( FUNC_WR_CLK_IN_P0 ) {
    LogicalPort: Write_Ports_0;
    Direction:   Input;
    Function:    Clock;
    Polarity:    ActiveHigh;
    EmbeddedTestLogic {
      TestInput: BIST_WR_CLK_IN_P0;
    }
  }

  Port ( FUNC_WR_EN_IN_P0 ) {
    LogicalPort: Write_Ports_0;
    Direction:   Input;
    Function:    WriteEnable;
    DisableDuringScan: Off;
    Polarity:    ActiveHigh;
    EmbeddedTestLogic {
      TestInput: BIST_WR_EN_IN_P0;
    }
  }


  Port ( FUNC_WR_ADDR_IN_P0[7:0] ) {
    LogicalPort: Write_Ports_0;
    Direction:   Input;
    Function:    Address;
    EmbeddedTestLogic {
      TestInput: BIST_WR_ADDR_IN_P0[7:0];
    }
  }

  Port ( FUNC_WR_DATA_IN_P0[29:0] ) {
    LogicalPort: Write_Ports_0;
    Direction:   Input;
    Function:    Data;
    EmbeddedTestLogic {
      TestInput: BIST_WR_DATA_IN_P0[29:0];
    }
  }

  Port ( WRAPPER_WR_CLK_EN_P0 ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   1;
  }

  Port ( GLOBAL_RROW_EN_IN_WR_P0)  { 
    Direction: Input; 
    Function: None; 
    Polarity: ActiveHigh;
    SafeValue: 1'b0;
  }

   
 
  Port ( FUNC_RD_CLK_IN_P0 ) {
    LogicalPort: Read_Ports_0;
    Direction:   Input;
    Function:    Clock;
    Polarity:    ActiveHigh;
    EmbeddedTestLogic {
      TestInput: BIST_RD_CLK_IN_P0;
    }
  }

  Port ( FUNC_RD_EN_IN_P0 ) {
    LogicalPort: Read_Ports_0;
    Direction:   Input;
    Function:    ReadEnable;
    DisableDuringScan: Off;
    Polarity:    ActiveHigh;
    EmbeddedTestLogic {
      TestInput: BIST_RD_EN_IN_P0;
    }
  }


  Port ( FUNC_RD_ADDR_IN_P0[7:0] ) {
    LogicalPort: Read_Ports_0;
    Direction:   Input;
    Function:    Address;
    EmbeddedTestLogic {
      TestInput: BIST_RD_ADDR_IN_P0[7:0];
    }
  }

  Port ( DATA_OUT_P0[29:0] ) {
    LogicalPort: Read_Ports_0;
    Direction:   Output;
    Function:    Data;
  }

  Port ( OUTPUT_RESET_P0 ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   0;
  }

  
   Port ( WRAPPER_RD_CLK_EN_P0 ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   1;
  } 

  Port ( GLOBAL_RROW_EN_IN_RD_P0)  { 
    Direction: Input; 
    Function: None; 
    Polarity: ActiveHigh;
    SafeValue: 1'b0; 
  } 



  Port ( BIST_ENABLE ) {
    Direction:   Input;
    Function:    BistEn;
    Polarity:    ActiveHigh;
  }

  Port ( flcp_fd[2:0] ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   3'b000;
  }

  Port ( flcp_rd[2:0] ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   3'b000;
  }


  Port ( IP_RESET_B ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveLow;
    SafeValue:   1'b1;
  }
  
  Port ( COL_REPAIR_IN[12:0] ) {
    Direction:   Input;
    Function:    BisrParallelData;
    Polarity:    ActiveHigh;
    
  }

  Port ( ROW_REPAIR_IN[12:0] ) {
    Direction:   Input;
    Function:    BisrParallelData;
    Polarity:    ActiveHigh;
    
  }

  Port ( FSCAN_RAM_RDIS_B ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveLow;
    SafeValue:   1;
  }

  Port ( FSCAN_RAM_WDIS_B ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveLow;
    SafeValue:   1;
  }
  

  Port ( FSCAN_RAM_INIT_EN ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   0;
  }

  Port ( FSCAN_RAM_INIT_VAL ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   0;
  }

  Port ( FSCAN_RAM_BYPSEL ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   0;
  }

  Port ( FSCAN_CLKUNGATE ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   0;
  }

  Port ( ISOLATION_CONTROL_IN ) {
    Direction: Input;
    Function: None;
    Polarity: ActiveHigh;
    Safevalue: 1'b0;
  }

  Port ( ARRAY_FREEZE ) {
    Direction: Input;
    Function: None;
    Polarity: ActiveHigh;
    Safevalue: 1'b0;
  }

  Port ( SLEEP_FUSE_IN ) {
    Direction: Input;
    Function: None;
    Polarity: ActiveHigh;
    Safevalue: 1'b0;
  }

  Port ( TRIM_FUSE_IN[19:0] ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   20'b00000000000000000000;
  }

  Port ( PWR_MGMT_IN[3:0] ) {
    Direction:   Input;
    Function:    None;
    Polarity:    ActiveHigh;
    SafeValue:   4'b0000;
  }

  Port ( PWR_MGMT_OUT[3:0] ) {
    Direction:   Output;
    Function:    None;
    Polarity:    ActiveHigh;
  }

 
//----- Start of Redundancy Analysis Segment -------------

  RedundancyAnalysis { 
    
    ColumnSegment(All) {
      NumberOfSpareElements : 1;
      ShiftedIORange : DATA_OUT_P0[29:0] ;
      FuseSet {
        FuseMap[4:0] {
          ShiftedIO(DATA_OUT_P0[0]) : 5'b00000;
          ShiftedIO(DATA_OUT_P0[1]) : 5'b00001;
          ShiftedIO(DATA_OUT_P0[2]) : 5'b00010;
          ShiftedIO(DATA_OUT_P0[3]) : 5'b00011;
          ShiftedIO(DATA_OUT_P0[4]) : 5'b00100;
          ShiftedIO(DATA_OUT_P0[5]) : 5'b00101;
          ShiftedIO(DATA_OUT_P0[6]) : 5'b00110;
          ShiftedIO(DATA_OUT_P0[7]) : 5'b00111;
          ShiftedIO(DATA_OUT_P0[8]) : 5'b01000;
          ShiftedIO(DATA_OUT_P0[9]) : 5'b01001;
          ShiftedIO(DATA_OUT_P0[10]) : 5'b01010;
          ShiftedIO(DATA_OUT_P0[11]) : 5'b01011;
          ShiftedIO(DATA_OUT_P0[12]) : 5'b01100;
          ShiftedIO(DATA_OUT_P0[13]) : 5'b01101;
          ShiftedIO(DATA_OUT_P0[14]) : 5'b01110;
          ShiftedIO(DATA_OUT_P0[15]) : 5'b01111;
          ShiftedIO(DATA_OUT_P0[16]) : 5'b10000;
          ShiftedIO(DATA_OUT_P0[17]) : 5'b10001;
          ShiftedIO(DATA_OUT_P0[18]) : 5'b10010;
          ShiftedIO(DATA_OUT_P0[19]) : 5'b10011;
          ShiftedIO(DATA_OUT_P0[20]) : 5'b10100;
          ShiftedIO(DATA_OUT_P0[21]) : 5'b10101;
          ShiftedIO(DATA_OUT_P0[22]) : 5'b10110;
          ShiftedIO(DATA_OUT_P0[23]) : 5'b10111;
          ShiftedIO(DATA_OUT_P0[24]) : 5'b11000;
          ShiftedIO(DATA_OUT_P0[25]) : 5'b11001;
          ShiftedIO(DATA_OUT_P0[26]) : 5'b11010;
          ShiftedIO(DATA_OUT_P0[27]) : 5'b11011;
          ShiftedIO(DATA_OUT_P0[28]) : 5'b11100;
          ShiftedIO(DATA_OUT_P0[29]) : 5'b11101;
        }
      }
      PinMap {
        SpareElement {
          RepairEnable:COL_REPAIR_IN[0];
          FuseMap[0]: COL_REPAIR_IN[1];
          FuseMap[1]: COL_REPAIR_IN[2];
          FuseMap[2]: COL_REPAIR_IN[3];
          FuseMap[3]: COL_REPAIR_IN[4];
          FuseMap[4]: COL_REPAIR_IN[5];
        }
      }
    }  
//--------------------ROW Repair-----------------//
    
    RowSegment(ALL) {
      NumberOfSpareElements : 1;
      FuseSet {
        Fuse[0] : AddressPort(FUNC_RD_ADDR_IN_P0[0]);
        Fuse[1] : AddressPort(FUNC_RD_ADDR_IN_P0[1]);
        Fuse[2] : AddressPort(FUNC_RD_ADDR_IN_P0[2]);
        Fuse[3] : AddressPort(FUNC_RD_ADDR_IN_P0[3]);
        Fuse[4] : AddressPort(FUNC_RD_ADDR_IN_P0[4]);
        Fuse[5] : AddressPort(FUNC_RD_ADDR_IN_P0[5]);
        Fuse[6] : AddressPort(FUNC_RD_ADDR_IN_P0[6]);
        Fuse[7] : AddressPort(FUNC_RD_ADDR_IN_P0[7]);
      }
      PinMap {
        SpareElement {
          RepairEnable:ROW_REPAIR_IN[0];
          Fuse[0]: ROW_REPAIR_IN[1];
          Fuse[1]: ROW_REPAIR_IN[2];
          Fuse[2]: ROW_REPAIR_IN[3];
          Fuse[3]: ROW_REPAIR_IN[4];
          Fuse[4]: ROW_REPAIR_IN[5];
          Fuse[5]: ROW_REPAIR_IN[6];
          Fuse[6]: ROW_REPAIR_IN[7];
          Fuse[7]: ROW_REPAIR_IN[8];
        }
      }
    }
  } 

} //end MemoryTemplate (arf030b256e1r1w0cbbeheaa4acw_dfx_wrapper)